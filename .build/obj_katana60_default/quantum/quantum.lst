   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB29:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** 
  19:quantum/quantum.c **** #if !defined(RGBLIGHT_ENABLE) && !defined(RGB_MATRIX_ENABLE)
  20:quantum/quantum.c **** 	#include "rgb.h"
  21:quantum/quantum.c **** #endif
  22:quantum/quantum.c **** 
  23:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  24:quantum/quantum.c **** #include "outputselect.h"
  25:quantum/quantum.c **** #endif
  26:quantum/quantum.c **** 
  27:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  28:quantum/quantum.c **** #define BREATHING_PERIOD 6
  29:quantum/quantum.c **** #endif
  30:quantum/quantum.c **** 
  31:quantum/quantum.c **** #include "backlight.h"
  32:quantum/quantum.c **** extern backlight_config_t backlight_config;
  33:quantum/quantum.c **** 
  34:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  35:quantum/quantum.c **** #include "fauxclicky.h"
  36:quantum/quantum.c **** #endif
  37:quantum/quantum.c **** 
  38:quantum/quantum.c **** #ifdef API_ENABLE
  39:quantum/quantum.c **** #include "api.h"
  40:quantum/quantum.c **** #endif
  41:quantum/quantum.c **** 
  42:quantum/quantum.c **** #ifdef MIDI_ENABLE
  43:quantum/quantum.c **** #include "process_midi.h"
  44:quantum/quantum.c **** #endif
  45:quantum/quantum.c **** 
  46:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
  47:quantum/quantum.c **** #include "velocikey.h"
  48:quantum/quantum.c **** #endif
  49:quantum/quantum.c **** 
  50:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
  51:quantum/quantum.c ****     #include "haptic.h"
  52:quantum/quantum.c **** #endif
  53:quantum/quantum.c **** 
  54:quantum/quantum.c **** #ifdef ENCODER_ENABLE
  55:quantum/quantum.c **** #include "encoder.h"
  56:quantum/quantum.c **** #endif
  57:quantum/quantum.c **** 
  58:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  59:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  60:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  61:quantum/quantum.c ****   #endif
  62:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  63:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  64:quantum/quantum.c ****   #endif
  65:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  66:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  67:quantum/quantum.c ****   #endif
  68:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  69:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  70:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  71:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  72:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  73:quantum/quantum.c ****   #endif
  74:quantum/quantum.c **** #endif
  75:quantum/quantum.c **** 
  76:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 76 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 8C01      		movw r16,r24
  39 000a EB01      		movw r28,r22
  77:quantum/quantum.c ****   switch (code) {
  40               		.loc 1 77 0
  41 000c 9A95      		dec r25
  42               	.LVL1:
  43 000e 8115      		cp r24,__zero_reg__
  44 0010 9F41      		sbci r25,31
  45 0012 00F4      		brsh .L1
  78:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  79:quantum/quantum.c ****     break;
  80:quantum/quantum.c ****   default:
  81:quantum/quantum.c ****     return;
  82:quantum/quantum.c ****   }
  83:quantum/quantum.c **** 
  84:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 84 0
  47 0014 10FF      		sbrs r17,0
  48 0016 00C0      		rjmp .L4
  85:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 85 0
  50 0018 80EE      		ldi r24,lo8(-32)
  51 001a FB01      		movw r30,r22
  52 001c 0995      		icall
  53               	.LVL2:
  54               	.L4:
  86:quantum/quantum.c ****   if (code & QK_LSFT)
  55               		.loc 1 86 0
  56 001e 11FF      		sbrs r17,1
  57 0020 00C0      		rjmp .L5
  87:quantum/quantum.c ****     f(KC_LSFT);
  58               		.loc 1 87 0
  59 0022 81EE      		ldi r24,lo8(-31)
  60 0024 FE01      		movw r30,r28
  61 0026 0995      		icall
  62               	.LVL3:
  63               	.L5:
  88:quantum/quantum.c ****   if (code & QK_LALT)
  64               		.loc 1 88 0
  65 0028 12FF      		sbrs r17,2
  66 002a 00C0      		rjmp .L6
  89:quantum/quantum.c ****     f(KC_LALT);
  67               		.loc 1 89 0
  68 002c 82EE      		ldi r24,lo8(-30)
  69 002e FE01      		movw r30,r28
  70 0030 0995      		icall
  71               	.LVL4:
  72               	.L6:
  90:quantum/quantum.c ****   if (code & QK_LGUI)
  73               		.loc 1 90 0
  74 0032 13FF      		sbrs r17,3
  75 0034 00C0      		rjmp .L7
  91:quantum/quantum.c ****     f(KC_LGUI);
  76               		.loc 1 91 0
  77 0036 83EE      		ldi r24,lo8(-29)
  78 0038 FE01      		movw r30,r28
  79 003a 0995      		icall
  80               	.LVL5:
  81               	.L7:
  92:quantum/quantum.c **** 
  93:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  82               		.loc 1 93 0
  83 003c 0115      		cp r16,__zero_reg__
  84 003e 1041      		sbci r17,16
  85 0040 00F4      		brsh .L21
  86               	.L1:
  87               	/* epilogue start */
  94:quantum/quantum.c **** 
  95:quantum/quantum.c ****   if (code & QK_RCTL)
  96:quantum/quantum.c ****     f(KC_RCTL);
  97:quantum/quantum.c ****   if (code & QK_RSFT)
  98:quantum/quantum.c ****     f(KC_RSFT);
  99:quantum/quantum.c ****   if (code & QK_RALT)
 100:quantum/quantum.c ****     f(KC_RALT);
 101:quantum/quantum.c ****   if (code & QK_RGUI)
 102:quantum/quantum.c ****     f(KC_RGUI);
 103:quantum/quantum.c **** }
  88               		.loc 1 103 0
  89 0042 DF91      		pop r29
  90 0044 CF91      		pop r28
  91               	.LVL6:
  92 0046 1F91      		pop r17
  93 0048 0F91      		pop r16
  94               	.LVL7:
  95 004a 0895      		ret
  96               	.LVL8:
  97               	.L21:
  96:quantum/quantum.c ****   if (code & QK_RSFT)
  98               		.loc 1 96 0
  99 004c 84EE      		ldi r24,lo8(-28)
 100 004e FE01      		movw r30,r28
 101 0050 0995      		icall
 102               	.LVL9:
  98:quantum/quantum.c ****   if (code & QK_RALT)
 103               		.loc 1 98 0
 104 0052 85EE      		ldi r24,lo8(-27)
 105 0054 FE01      		movw r30,r28
 106 0056 0995      		icall
 107               	.LVL10:
 100:quantum/quantum.c ****   if (code & QK_RGUI)
 108               		.loc 1 100 0
 109 0058 86EE      		ldi r24,lo8(-26)
 110 005a FE01      		movw r30,r28
 111 005c 0995      		icall
 112               	.LVL11:
 102:quantum/quantum.c **** }
 113               		.loc 1 102 0
 114 005e 87EE      		ldi r24,lo8(-25)
 115 0060 FE01      		movw r30,r28
 116               	/* epilogue start */
 117               		.loc 1 103 0
 118 0062 DF91      		pop r29
 119 0064 CF91      		pop r28
 120               	.LVL12:
 121 0066 1F91      		pop r17
 122 0068 0F91      		pop r16
 123               	.LVL13:
 102:quantum/quantum.c **** }
 124               		.loc 1 102 0
 125 006a 0994      		ijmp
 126               	.LVL14:
 127               		.cfi_endproc
 128               	.LFE29:
 130               		.section	.text.qk_register_weak_mods,"ax",@progbits
 132               	qk_register_weak_mods:
 133               	.LFB30:
 104:quantum/quantum.c **** 
 105:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 134               		.loc 1 105 0
 135               		.cfi_startproc
 136               	.LVL15:
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
 106:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 141               		.loc 1 106 0
 142 0000 8770      		andi r24,lo8(7)
 143               	.LVL16:
 144 0002 91E0      		ldi r25,lo8(1)
 145 0004 00C0      		rjmp 2f
 146               		1:
 147 0006 990F      		lsl r25
 148               		2:
 149 0008 8A95      		dec r24
 150 000a 02F4      		brpl 1b
 151 000c 892F      		mov r24,r25
 152 000e 0E94 0000 		call add_weak_mods
 153               	.LVL17:
 107:quantum/quantum.c ****     send_keyboard_report();
 154               		.loc 1 107 0
 155 0012 0C94 0000 		jmp send_keyboard_report
 156               	.LVL18:
 157               		.cfi_endproc
 158               	.LFE30:
 160               		.section	.text.qk_register_mods,"ax",@progbits
 162               	qk_register_mods:
 163               	.LFB101:
 164               		.cfi_startproc
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 169 0000 0C94 0000 		jmp qk_register_weak_mods
 170               		.cfi_endproc
 171               	.LFE101:
 173               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 175               	qk_unregister_weak_mods:
 176               	.LFB31:
 108:quantum/quantum.c **** }
 109:quantum/quantum.c **** 
 110:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 177               		.loc 1 110 0
 178               		.cfi_startproc
 179               	.LVL19:
 180               	/* prologue: function */
 181               	/* frame size = 0 */
 182               	/* stack size = 0 */
 183               	.L__stack_usage = 0
 111:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 184               		.loc 1 111 0
 185 0000 8770      		andi r24,lo8(7)
 186               	.LVL20:
 187 0002 91E0      		ldi r25,lo8(1)
 188 0004 00C0      		rjmp 2f
 189               		1:
 190 0006 990F      		lsl r25
 191               		2:
 192 0008 8A95      		dec r24
 193 000a 02F4      		brpl 1b
 194 000c 892F      		mov r24,r25
 195 000e 0E94 0000 		call del_weak_mods
 196               	.LVL21:
 112:quantum/quantum.c ****     send_keyboard_report();
 197               		.loc 1 112 0
 198 0012 0C94 0000 		jmp send_keyboard_report
 199               	.LVL22:
 200               		.cfi_endproc
 201               	.LFE31:
 203               		.section	.text.qk_unregister_mods,"ax",@progbits
 205               	qk_unregister_mods:
 206               	.LFB103:
 207               		.cfi_startproc
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 0 */
 211               	.L__stack_usage = 0
 212 0000 0C94 0000 		jmp qk_unregister_weak_mods
 213               		.cfi_endproc
 214               	.LFE103:
 216               		.section	.text.rgblight_toggle,"ax",@progbits
 217               		.weak	rgblight_toggle
 219               	rgblight_toggle:
 220               	.LFB75:
 221               		.cfi_startproc
 222               	/* prologue: function */
 223               	/* frame size = 0 */
 224               	/* stack size = 0 */
 225               	.L__stack_usage = 0
 226               	/* epilogue start */
 227 0000 0895      		ret
 228               		.cfi_endproc
 229               	.LFE75:
 231               		.section	.text.rgblight_step,"ax",@progbits
 232               		.weak	rgblight_step
 234               	rgblight_step:
 235               	.LFB77:
 236               		.cfi_startproc
 237               	/* prologue: function */
 238               	/* frame size = 0 */
 239               	/* stack size = 0 */
 240               	.L__stack_usage = 0
 241               	/* epilogue start */
 242 0000 0895      		ret
 243               		.cfi_endproc
 244               	.LFE77:
 246               		.section	.text.rgblight_step_reverse,"ax",@progbits
 247               		.weak	rgblight_step_reverse
 249               	rgblight_step_reverse:
 250               	.LFB79:
 251               		.cfi_startproc
 252               	/* prologue: function */
 253               	/* frame size = 0 */
 254               	/* stack size = 0 */
 255               	.L__stack_usage = 0
 256               	/* epilogue start */
 257 0000 0895      		ret
 258               		.cfi_endproc
 259               	.LFE79:
 261               		.section	.text.rgblight_increase_hue,"ax",@progbits
 262               		.weak	rgblight_increase_hue
 264               	rgblight_increase_hue:
 265               	.LFB81:
 266               		.cfi_startproc
 267               	/* prologue: function */
 268               	/* frame size = 0 */
 269               	/* stack size = 0 */
 270               	.L__stack_usage = 0
 271               	/* epilogue start */
 272 0000 0895      		ret
 273               		.cfi_endproc
 274               	.LFE81:
 276               		.section	.text.rgblight_decrease_hue,"ax",@progbits
 277               		.weak	rgblight_decrease_hue
 279               	rgblight_decrease_hue:
 280               	.LFB83:
 281               		.cfi_startproc
 282               	/* prologue: function */
 283               	/* frame size = 0 */
 284               	/* stack size = 0 */
 285               	.L__stack_usage = 0
 286               	/* epilogue start */
 287 0000 0895      		ret
 288               		.cfi_endproc
 289               	.LFE83:
 291               		.section	.text.rgblight_increase_sat,"ax",@progbits
 292               		.weak	rgblight_increase_sat
 294               	rgblight_increase_sat:
 295               	.LFB85:
 296               		.cfi_startproc
 297               	/* prologue: function */
 298               	/* frame size = 0 */
 299               	/* stack size = 0 */
 300               	.L__stack_usage = 0
 301               	/* epilogue start */
 302 0000 0895      		ret
 303               		.cfi_endproc
 304               	.LFE85:
 306               		.section	.text.rgblight_decrease_sat,"ax",@progbits
 307               		.weak	rgblight_decrease_sat
 309               	rgblight_decrease_sat:
 310               	.LFB87:
 311               		.cfi_startproc
 312               	/* prologue: function */
 313               	/* frame size = 0 */
 314               	/* stack size = 0 */
 315               	.L__stack_usage = 0
 316               	/* epilogue start */
 317 0000 0895      		ret
 318               		.cfi_endproc
 319               	.LFE87:
 321               		.section	.text.rgblight_increase_val,"ax",@progbits
 322               		.weak	rgblight_increase_val
 324               	rgblight_increase_val:
 325               	.LFB89:
 326               		.cfi_startproc
 327               	/* prologue: function */
 328               	/* frame size = 0 */
 329               	/* stack size = 0 */
 330               	.L__stack_usage = 0
 331               	/* epilogue start */
 332 0000 0895      		ret
 333               		.cfi_endproc
 334               	.LFE89:
 336               		.section	.text.rgblight_decrease_val,"ax",@progbits
 337               		.weak	rgblight_decrease_val
 339               	rgblight_decrease_val:
 340               	.LFB91:
 341               		.cfi_startproc
 342               	/* prologue: function */
 343               	/* frame size = 0 */
 344               	/* stack size = 0 */
 345               	.L__stack_usage = 0
 346               	/* epilogue start */
 347 0000 0895      		ret
 348               		.cfi_endproc
 349               	.LFE91:
 351               		.section	.text.rgblight_increase_speed,"ax",@progbits
 352               		.weak	rgblight_increase_speed
 354               	rgblight_increase_speed:
 355               	.LFB93:
 356               		.cfi_startproc
 357               	/* prologue: function */
 358               	/* frame size = 0 */
 359               	/* stack size = 0 */
 360               	.L__stack_usage = 0
 361               	/* epilogue start */
 362 0000 0895      		ret
 363               		.cfi_endproc
 364               	.LFE93:
 366               		.section	.text.rgblight_decrease_speed,"ax",@progbits
 367               		.weak	rgblight_decrease_speed
 369               	rgblight_decrease_speed:
 370               	.LFB95:
 371               		.cfi_startproc
 372               	/* prologue: function */
 373               	/* frame size = 0 */
 374               	/* stack size = 0 */
 375               	.L__stack_usage = 0
 376               	/* epilogue start */
 377 0000 0895      		ret
 378               		.cfi_endproc
 379               	.LFE95:
 381               		.section	.text.register_code16,"ax",@progbits
 382               	.global	register_code16
 384               	register_code16:
 385               	.LFB34:
 113:quantum/quantum.c **** }
 114:quantum/quantum.c **** 
 115:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 116:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 117:quantum/quantum.c ****     send_keyboard_report();
 118:quantum/quantum.c **** }
 119:quantum/quantum.c **** 
 120:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 121:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 122:quantum/quantum.c ****     send_keyboard_report();
 123:quantum/quantum.c **** }
 124:quantum/quantum.c **** 
 125:quantum/quantum.c **** void register_code16 (uint16_t code) {
 386               		.loc 1 125 0
 387               		.cfi_startproc
 388               	.LVL23:
 389               		.loc 1 125 0
 390 0000 CF93      		push r28
 391               	.LCFI4:
 392               		.cfi_def_cfa_offset 3
 393               		.cfi_offset 28, -2
 394 0002 DF93      		push r29
 395               	.LCFI5:
 396               		.cfi_def_cfa_offset 4
 397               		.cfi_offset 29, -3
 398               	/* prologue: function */
 399               	/* frame size = 0 */
 400               	/* stack size = 2 */
 401               	.L__stack_usage = 2
 402 0004 EC01      		movw r28,r24
 126:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 403               		.loc 1 126 0
 404 0006 805E      		subi r24,-32
 405 0008 9109      		sbc r25,__zero_reg__
 406               	.LVL24:
 407 000a 0897      		sbiw r24,8
 408 000c 00F0      		brlo .L38
 127:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 128:quantum/quantum.c ****   } else {
 129:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 409               		.loc 1 129 0 discriminator 1
 410 000e 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 411 0010 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 126:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 412               		.loc 1 126 0 discriminator 1
 413 0012 2097      		sbiw r28,0
 414 0014 01F4      		brne .L41
 415               	.L38:
 127:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 416               		.loc 1 127 0
 417 0016 60E0      		ldi r22,lo8(gs(qk_register_mods))
 418 0018 70E0      		ldi r23,hi8(gs(qk_register_mods))
 419               	.L41:
 420               		.loc 1 129 0
 421 001a CE01      		movw r24,r28
 422 001c 0E94 0000 		call do_code16
 423               	.LVL25:
 130:quantum/quantum.c ****   }
 131:quantum/quantum.c ****   register_code (code);
 424               		.loc 1 131 0
 425 0020 8C2F      		mov r24,r28
 426               	/* epilogue start */
 132:quantum/quantum.c **** }
 427               		.loc 1 132 0
 428 0022 DF91      		pop r29
 429 0024 CF91      		pop r28
 430               	.LVL26:
 131:quantum/quantum.c **** }
 431               		.loc 1 131 0
 432 0026 0C94 0000 		jmp register_code
 433               	.LVL27:
 434               		.cfi_endproc
 435               	.LFE34:
 437               		.section	.text.unregister_code16,"ax",@progbits
 438               	.global	unregister_code16
 440               	unregister_code16:
 441               	.LFB35:
 133:quantum/quantum.c **** 
 134:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 442               		.loc 1 134 0
 443               		.cfi_startproc
 444               	.LVL28:
 445 0000 CF93      		push r28
 446               	.LCFI6:
 447               		.cfi_def_cfa_offset 3
 448               		.cfi_offset 28, -2
 449 0002 DF93      		push r29
 450               	.LCFI7:
 451               		.cfi_def_cfa_offset 4
 452               		.cfi_offset 29, -3
 453               	/* prologue: function */
 454               	/* frame size = 0 */
 455               	/* stack size = 2 */
 456               	.L__stack_usage = 2
 457 0004 EC01      		movw r28,r24
 135:quantum/quantum.c ****   unregister_code (code);
 458               		.loc 1 135 0
 459 0006 0E94 0000 		call unregister_code
 460               	.LVL29:
 136:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 461               		.loc 1 136 0
 462 000a CE01      		movw r24,r28
 463 000c 805E      		subi r24,-32
 464 000e 9109      		sbc r25,__zero_reg__
 465 0010 0897      		sbiw r24,8
 466 0012 00F0      		brlo .L43
 137:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 138:quantum/quantum.c ****   } else {
 139:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 467               		.loc 1 139 0 discriminator 1
 468 0014 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 469 0016 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 136:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 470               		.loc 1 136 0 discriminator 1
 471 0018 2097      		sbiw r28,0
 472 001a 01F4      		brne .L45
 473               	.L43:
 137:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 474               		.loc 1 137 0
 475 001c 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 476 001e 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 477               	.L45:
 478               		.loc 1 139 0
 479 0020 CE01      		movw r24,r28
 480               	/* epilogue start */
 140:quantum/quantum.c ****   }
 141:quantum/quantum.c **** }
 481               		.loc 1 141 0
 482 0022 DF91      		pop r29
 483 0024 CF91      		pop r28
 484               	.LVL30:
 139:quantum/quantum.c ****   }
 485               		.loc 1 139 0
 486 0026 0C94 0000 		jmp do_code16
 487               	.LVL31:
 488               		.cfi_endproc
 489               	.LFE35:
 491               		.section	.text.tap_code16,"ax",@progbits
 492               	.global	tap_code16
 494               	tap_code16:
 495               	.LFB36:
 142:quantum/quantum.c **** 
 143:quantum/quantum.c **** void tap_code16(uint16_t code) {
 496               		.loc 1 143 0
 497               		.cfi_startproc
 498               	.LVL32:
 499 0000 CF93      		push r28
 500               	.LCFI8:
 501               		.cfi_def_cfa_offset 3
 502               		.cfi_offset 28, -2
 503 0002 DF93      		push r29
 504               	.LCFI9:
 505               		.cfi_def_cfa_offset 4
 506               		.cfi_offset 29, -3
 507               	/* prologue: function */
 508               	/* frame size = 0 */
 509               	/* stack size = 2 */
 510               	.L__stack_usage = 2
 511 0004 EC01      		movw r28,r24
 144:quantum/quantum.c ****   register_code16(code);
 512               		.loc 1 144 0
 513 0006 0E94 0000 		call register_code16
 514               	.LVL33:
 145:quantum/quantum.c ****   #if TAP_CODE_DELAY > 0
 146:quantum/quantum.c ****     wait_ms(TAP_CODE_DELAY);
 147:quantum/quantum.c ****   #endif
 148:quantum/quantum.c ****   unregister_code16(code);
 515               		.loc 1 148 0
 516 000a CE01      		movw r24,r28
 517               	/* epilogue start */
 149:quantum/quantum.c **** }
 518               		.loc 1 149 0
 519 000c DF91      		pop r29
 520 000e CF91      		pop r28
 521               	.LVL34:
 148:quantum/quantum.c **** }
 522               		.loc 1 148 0
 523 0010 0C94 0000 		jmp unregister_code16
 524               	.LVL35:
 525               		.cfi_endproc
 526               	.LFE36:
 528               		.section	.text.process_action_kb,"ax",@progbits
 529               		.weak	process_action_kb
 531               	process_action_kb:
 532               	.LFB37:
 150:quantum/quantum.c **** 
 151:quantum/quantum.c **** __attribute__ ((weak))
 152:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 533               		.loc 1 152 0
 534               		.cfi_startproc
 535               	.LVL36:
 536               	/* prologue: function */
 537               	/* frame size = 0 */
 538               	/* stack size = 0 */
 539               	.L__stack_usage = 0
 153:quantum/quantum.c ****   return true;
 154:quantum/quantum.c **** }
 540               		.loc 1 154 0
 541 0000 81E0      		ldi r24,lo8(1)
 542               	.LVL37:
 543               	/* epilogue start */
 544 0002 0895      		ret
 545               		.cfi_endproc
 546               	.LFE37:
 548               		.section	.text.process_record_user,"ax",@progbits
 549               		.weak	process_record_user
 551               	process_record_user:
 552               	.LFB39:
 155:quantum/quantum.c **** 
 156:quantum/quantum.c **** __attribute__ ((weak))
 157:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 158:quantum/quantum.c ****   return process_record_user(keycode, record);
 159:quantum/quantum.c **** }
 160:quantum/quantum.c **** 
 161:quantum/quantum.c **** __attribute__ ((weak))
 162:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 553               		.loc 1 162 0
 554               		.cfi_startproc
 555               	.LVL38:
 556               	/* prologue: function */
 557               	/* frame size = 0 */
 558               	/* stack size = 0 */
 559               	.L__stack_usage = 0
 163:quantum/quantum.c ****   return true;
 164:quantum/quantum.c **** }
 560               		.loc 1 164 0
 561 0000 81E0      		ldi r24,lo8(1)
 562               	.LVL39:
 563               	/* epilogue start */
 564 0002 0895      		ret
 565               		.cfi_endproc
 566               	.LFE39:
 568               		.section	.text.process_record_kb,"ax",@progbits
 569               		.weak	process_record_kb
 571               	process_record_kb:
 572               	.LFB38:
 157:quantum/quantum.c ****   return process_record_user(keycode, record);
 573               		.loc 1 157 0
 574               		.cfi_startproc
 575               	.LVL40:
 576               	/* prologue: function */
 577               	/* frame size = 0 */
 578               	/* stack size = 0 */
 579               	.L__stack_usage = 0
 158:quantum/quantum.c **** }
 580               		.loc 1 158 0
 581 0000 0C94 0000 		jmp process_record_user
 582               	.LVL41:
 583               		.cfi_endproc
 584               	.LFE38:
 586               		.section	.text.get_event_keycode,"ax",@progbits
 587               	.global	get_event_keycode
 589               	get_event_keycode:
 590               	.LFB42:
 165:quantum/quantum.c **** 
 166:quantum/quantum.c **** void reset_keyboard(void) {
 167:quantum/quantum.c ****   clear_keyboard();
 168:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 169:quantum/quantum.c ****   process_midi_all_notes_off();
 170:quantum/quantum.c **** #endif
 171:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 172:quantum/quantum.c ****   #ifndef NO_MUSIC_MODE
 173:quantum/quantum.c ****     music_all_notes_off();
 174:quantum/quantum.c ****   #endif
 175:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 176:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 177:quantum/quantum.c ****   shutdown_user();
 178:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 179:quantum/quantum.c ****     wait_ms(1);
 180:quantum/quantum.c ****   stop_all_notes();
 181:quantum/quantum.c **** #else
 182:quantum/quantum.c ****   shutdown_user();
 183:quantum/quantum.c ****   wait_ms(250);
 184:quantum/quantum.c **** #endif
 185:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 186:quantum/quantum.c ****   haptic_shutdown();
 187:quantum/quantum.c **** #endif
 188:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 189:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 190:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 191:quantum/quantum.c **** #endif
 192:quantum/quantum.c ****   bootloader_jump();
 193:quantum/quantum.c **** }
 194:quantum/quantum.c **** 
 195:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 196:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 197:quantum/quantum.c ****  */
 198:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 199:quantum/quantum.c **** 
 200:quantum/quantum.c **** /* Convert record into usable keycode via the contained event. */
 201:quantum/quantum.c **** uint16_t get_record_keycode(keyrecord_t *record) {
 202:quantum/quantum.c ****   return get_event_keycode(record->event);
 203:quantum/quantum.c **** }
 204:quantum/quantum.c **** 
 205:quantum/quantum.c **** 
 206:quantum/quantum.c **** /* Convert event into usable keycode. Checks the layer cache to ensure that it
 207:quantum/quantum.c ****  * retains the correct keycode after a layer change, if the key is still pressed.
 208:quantum/quantum.c ****  */
 209:quantum/quantum.c **** uint16_t get_event_keycode(keyevent_t event) {
 591               		.loc 1 209 0
 592               		.cfi_startproc
 593 0000 1F93      		push r17
 594               	.LCFI10:
 595               		.cfi_def_cfa_offset 3
 596               		.cfi_offset 17, -2
 597 0002 CF93      		push r28
 598               	.LCFI11:
 599               		.cfi_def_cfa_offset 4
 600               		.cfi_offset 28, -3
 601 0004 DF93      		push r29
 602               	.LCFI12:
 603               		.cfi_def_cfa_offset 5
 604               		.cfi_offset 29, -4
 605 0006 00D0      		rcall .
 606 0008 00D0      		rcall .
 607 000a 1F92      		push __zero_reg__
 608               	.LCFI13:
 609               		.cfi_def_cfa_offset 10
 610 000c CDB7      		in r28,__SP_L__
 611 000e DEB7      		in r29,__SP_H__
 612               	.LCFI14:
 613               		.cfi_def_cfa_register 28
 614               	/* prologue: function */
 615               	/* frame size = 5 */
 616               	/* stack size = 8 */
 617               	.L__stack_usage = 8
 618 0010 4983      		std Y+1,r20
 619 0012 5A83      		std Y+2,r21
 620 0014 6B83      		std Y+3,r22
 210:quantum/quantum.c **** 
 211:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 212:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 213:quantum/quantum.c ****     if (!disable_action_cache) {
 621               		.loc 1 213 0
 622 0016 2091 0000 		lds r18,disable_action_cache
 623 001a 8981      		ldd r24,Y+1
 624 001c 9A81      		ldd r25,Y+2
 625 001e 2111      		cpse r18,__zero_reg__
 626 0020 00C0      		rjmp .L51
 627               	.LBB24:
 214:quantum/quantum.c ****       uint8_t layer;
 215:quantum/quantum.c **** 
 216:quantum/quantum.c ****       if (event.pressed) {
 628               		.loc 1 216 0
 629 0022 6623      		tst r22
 630 0024 01F0      		breq .L52
 217:quantum/quantum.c ****         layer = layer_switch_get_layer(event.key);
 631               		.loc 1 217 0
 632 0026 0E94 0000 		call layer_switch_get_layer
 633               	.LVL42:
 634 002a 182F      		mov r17,r24
 635               	.LVL43:
 218:quantum/quantum.c ****         update_source_layers_cache(event.key, layer);
 636               		.loc 1 218 0
 637 002c 682F      		mov r22,r24
 638 002e 8981      		ldd r24,Y+1
 639 0030 9A81      		ldd r25,Y+2
 640 0032 0E94 0000 		call update_source_layers_cache
 641               	.LVL44:
 642               	.L53:
 219:quantum/quantum.c ****       } else {
 220:quantum/quantum.c ****         layer = read_source_layers_cache(event.key);
 221:quantum/quantum.c ****       }
 222:quantum/quantum.c ****       return keymap_key_to_keycode(layer, event.key);
 643               		.loc 1 222 0
 644 0036 6981      		ldd r22,Y+1
 645 0038 7A81      		ldd r23,Y+2
 646 003a 812F      		mov r24,r17
 647               	.LVL45:
 648               	.L54:
 649               	/* epilogue start */
 650               	.LBE24:
 223:quantum/quantum.c ****     } else
 224:quantum/quantum.c ****   #endif
 225:quantum/quantum.c ****     return keymap_key_to_keycode(layer_switch_get_layer(event.key), event.key);
 226:quantum/quantum.c **** }
 651               		.loc 1 226 0
 652 003c 0F90      		pop __tmp_reg__
 653 003e 0F90      		pop __tmp_reg__
 654 0040 0F90      		pop __tmp_reg__
 655 0042 0F90      		pop __tmp_reg__
 656 0044 0F90      		pop __tmp_reg__
 657 0046 DF91      		pop r29
 658 0048 CF91      		pop r28
 659 004a 1F91      		pop r17
 225:quantum/quantum.c **** }
 660               		.loc 1 225 0
 661 004c 0C94 0000 		jmp keymap_key_to_keycode
 662               	.LVL46:
 663               	.L52:
 664               	.LBB25:
 220:quantum/quantum.c ****       }
 665               		.loc 1 220 0
 666 0050 0E94 0000 		call read_source_layers_cache
 667               	.LVL47:
 668 0054 182F      		mov r17,r24
 669               	.LVL48:
 670 0056 00C0      		rjmp .L53
 671               	.LVL49:
 672               	.L51:
 673               	.LBE25:
 225:quantum/quantum.c **** }
 674               		.loc 1 225 0
 675 0058 0E94 0000 		call layer_switch_get_layer
 676               	.LVL50:
 677 005c 6981      		ldd r22,Y+1
 678 005e 7A81      		ldd r23,Y+2
 679 0060 00C0      		rjmp .L54
 680               		.cfi_endproc
 681               	.LFE42:
 683               		.section	.text.get_record_keycode,"ax",@progbits
 684               	.global	get_record_keycode
 686               	get_record_keycode:
 687               	.LFB41:
 201:quantum/quantum.c ****   return get_event_keycode(record->event);
 688               		.loc 1 201 0
 689               		.cfi_startproc
 690               	.LVL51:
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 0 */
 694               	.L__stack_usage = 0
 695 0000 FC01      		movw r30,r24
 202:quantum/quantum.c **** }
 696               		.loc 1 202 0
 697 0002 4081      		ld r20,Z
 698 0004 5181      		ldd r21,Z+1
 699 0006 6281      		ldd r22,Z+2
 700 0008 7381      		ldd r23,Z+3
 701 000a 8481      		ldd r24,Z+4
 702               	.LVL52:
 703 000c 0C94 0000 		jmp get_event_keycode
 704               	.LVL53:
 705               		.cfi_endproc
 706               	.LFE41:
 708               		.section	.text.send_char,"ax",@progbits
 709               	.global	send_char
 711               	send_char:
 712               	.LFB48:
 227:quantum/quantum.c **** 
 228:quantum/quantum.c **** /* Main keycode processing function. Hands off handling to other functions,
 229:quantum/quantum.c ****  * then processes internal Quantum keycodes, then processes ACTIONs.
 230:quantum/quantum.c ****  */
 231:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 232:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record);
 233:quantum/quantum.c **** 
 234:quantum/quantum.c ****     // This is how you use actions here
 235:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 236:quantum/quantum.c ****     //   action_t action;
 237:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 238:quantum/quantum.c ****     //   process_action(record, action);
 239:quantum/quantum.c ****     //   return false;
 240:quantum/quantum.c ****     // }
 241:quantum/quantum.c **** 
 242:quantum/quantum.c ****   #ifdef VELOCIKEY_ENABLE
 243:quantum/quantum.c ****     if (velocikey_enabled() && record->event.pressed) { velocikey_accelerate(); }
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c **** 
 246:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 247:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 248:quantum/quantum.c ****   #endif
 249:quantum/quantum.c **** 
 250:quantum/quantum.c ****   if (!(
 251:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 252:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 253:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 254:quantum/quantum.c ****   #endif
 255:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 256:quantum/quantum.c ****     process_clicky(keycode, record) &&
 257:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 258:quantum/quantum.c ****   #ifdef HAPTIC_ENABLE
 259:quantum/quantum.c ****     process_haptic(keycode, record) &&
 260:quantum/quantum.c ****   #endif //HAPTIC_ENABLE
 261:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE)
 262:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 263:quantum/quantum.c ****   #endif
 264:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 265:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 266:quantum/quantum.c ****     process_midi(keycode, record) &&
 267:quantum/quantum.c ****   #endif
 268:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 269:quantum/quantum.c ****     process_audio(keycode, record) &&
 270:quantum/quantum.c ****   #endif
 271:quantum/quantum.c ****   #ifdef STENO_ENABLE
 272:quantum/quantum.c ****     process_steno(keycode, record) &&
 273:quantum/quantum.c ****   #endif
 274:quantum/quantum.c ****   #if (defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSIC
 275:quantum/quantum.c ****     process_music(keycode, record) &&
 276:quantum/quantum.c ****   #endif
 277:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 278:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 279:quantum/quantum.c ****   #endif
 280:quantum/quantum.c ****   #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 281:quantum/quantum.c ****     process_unicode_common(keycode, record) &&
 282:quantum/quantum.c ****   #endif
 283:quantum/quantum.c ****   #ifdef LEADER_ENABLE
 284:quantum/quantum.c ****     process_leader(keycode, record) &&
 285:quantum/quantum.c ****   #endif
 286:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 287:quantum/quantum.c ****     process_combo(keycode, record) &&
 288:quantum/quantum.c ****   #endif
 289:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 290:quantum/quantum.c ****     process_printer(keycode, record) &&
 291:quantum/quantum.c ****   #endif
 292:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 293:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 294:quantum/quantum.c ****   #endif
 295:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 296:quantum/quantum.c ****     process_terminal(keycode, record) &&
 297:quantum/quantum.c ****   #endif
 298:quantum/quantum.c ****   #ifdef SPACE_CADET_ENABLE
 299:quantum/quantum.c ****     process_space_cadet(keycode, record) &&
 300:quantum/quantum.c ****   #endif
 301:quantum/quantum.c ****       true)) {
 302:quantum/quantum.c ****     return false;
 303:quantum/quantum.c ****   }
 304:quantum/quantum.c **** 
 305:quantum/quantum.c ****   // Shift / paren setup
 306:quantum/quantum.c **** 
 307:quantum/quantum.c ****   switch(keycode) {
 308:quantum/quantum.c ****     case RESET:
 309:quantum/quantum.c ****       if (record->event.pressed) {
 310:quantum/quantum.c ****         reset_keyboard();
 311:quantum/quantum.c ****       }
 312:quantum/quantum.c ****     return false;
 313:quantum/quantum.c ****     case DEBUG:
 314:quantum/quantum.c ****       if (record->event.pressed) {
 315:quantum/quantum.c ****         debug_enable ^= 1;
 316:quantum/quantum.c ****         if (debug_enable) {
 317:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 318:quantum/quantum.c ****         } else {
 319:quantum/quantum.c ****           print("DEBUG: disabled.\n");
 320:quantum/quantum.c ****         }
 321:quantum/quantum.c ****       }
 322:quantum/quantum.c ****     return false;
 323:quantum/quantum.c ****     case EEPROM_RESET:
 324:quantum/quantum.c ****       if (record->event.pressed) {
 325:quantum/quantum.c ****           eeconfig_init();
 326:quantum/quantum.c ****       }
 327:quantum/quantum.c ****     return false;
 328:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 329:quantum/quantum.c ****   case FC_TOG:
 330:quantum/quantum.c ****     if (record->event.pressed) {
 331:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 332:quantum/quantum.c ****     }
 333:quantum/quantum.c ****     return false;
 334:quantum/quantum.c ****   case FC_ON:
 335:quantum/quantum.c ****     if (record->event.pressed) {
 336:quantum/quantum.c ****       FAUXCLICKY_ON;
 337:quantum/quantum.c ****     }
 338:quantum/quantum.c ****     return false;
 339:quantum/quantum.c ****   case FC_OFF:
 340:quantum/quantum.c ****     if (record->event.pressed) {
 341:quantum/quantum.c ****       FAUXCLICKY_OFF;
 342:quantum/quantum.c ****     }
 343:quantum/quantum.c ****     return false;
 344:quantum/quantum.c ****   #endif
 345:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 346:quantum/quantum.c ****   case RGB_TOG:
 347:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 348:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 349:quantum/quantum.c ****     if (record->event.pressed) {
 350:quantum/quantum.c ****     #else
 351:quantum/quantum.c ****     if (!record->event.pressed) {
 352:quantum/quantum.c ****     #endif
 353:quantum/quantum.c ****       rgblight_toggle();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 359:quantum/quantum.c ****       if(shifted) {
 360:quantum/quantum.c ****         rgblight_step_reverse();
 361:quantum/quantum.c ****       }
 362:quantum/quantum.c ****       else {
 363:quantum/quantum.c ****         rgblight_step();
 364:quantum/quantum.c ****       }
 365:quantum/quantum.c ****     }
 366:quantum/quantum.c ****     return false;
 367:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 368:quantum/quantum.c ****     if (record->event.pressed) {
 369:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 370:quantum/quantum.c ****       if(shifted) {
 371:quantum/quantum.c ****         rgblight_step();
 372:quantum/quantum.c ****       }
 373:quantum/quantum.c ****       else {
 374:quantum/quantum.c ****         rgblight_step_reverse();
 375:quantum/quantum.c ****       }
 376:quantum/quantum.c ****     }
 377:quantum/quantum.c ****     return false;
 378:quantum/quantum.c ****   case RGB_HUI:
 379:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 380:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 381:quantum/quantum.c ****     if (record->event.pressed) {
 382:quantum/quantum.c ****     #else
 383:quantum/quantum.c ****     if (!record->event.pressed) {
 384:quantum/quantum.c ****     #endif
 385:quantum/quantum.c ****       rgblight_increase_hue();
 386:quantum/quantum.c ****     }
 387:quantum/quantum.c ****     return false;
 388:quantum/quantum.c ****   case RGB_HUD:
 389:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 390:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 391:quantum/quantum.c ****     if (record->event.pressed) {
 392:quantum/quantum.c ****     #else
 393:quantum/quantum.c ****     if (!record->event.pressed) {
 394:quantum/quantum.c ****     #endif
 395:quantum/quantum.c ****       rgblight_decrease_hue();
 396:quantum/quantum.c ****     }
 397:quantum/quantum.c ****     return false;
 398:quantum/quantum.c ****   case RGB_SAI:
 399:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 400:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 401:quantum/quantum.c ****     if (record->event.pressed) {
 402:quantum/quantum.c ****     #else
 403:quantum/quantum.c ****     if (!record->event.pressed) {
 404:quantum/quantum.c ****     #endif
 405:quantum/quantum.c ****       rgblight_increase_sat();
 406:quantum/quantum.c ****     }
 407:quantum/quantum.c ****     return false;
 408:quantum/quantum.c ****   case RGB_SAD:
 409:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 410:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 411:quantum/quantum.c ****     if (record->event.pressed) {
 412:quantum/quantum.c ****     #else
 413:quantum/quantum.c ****     if (!record->event.pressed) {
 414:quantum/quantum.c ****     #endif
 415:quantum/quantum.c ****       rgblight_decrease_sat();
 416:quantum/quantum.c ****     }
 417:quantum/quantum.c ****     return false;
 418:quantum/quantum.c ****   case RGB_VAI:
 419:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 420:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 421:quantum/quantum.c ****     if (record->event.pressed) {
 422:quantum/quantum.c ****     #else
 423:quantum/quantum.c ****     if (!record->event.pressed) {
 424:quantum/quantum.c ****     #endif
 425:quantum/quantum.c ****       rgblight_increase_val();
 426:quantum/quantum.c ****     }
 427:quantum/quantum.c ****     return false;
 428:quantum/quantum.c ****   case RGB_VAD:
 429:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 430:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 431:quantum/quantum.c ****     if (record->event.pressed) {
 432:quantum/quantum.c ****     #else
 433:quantum/quantum.c ****     if (!record->event.pressed) {
 434:quantum/quantum.c ****     #endif
 435:quantum/quantum.c ****       rgblight_decrease_val();
 436:quantum/quantum.c ****     }
 437:quantum/quantum.c ****     return false;
 438:quantum/quantum.c ****   case RGB_SPI:
 439:quantum/quantum.c ****     if (record->event.pressed) {
 440:quantum/quantum.c ****       rgblight_increase_speed();
 441:quantum/quantum.c ****     }
 442:quantum/quantum.c ****     return false;
 443:quantum/quantum.c ****   case RGB_SPD:
 444:quantum/quantum.c ****     if (record->event.pressed) {
 445:quantum/quantum.c ****       rgblight_decrease_speed();
 446:quantum/quantum.c ****     }
 447:quantum/quantum.c ****     return false;
 448:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 449:quantum/quantum.c ****     if (record->event.pressed) {
 450:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_STATIC_LIGHT);
 451:quantum/quantum.c ****     }
 452:quantum/quantum.c ****     return false;
 453:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 454:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_BREATHING
 455:quantum/quantum.c ****     if (record->event.pressed) {
 456:quantum/quantum.c ****       if ((RGBLIGHT_MODE_BREATHING <= rgblight_get_mode()) &&
 457:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_BREATHING_end)) {
 458:quantum/quantum.c ****         rgblight_step();
 459:quantum/quantum.c ****       } else {
 460:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_BREATHING);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****     }
 463:quantum/quantum.c ****   #endif
 464:quantum/quantum.c ****     return false;
 465:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 466:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_RAINBOW_MOOD
 467:quantum/quantum.c ****     if (record->event.pressed) {
 468:quantum/quantum.c ****       if ((RGBLIGHT_MODE_RAINBOW_MOOD <= rgblight_get_mode()) &&
 469:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_MOOD_end)) {
 470:quantum/quantum.c ****         rgblight_step();
 471:quantum/quantum.c ****       } else {
 472:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_RAINBOW_MOOD);
 473:quantum/quantum.c ****       }
 474:quantum/quantum.c ****     }
 475:quantum/quantum.c ****   #endif
 476:quantum/quantum.c ****     return false;
 477:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 478:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_RAINBOW_SWIRL
 479:quantum/quantum.c ****     if (record->event.pressed) {
 480:quantum/quantum.c ****       if ((RGBLIGHT_MODE_RAINBOW_SWIRL <= rgblight_get_mode()) &&
 481:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_SWIRL_end)) {
 482:quantum/quantum.c ****         rgblight_step();
 483:quantum/quantum.c ****       } else {
 484:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_RAINBOW_SWIRL);
 485:quantum/quantum.c ****       }
 486:quantum/quantum.c ****     }
 487:quantum/quantum.c ****   #endif
 488:quantum/quantum.c ****     return false;
 489:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 490:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_SNAKE
 491:quantum/quantum.c ****     if (record->event.pressed) {
 492:quantum/quantum.c ****       if ((RGBLIGHT_MODE_SNAKE <= rgblight_get_mode()) &&
 493:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_SNAKE_end)) {
 494:quantum/quantum.c ****         rgblight_step();
 495:quantum/quantum.c ****       } else {
 496:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_SNAKE);
 497:quantum/quantum.c ****       }
 498:quantum/quantum.c ****     }
 499:quantum/quantum.c ****   #endif
 500:quantum/quantum.c ****     return false;
 501:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 502:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_KNIGHT
 503:quantum/quantum.c ****     if (record->event.pressed) {
 504:quantum/quantum.c ****       if ((RGBLIGHT_MODE_KNIGHT <= rgblight_get_mode()) &&
 505:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_KNIGHT_end)) {
 506:quantum/quantum.c ****         rgblight_step();
 507:quantum/quantum.c ****       } else {
 508:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_KNIGHT);
 509:quantum/quantum.c ****       }
 510:quantum/quantum.c ****     }
 511:quantum/quantum.c ****   #endif
 512:quantum/quantum.c ****     return false;
 513:quantum/quantum.c ****   case RGB_MODE_XMAS:
 514:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_CHRISTMAS
 515:quantum/quantum.c ****     if (record->event.pressed) {
 516:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_CHRISTMAS);
 517:quantum/quantum.c ****     }
 518:quantum/quantum.c ****   #endif
 519:quantum/quantum.c ****     return false;
 520:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 521:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_STATIC_GRADIENT
 522:quantum/quantum.c ****     if (record->event.pressed) {
 523:quantum/quantum.c ****       if ((RGBLIGHT_MODE_STATIC_GRADIENT <= rgblight_get_mode()) &&
 524:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_STATIC_GRADIENT_end)) {
 525:quantum/quantum.c ****         rgblight_step();
 526:quantum/quantum.c ****       } else {
 527:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_STATIC_GRADIENT);
 528:quantum/quantum.c ****       }
 529:quantum/quantum.c ****     }
 530:quantum/quantum.c ****   #endif
 531:quantum/quantum.c ****     return false;
 532:quantum/quantum.c ****   case RGB_MODE_RGBTEST:
 533:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_RGB_TEST
 534:quantum/quantum.c ****     if (record->event.pressed) {
 535:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_RGB_TEST);
 536:quantum/quantum.c ****     }
 537:quantum/quantum.c ****   #endif
 538:quantum/quantum.c ****     return false;
 539:quantum/quantum.c ****   #endif // defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 540:quantum/quantum.c ****   #ifdef VELOCIKEY_ENABLE
 541:quantum/quantum.c ****     case VLK_TOG:
 542:quantum/quantum.c ****       if (record->event.pressed) {
 543:quantum/quantum.c ****         velocikey_toggle();
 544:quantum/quantum.c ****       }
 545:quantum/quantum.c ****       return false;
 546:quantum/quantum.c ****   #endif
 547:quantum/quantum.c ****   #ifdef PROTOCOL_LUFA
 548:quantum/quantum.c ****     case OUT_AUTO:
 549:quantum/quantum.c ****       if (record->event.pressed) {
 550:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 551:quantum/quantum.c ****       }
 552:quantum/quantum.c ****       return false;
 553:quantum/quantum.c ****     case OUT_USB:
 554:quantum/quantum.c ****       if (record->event.pressed) {
 555:quantum/quantum.c ****         set_output(OUTPUT_USB);
 556:quantum/quantum.c ****       }
 557:quantum/quantum.c ****       return false;
 558:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 559:quantum/quantum.c ****     case OUT_BT:
 560:quantum/quantum.c ****       if (record->event.pressed) {
 561:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 562:quantum/quantum.c ****       }
 563:quantum/quantum.c ****       return false;
 564:quantum/quantum.c ****     #endif
 565:quantum/quantum.c ****     #endif
 566:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 567:quantum/quantum.c ****       if (record->event.pressed) {
 568:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 569:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 570:quantum/quantum.c ****             eeconfig_init();
 571:quantum/quantum.c ****         }
 572:quantum/quantum.c ****         /* keymap config */
 573:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 574:quantum/quantum.c ****         switch (keycode)
 575:quantum/quantum.c ****         {
 576:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 577:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 578:quantum/quantum.c ****             break;
 579:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 580:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 581:quantum/quantum.c ****             break;
 582:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 583:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 584:quantum/quantum.c ****             break;
 585:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 586:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 587:quantum/quantum.c ****             break;
 588:quantum/quantum.c ****           case MAGIC_NO_GUI:
 589:quantum/quantum.c ****             keymap_config.no_gui = true;
 590:quantum/quantum.c ****             break;
 591:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 592:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 593:quantum/quantum.c ****             break;
 594:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 595:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 596:quantum/quantum.c ****             break;
 597:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 598:quantum/quantum.c ****             keymap_config.nkro = true;
 599:quantum/quantum.c ****             break;
 600:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 601:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 602:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 603:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 604:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 605:quantum/quantum.c ****             #endif
 606:quantum/quantum.c ****             break;
 607:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 608:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 609:quantum/quantum.c ****             break;
 610:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 611:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 612:quantum/quantum.c ****             break;
 613:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 614:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 615:quantum/quantum.c ****             break;
 616:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 617:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 618:quantum/quantum.c ****             break;
 619:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 620:quantum/quantum.c ****             keymap_config.no_gui = false;
 621:quantum/quantum.c ****             break;
 622:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 623:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 624:quantum/quantum.c ****             break;
 625:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 626:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 627:quantum/quantum.c ****             break;
 628:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 629:quantum/quantum.c ****             keymap_config.nkro = false;
 630:quantum/quantum.c ****             break;
 631:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 632:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 633:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 634:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 635:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 636:quantum/quantum.c ****             #endif
 637:quantum/quantum.c ****             break;
 638:quantum/quantum.c ****           case MAGIC_TOGGLE_ALT_GUI:
 639:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = !keymap_config.swap_lalt_lgui;
 640:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = !keymap_config.swap_ralt_rgui;
 641:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 642:quantum/quantum.c ****               if (keymap_config.swap_ralt_rgui) {
 643:quantum/quantum.c ****                 PLAY_SONG(ag_swap_song);
 644:quantum/quantum.c ****               } else {
 645:quantum/quantum.c ****                 PLAY_SONG(ag_norm_song);
 646:quantum/quantum.c ****               }
 647:quantum/quantum.c ****             #endif
 648:quantum/quantum.c ****             break;
 649:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 650:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 651:quantum/quantum.c ****             break;
 652:quantum/quantum.c ****           default:
 653:quantum/quantum.c ****             break;
 654:quantum/quantum.c ****         }
 655:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 656:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 657:quantum/quantum.c **** 
 658:quantum/quantum.c ****         return false;
 659:quantum/quantum.c ****       }
 660:quantum/quantum.c ****       break;
 661:quantum/quantum.c **** 
 662:quantum/quantum.c ****     case GRAVE_ESC: {
 663:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 664:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 665:quantum/quantum.c **** 
 666:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 667:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 668:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 669:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 670:quantum/quantum.c ****         shifted = 0;
 671:quantum/quantum.c ****       }
 672:quantum/quantum.c **** #endif
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 675:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 676:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 677:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 678:quantum/quantum.c ****         shifted = 0;
 679:quantum/quantum.c ****       }
 680:quantum/quantum.c **** #endif
 681:quantum/quantum.c **** 
 682:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 683:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 684:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 685:quantum/quantum.c ****         shifted = 0;
 686:quantum/quantum.c ****       }
 687:quantum/quantum.c **** #endif
 688:quantum/quantum.c **** 
 689:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 690:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 691:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 692:quantum/quantum.c ****         shifted = 0;
 693:quantum/quantum.c ****       }
 694:quantum/quantum.c **** #endif
 695:quantum/quantum.c **** 
 696:quantum/quantum.c ****       if (record->event.pressed) {
 697:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 698:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 699:quantum/quantum.c ****       }
 700:quantum/quantum.c ****       else {
 701:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 702:quantum/quantum.c ****       }
 703:quantum/quantum.c **** 
 704:quantum/quantum.c ****       send_keyboard_report();
 705:quantum/quantum.c ****       return false;
 706:quantum/quantum.c ****     }
 707:quantum/quantum.c **** 
 708:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 709:quantum/quantum.c ****     case BL_BRTG: {
 710:quantum/quantum.c ****       if (record->event.pressed)
 711:quantum/quantum.c ****         breathing_toggle();
 712:quantum/quantum.c ****       return false;
 713:quantum/quantum.c ****     }
 714:quantum/quantum.c **** #endif
 715:quantum/quantum.c ****   }
 716:quantum/quantum.c **** 
 717:quantum/quantum.c ****   return process_action_kb(record);
 718:quantum/quantum.c **** }
 719:quantum/quantum.c **** 
 720:quantum/quantum.c **** __attribute__ ((weak))
 721:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 722:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 723:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 724:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 725:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 726:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 727:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 728:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 729:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 730:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 731:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 732:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 733:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 734:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 735:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 736:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 737:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 738:quantum/quantum.c **** };
 739:quantum/quantum.c **** 
 740:quantum/quantum.c **** __attribute__ ((weak))
 741:quantum/quantum.c **** const bool ascii_to_altgr_lut[0x80] PROGMEM = {
 742:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 743:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 744:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 745:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 746:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 747:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 748:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 749:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 750:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 751:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 752:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 753:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 754:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 755:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 756:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 757:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0
 758:quantum/quantum.c **** };
 759:quantum/quantum.c **** 
 760:quantum/quantum.c **** __attribute__ ((weak))
 761:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 762:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 763:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 764:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 765:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 766:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 767:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 768:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 769:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 770:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 771:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 772:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 773:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 774:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 775:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 776:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 777:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 778:quantum/quantum.c **** };
 779:quantum/quantum.c **** 
 780:quantum/quantum.c **** void send_string(const char *str) {
 781:quantum/quantum.c ****   send_string_with_delay(str, 0);
 782:quantum/quantum.c **** }
 783:quantum/quantum.c **** 
 784:quantum/quantum.c **** void send_string_P(const char *str) {
 785:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 786:quantum/quantum.c **** }
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 789:quantum/quantum.c ****     while (1) {
 790:quantum/quantum.c ****         char ascii_code = *str;
 791:quantum/quantum.c ****         if (!ascii_code) break;
 792:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 793:quantum/quantum.c ****           // tap
 794:quantum/quantum.c ****           uint8_t keycode = *(++str);
 795:quantum/quantum.c ****           register_code(keycode);
 796:quantum/quantum.c ****           unregister_code(keycode);
 797:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 798:quantum/quantum.c ****           // down
 799:quantum/quantum.c ****           uint8_t keycode = *(++str);
 800:quantum/quantum.c ****           register_code(keycode);
 801:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 802:quantum/quantum.c ****           // up
 803:quantum/quantum.c ****           uint8_t keycode = *(++str);
 804:quantum/quantum.c ****           unregister_code(keycode);
 805:quantum/quantum.c ****         } else {
 806:quantum/quantum.c ****           send_char(ascii_code);
 807:quantum/quantum.c ****         }
 808:quantum/quantum.c ****         ++str;
 809:quantum/quantum.c ****         // interval
 810:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 811:quantum/quantum.c ****     }
 812:quantum/quantum.c **** }
 813:quantum/quantum.c **** 
 814:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 815:quantum/quantum.c ****     while (1) {
 816:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 817:quantum/quantum.c ****         if (!ascii_code) break;
 818:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 819:quantum/quantum.c ****           // tap
 820:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 821:quantum/quantum.c ****           register_code(keycode);
 822:quantum/quantum.c ****           unregister_code(keycode);
 823:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 824:quantum/quantum.c ****           // down
 825:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 826:quantum/quantum.c ****           register_code(keycode);
 827:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 828:quantum/quantum.c ****           // up
 829:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 830:quantum/quantum.c ****           unregister_code(keycode);
 831:quantum/quantum.c ****         } else {
 832:quantum/quantum.c ****           send_char(ascii_code);
 833:quantum/quantum.c ****         }
 834:quantum/quantum.c ****         ++str;
 835:quantum/quantum.c ****         // interval
 836:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 837:quantum/quantum.c ****     }
 838:quantum/quantum.c **** }
 839:quantum/quantum.c **** 
 840:quantum/quantum.c **** void send_char(char ascii_code) {
 713               		.loc 1 840 0
 714               		.cfi_startproc
 715               	.LVL54:
 716 0000 1F93      		push r17
 717               	.LCFI15:
 718               		.cfi_def_cfa_offset 3
 719               		.cfi_offset 17, -2
 720 0002 CF93      		push r28
 721               	.LCFI16:
 722               		.cfi_def_cfa_offset 4
 723               		.cfi_offset 28, -3
 724 0004 DF93      		push r29
 725               	.LCFI17:
 726               		.cfi_def_cfa_offset 5
 727               		.cfi_offset 29, -4
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 3 */
 731               	.L__stack_usage = 3
 732 0006 90E0      		ldi r25,0
 733               	.LVL55:
 734               	.LBB26:
 841:quantum/quantum.c ****   uint8_t keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 735               		.loc 1 841 0
 736 0008 FC01      		movw r30,r24
 737 000a E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 738 000c F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 739               	.LVL56:
 740               	/* #APP */
 741               	 ;  841 "quantum/quantum.c" 1
 742 000e 1491      		lpm r17, Z
 743               		
 744               	 ;  0 "" 2
 745               	.LVL57:
 746               	/* #NOAPP */
 747               	.LBE26:
 748               	.LBB27:
 842:quantum/quantum.c ****   bool is_shifted = pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code]);
 749               		.loc 1 842 0
 750 0010 FC01      		movw r30,r24
 751               	.LVL58:
 752 0012 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 753 0014 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 754               	.LVL59:
 755               	/* #APP */
 756               	 ;  842 "quantum/quantum.c" 1
 757 0016 D491      		lpm r29, Z
 758               		
 759               	 ;  0 "" 2
 760               	.LVL60:
 761               	/* #NOAPP */
 762               	.LBE27:
 763               	.LBB28:
 843:quantum/quantum.c ****   bool is_altgred = pgm_read_byte(&ascii_to_altgr_lut[(uint8_t)ascii_code]);
 764               		.loc 1 843 0
 765 0018 8050      		subi r24,lo8(-(ascii_to_altgr_lut))
 766 001a 9040      		sbci r25,hi8(-(ascii_to_altgr_lut))
 767               	.LVL61:
 768 001c FC01      		movw r30,r24
 769               	.LVL62:
 770               	/* #APP */
 771               	 ;  843 "quantum/quantum.c" 1
 772 001e C491      		lpm r28, Z
 773               		
 774               	 ;  0 "" 2
 775               	.LVL63:
 776               	/* #NOAPP */
 777               	.LBE28:
 844:quantum/quantum.c **** 
 845:quantum/quantum.c ****   if (is_shifted) {
 778               		.loc 1 845 0
 779 0020 DD23      		tst r29
 780 0022 01F0      		breq .L57
 846:quantum/quantum.c ****     register_code(KC_LSFT);
 781               		.loc 1 846 0
 782 0024 81EE      		ldi r24,lo8(-31)
 783               	.LVL64:
 784 0026 0E94 0000 		call register_code
 785               	.LVL65:
 786               	.L57:
 847:quantum/quantum.c ****   }
 848:quantum/quantum.c ****   if (is_altgred) {
 787               		.loc 1 848 0
 788 002a CC23      		tst r28
 789 002c 01F0      		breq .L58
 849:quantum/quantum.c ****     register_code(KC_RALT);
 790               		.loc 1 849 0
 791 002e 86EE      		ldi r24,lo8(-26)
 792 0030 0E94 0000 		call register_code
 793               	.LVL66:
 794               	.L58:
 850:quantum/quantum.c ****   }
 851:quantum/quantum.c ****   tap_code(keycode);
 795               		.loc 1 851 0
 796 0034 812F      		mov r24,r17
 797 0036 0E94 0000 		call tap_code
 798               	.LVL67:
 852:quantum/quantum.c ****   if (is_altgred) {
 799               		.loc 1 852 0
 800 003a CC23      		tst r28
 801 003c 01F0      		breq .L59
 853:quantum/quantum.c ****     unregister_code(KC_RALT);
 802               		.loc 1 853 0
 803 003e 86EE      		ldi r24,lo8(-26)
 804 0040 0E94 0000 		call unregister_code
 805               	.LVL68:
 806               	.L59:
 854:quantum/quantum.c ****   }
 855:quantum/quantum.c ****   if (is_shifted) {
 807               		.loc 1 855 0
 808 0044 DD23      		tst r29
 809 0046 01F0      		breq .L56
 856:quantum/quantum.c ****     unregister_code(KC_LSFT);
 810               		.loc 1 856 0
 811 0048 81EE      		ldi r24,lo8(-31)
 812               	/* epilogue start */
 857:quantum/quantum.c ****   }
 858:quantum/quantum.c **** }
 813               		.loc 1 858 0
 814 004a DF91      		pop r29
 815               	.LVL69:
 816 004c CF91      		pop r28
 817               	.LVL70:
 818 004e 1F91      		pop r17
 819               	.LVL71:
 856:quantum/quantum.c ****     unregister_code(KC_LSFT);
 820               		.loc 1 856 0
 821 0050 0C94 0000 		jmp unregister_code
 822               	.LVL72:
 823               	.L56:
 824               	/* epilogue start */
 825               		.loc 1 858 0
 826 0054 DF91      		pop r29
 827               	.LVL73:
 828 0056 CF91      		pop r28
 829               	.LVL74:
 830 0058 1F91      		pop r17
 831               	.LVL75:
 832 005a 0895      		ret
 833               		.cfi_endproc
 834               	.LFE48:
 836               		.section	.text.send_string_with_delay,"ax",@progbits
 837               	.global	send_string_with_delay
 839               	send_string_with_delay:
 840               	.LFB46:
 788:quantum/quantum.c ****     while (1) {
 841               		.loc 1 788 0
 842               		.cfi_startproc
 843               	.LVL76:
 844 0000 FF92      		push r15
 845               	.LCFI18:
 846               		.cfi_def_cfa_offset 3
 847               		.cfi_offset 15, -2
 848 0002 0F93      		push r16
 849               	.LCFI19:
 850               		.cfi_def_cfa_offset 4
 851               		.cfi_offset 16, -3
 852 0004 1F93      		push r17
 853               	.LCFI20:
 854               		.cfi_def_cfa_offset 5
 855               		.cfi_offset 17, -4
 856 0006 CF93      		push r28
 857               	.LCFI21:
 858               		.cfi_def_cfa_offset 6
 859               		.cfi_offset 28, -5
 860 0008 DF93      		push r29
 861               	.LCFI22:
 862               		.cfi_def_cfa_offset 7
 863               		.cfi_offset 29, -6
 864               	/* prologue: function */
 865               	/* frame size = 0 */
 866               	/* stack size = 5 */
 867               	.L__stack_usage = 5
 868 000a EC01      		movw r28,r24
 869 000c F62E      		mov r15,r22
 870               	.LVL77:
 871               	.L78:
 872               	.LBB29:
 790:quantum/quantum.c ****         if (!ascii_code) break;
 873               		.loc 1 790 0
 874 000e 8881      		ld r24,Y
 875               	.LVL78:
 791:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 876               		.loc 1 791 0
 877 0010 8823      		tst r24
 878 0012 01F0      		breq .L70
 879 0014 8E01      		movw r16,r28
 880 0016 0F5F      		subi r16,-1
 881 0018 1F4F      		sbci r17,-1
 792:quantum/quantum.c ****           // tap
 882               		.loc 1 792 0
 883 001a 8130      		cpi r24,lo8(1)
 884 001c 01F4      		brne .L72
 885               	.LVL79:
 886               	.LBB30:
 794:quantum/quantum.c ****           register_code(keycode);
 887               		.loc 1 794 0
 888 001e C981      		ldd r28,Y+1
 889               	.LVL80:
 795:quantum/quantum.c ****           unregister_code(keycode);
 890               		.loc 1 795 0
 891 0020 8C2F      		mov r24,r28
 892               	.LVL81:
 893 0022 0E94 0000 		call register_code
 894               	.LVL82:
 796:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 895               		.loc 1 796 0
 896 0026 8C2F      		mov r24,r28
 897               	.LVL83:
 898               	.L79:
 899               	.LBE30:
 900               	.LBB31:
 804:quantum/quantum.c ****         } else {
 901               		.loc 1 804 0
 902 0028 0E94 0000 		call unregister_code
 903               	.LVL84:
 904               	.LBE31:
 905 002c 00C0      		rjmp .L73
 906               	.LVL85:
 907               	.L72:
 797:quantum/quantum.c ****           // down
 908               		.loc 1 797 0
 909 002e 8230      		cpi r24,lo8(2)
 910 0030 01F4      		brne .L74
 911               	.LVL86:
 912               	.LBB32:
 800:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 913               		.loc 1 800 0
 914 0032 8981      		ldd r24,Y+1
 915               	.LVL87:
 916 0034 0E94 0000 		call register_code
 917               	.LVL88:
 918               	.L73:
 919               	.LBE32:
 808:quantum/quantum.c ****         // interval
 920               		.loc 1 808 0
 921 0038 E801      		movw r28,r16
 922 003a 2196      		adiw r28,1
 923               	.LVL89:
 924               	.LBB33:
 810:quantum/quantum.c ****     }
 925               		.loc 1 810 0
 926 003c 8F2D      		mov r24,r15
 927               	.LVL90:
 928               	.L76:
 810:quantum/quantum.c ****     }
 929               		.loc 1 810 0 is_stmt 0 discriminator 1
 930               	.LVL91:
 931 003e 8150      		subi r24,1
 932 0040 00F0      		brcs .L78
 933               	.LBB34:
 934               	.LBB35:
 935               		.file 2 "/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/7.2.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 936               		.loc 2 187 0 is_stmt 1
 937 0042 EFE9      		ldi r30,lo8(3999)
 938 0044 FFE0      		ldi r31,hi8(3999)
 939 0046 3197      	1:	sbiw r30,1
 940 0048 01F4      		brne 1b
 941 004a 00C0      		rjmp .
 942 004c 0000      		nop
 943 004e 00C0      		rjmp .L76
 944               	.LVL92:
 945               	.L74:
 946               	.LBE35:
 947               	.LBE34:
 948               	.LBE33:
 801:quantum/quantum.c ****           // up
 949               		.loc 1 801 0
 950 0050 8330      		cpi r24,lo8(3)
 951 0052 01F4      		brne .L75
 952               	.LVL93:
 953               	.LBB36:
 804:quantum/quantum.c ****         } else {
 954               		.loc 1 804 0
 955 0054 8981      		ldd r24,Y+1
 956               	.LVL94:
 957 0056 00C0      		rjmp .L79
 958               	.LVL95:
 959               	.L75:
 960               	.LBE36:
 806:quantum/quantum.c ****         }
 961               		.loc 1 806 0
 962 0058 0E94 0000 		call send_char
 963               	.LVL96:
 964 005c 8E01      		movw r16,r28
 965 005e 00C0      		rjmp .L73
 966               	.LVL97:
 967               	.L70:
 968               	/* epilogue start */
 969               	.LBE29:
 812:quantum/quantum.c **** 
 970               		.loc 1 812 0
 971 0060 DF91      		pop r29
 972 0062 CF91      		pop r28
 973               	.LVL98:
 974 0064 1F91      		pop r17
 975 0066 0F91      		pop r16
 976 0068 FF90      		pop r15
 977               	.LVL99:
 978 006a 0895      		ret
 979               		.cfi_endproc
 980               	.LFE46:
 982               		.section	.text.send_string,"ax",@progbits
 983               	.global	send_string
 985               	send_string:
 986               	.LFB44:
 780:quantum/quantum.c ****   send_string_with_delay(str, 0);
 987               		.loc 1 780 0
 988               		.cfi_startproc
 989               	.LVL100:
 990               	/* prologue: function */
 991               	/* frame size = 0 */
 992               	/* stack size = 0 */
 993               	.L__stack_usage = 0
 781:quantum/quantum.c **** }
 994               		.loc 1 781 0
 995 0000 60E0      		ldi r22,0
 996 0002 0C94 0000 		jmp send_string_with_delay
 997               	.LVL101:
 998               		.cfi_endproc
 999               	.LFE44:
 1001               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1002               	.global	send_string_with_delay_P
 1004               	send_string_with_delay_P:
 1005               	.LFB47:
 814:quantum/quantum.c ****     while (1) {
 1006               		.loc 1 814 0
 1007               		.cfi_startproc
 1008               	.LVL102:
 1009 0000 FF92      		push r15
 1010               	.LCFI23:
 1011               		.cfi_def_cfa_offset 3
 1012               		.cfi_offset 15, -2
 1013 0002 0F93      		push r16
 1014               	.LCFI24:
 1015               		.cfi_def_cfa_offset 4
 1016               		.cfi_offset 16, -3
 1017 0004 1F93      		push r17
 1018               	.LCFI25:
 1019               		.cfi_def_cfa_offset 5
 1020               		.cfi_offset 17, -4
 1021 0006 CF93      		push r28
 1022               	.LCFI26:
 1023               		.cfi_def_cfa_offset 6
 1024               		.cfi_offset 28, -5
 1025 0008 DF93      		push r29
 1026               	.LCFI27:
 1027               		.cfi_def_cfa_offset 7
 1028               		.cfi_offset 29, -6
 1029               	/* prologue: function */
 1030               	/* frame size = 0 */
 1031               	/* stack size = 5 */
 1032               	.L__stack_usage = 5
 1033 000a 8C01      		movw r16,r24
 1034 000c F62E      		mov r15,r22
 1035               	.LVL103:
 1036               	.L89:
 1037               	.LBB37:
 1038               	.LBB38:
 816:quantum/quantum.c ****         if (!ascii_code) break;
 1039               		.loc 1 816 0
 1040 000e F801      		movw r30,r16
 1041               	/* #APP */
 1042               	 ;  816 "quantum/quantum.c" 1
 1043 0010 8491      		lpm r24, Z
 1044               		
 1045               	 ;  0 "" 2
 1046               	.LVL104:
 1047               	/* #NOAPP */
 1048               	.LBE38:
 817:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 1049               		.loc 1 817 0
 1050 0012 8823      		tst r24
 1051 0014 01F0      		breq .L81
 1052 0016 E801      		movw r28,r16
 1053 0018 2196      		adiw r28,1
 818:quantum/quantum.c ****           // tap
 1054               		.loc 1 818 0
 1055 001a 8130      		cpi r24,lo8(1)
 1056 001c 01F4      		brne .L83
 1057               	.LVL105:
 1058               	.LBB39:
 1059               	.LBB40:
 820:quantum/quantum.c ****           register_code(keycode);
 1060               		.loc 1 820 0
 1061 001e FE01      		movw r30,r28
 1062               	/* #APP */
 1063               	 ;  820 "quantum/quantum.c" 1
 1064 0020 1491      		lpm r17, Z
 1065               		
 1066               	 ;  0 "" 2
 1067               	.LVL106:
 1068               	/* #NOAPP */
 1069               	.LBE40:
 821:quantum/quantum.c ****           unregister_code(keycode);
 1070               		.loc 1 821 0
 1071 0022 812F      		mov r24,r17
 1072               	.LVL107:
 1073 0024 0E94 0000 		call register_code
 1074               	.LVL108:
 822:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 1075               		.loc 1 822 0
 1076 0028 812F      		mov r24,r17
 1077               	.LVL109:
 1078               	.L90:
 1079               	.LBE39:
 1080               	.LBB41:
 830:quantum/quantum.c ****         } else {
 1081               		.loc 1 830 0
 1082 002a 0E94 0000 		call unregister_code
 1083               	.LVL110:
 1084               	.LBE41:
 1085 002e 00C0      		rjmp .L84
 1086               	.LVL111:
 1087               	.L83:
 823:quantum/quantum.c ****           // down
 1088               		.loc 1 823 0
 1089 0030 8230      		cpi r24,lo8(2)
 1090 0032 01F4      		brne .L85
 1091               	.LVL112:
 1092               	.LBB43:
 1093               	.LBB44:
 825:quantum/quantum.c ****           register_code(keycode);
 1094               		.loc 1 825 0
 1095 0034 FE01      		movw r30,r28
 1096               	/* #APP */
 1097               	 ;  825 "quantum/quantum.c" 1
 1098 0036 8491      		lpm r24, Z
 1099               		
 1100               	 ;  0 "" 2
 1101               	.LVL113:
 1102               	/* #NOAPP */
 1103               	.LBE44:
 826:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 1104               		.loc 1 826 0
 1105 0038 0E94 0000 		call register_code
 1106               	.LVL114:
 1107               	.L84:
 1108               	.LBE43:
 834:quantum/quantum.c ****         // interval
 1109               		.loc 1 834 0
 1110 003c 8E01      		movw r16,r28
 1111 003e 0F5F      		subi r16,-1
 1112 0040 1F4F      		sbci r17,-1
 1113               	.LVL115:
 1114               	.LBB45:
 836:quantum/quantum.c ****     }
 1115               		.loc 1 836 0
 1116 0042 8F2D      		mov r24,r15
 1117               	.LVL116:
 1118               	.L87:
 836:quantum/quantum.c ****     }
 1119               		.loc 1 836 0 is_stmt 0 discriminator 1
 1120               	.LVL117:
 1121 0044 8150      		subi r24,1
 1122 0046 00F0      		brcs .L89
 1123               	.LBB46:
 1124               	.LBB47:
 1125               		.loc 2 187 0 is_stmt 1
 1126 0048 EFE9      		ldi r30,lo8(3999)
 1127 004a FFE0      		ldi r31,hi8(3999)
 1128 004c 3197      	1:	sbiw r30,1
 1129 004e 01F4      		brne 1b
 1130 0050 00C0      		rjmp .
 1131 0052 0000      		nop
 1132 0054 00C0      		rjmp .L87
 1133               	.LVL118:
 1134               	.L85:
 1135               	.LBE47:
 1136               	.LBE46:
 1137               	.LBE45:
 827:quantum/quantum.c ****           // up
 1138               		.loc 1 827 0
 1139 0056 8330      		cpi r24,lo8(3)
 1140 0058 01F4      		brne .L86
 1141               	.LVL119:
 1142               	.LBB48:
 1143               	.LBB42:
 829:quantum/quantum.c ****           unregister_code(keycode);
 1144               		.loc 1 829 0
 1145 005a FE01      		movw r30,r28
 1146               	/* #APP */
 1147               	 ;  829 "quantum/quantum.c" 1
 1148 005c 8491      		lpm r24, Z
 1149               		
 1150               	 ;  0 "" 2
 1151               	.LVL120:
 1152               	/* #NOAPP */
 1153 005e 00C0      		rjmp .L90
 1154               	.LVL121:
 1155               	.L86:
 1156               	.LBE42:
 1157               	.LBE48:
 832:quantum/quantum.c ****         }
 1158               		.loc 1 832 0
 1159 0060 0E94 0000 		call send_char
 1160               	.LVL122:
 1161 0064 E801      		movw r28,r16
 1162 0066 00C0      		rjmp .L84
 1163               	.LVL123:
 1164               	.L81:
 1165               	/* epilogue start */
 1166               	.LBE37:
 838:quantum/quantum.c **** 
 1167               		.loc 1 838 0
 1168 0068 DF91      		pop r29
 1169 006a CF91      		pop r28
 1170 006c 1F91      		pop r17
 1171 006e 0F91      		pop r16
 1172               	.LVL124:
 1173 0070 FF90      		pop r15
 1174               	.LVL125:
 1175 0072 0895      		ret
 1176               		.cfi_endproc
 1177               	.LFE47:
 1179               		.section	.text.send_string_P,"ax",@progbits
 1180               	.global	send_string_P
 1182               	send_string_P:
 1183               	.LFB45:
 784:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1184               		.loc 1 784 0
 1185               		.cfi_startproc
 1186               	.LVL126:
 1187               	/* prologue: function */
 1188               	/* frame size = 0 */
 1189               	/* stack size = 0 */
 1190               	.L__stack_usage = 0
 785:quantum/quantum.c **** }
 1191               		.loc 1 785 0
 1192 0000 60E0      		ldi r22,0
 1193 0002 0C94 0000 		jmp send_string_with_delay_P
 1194               	.LVL127:
 1195               		.cfi_endproc
 1196               	.LFE45:
 1198               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1199               	.global	set_single_persistent_default_layer
 1201               	set_single_persistent_default_layer:
 1202               	.LFB49:
 859:quantum/quantum.c **** 
 860:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1203               		.loc 1 860 0
 1204               		.cfi_startproc
 1205               	.LVL128:
 1206 0000 CF93      		push r28
 1207               	.LCFI28:
 1208               		.cfi_def_cfa_offset 3
 1209               		.cfi_offset 28, -2
 1210 0002 DF93      		push r29
 1211               	.LCFI29:
 1212               		.cfi_def_cfa_offset 4
 1213               		.cfi_offset 29, -3
 1214               	/* prologue: function */
 1215               	/* frame size = 0 */
 1216               	/* stack size = 2 */
 1217               	.L__stack_usage = 2
 861:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 862:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 863:quantum/quantum.c ****   #endif
 864:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1218               		.loc 1 864 0
 1219 0004 C1E0      		ldi r28,lo8(1)
 1220 0006 D0E0      		ldi r29,0
 1221 0008 00C0      		rjmp 2f
 1222               		1:
 1223 000a CC0F      		lsl r28
 1224 000c DD1F      		rol r29
 1225               		2:
 1226 000e 8A95      		dec r24
 1227 0010 02F4      		brpl 1b
 1228 0012 8C2F      		mov r24,r28
 1229               	.LVL129:
 1230 0014 0E94 0000 		call eeconfig_update_default_layer
 1231               	.LVL130:
 865:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1232               		.loc 1 865 0
 1233 0018 BE01      		movw r22,r28
 1234 001a 90E0      		ldi r25,0
 1235 001c 80E0      		ldi r24,0
 1236               	/* epilogue start */
 866:quantum/quantum.c **** }
 1237               		.loc 1 866 0
 1238 001e DF91      		pop r29
 1239 0020 CF91      		pop r28
 865:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1240               		.loc 1 865 0
 1241 0022 0C94 0000 		jmp default_layer_set
 1242               	.LVL131:
 1243               		.cfi_endproc
 1244               	.LFE49:
 1246               		.section	.text.update_tri_layer_state,"ax",@progbits
 1247               	.global	update_tri_layer_state
 1249               	update_tri_layer_state:
 1250               	.LFB50:
 867:quantum/quantum.c **** 
 868:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1251               		.loc 1 868 0
 1252               		.cfi_startproc
 1253               	.LVL132:
 1254 0000 8F92      		push r8
 1255               	.LCFI30:
 1256               		.cfi_def_cfa_offset 3
 1257               		.cfi_offset 8, -2
 1258 0002 9F92      		push r9
 1259               	.LCFI31:
 1260               		.cfi_def_cfa_offset 4
 1261               		.cfi_offset 9, -3
 1262 0004 AF92      		push r10
 1263               	.LCFI32:
 1264               		.cfi_def_cfa_offset 5
 1265               		.cfi_offset 10, -4
 1266 0006 BF92      		push r11
 1267               	.LCFI33:
 1268               		.cfi_def_cfa_offset 6
 1269               		.cfi_offset 11, -5
 1270 0008 CF92      		push r12
 1271               	.LCFI34:
 1272               		.cfi_def_cfa_offset 7
 1273               		.cfi_offset 12, -6
 1274 000a DF92      		push r13
 1275               	.LCFI35:
 1276               		.cfi_def_cfa_offset 8
 1277               		.cfi_offset 13, -7
 1278 000c EF92      		push r14
 1279               	.LCFI36:
 1280               		.cfi_def_cfa_offset 9
 1281               		.cfi_offset 14, -8
 1282 000e FF92      		push r15
 1283               	.LCFI37:
 1284               		.cfi_def_cfa_offset 10
 1285               		.cfi_offset 15, -9
 1286 0010 0F93      		push r16
 1287               	.LCFI38:
 1288               		.cfi_def_cfa_offset 11
 1289               		.cfi_offset 16, -10
 1290 0012 1F93      		push r17
 1291               	.LCFI39:
 1292               		.cfi_def_cfa_offset 12
 1293               		.cfi_offset 17, -11
 1294               	/* prologue: function */
 1295               	/* frame size = 0 */
 1296               	/* stack size = 10 */
 1297               	.L__stack_usage = 10
 1298 0014 6B01      		movw r12,r22
 1299 0016 7C01      		movw r14,r24
 869:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1300               		.loc 1 869 0
 1301 0018 81E0      		ldi r24,lo8(1)
 1302 001a 90E0      		ldi r25,0
 1303 001c A0E0      		ldi r26,0
 1304 001e B0E0      		ldi r27,0
 1305 0020 4C01      		movw r8,r24
 1306 0022 5D01      		movw r10,r26
 1307 0024 00C0      		rjmp 2f
 1308               		1:
 1309 0026 880C      		lsl r8
 1310 0028 991C      		rol r9
 1311 002a AA1C      		rol r10
 1312 002c BB1C      		rol r11
 1313               		2:
 1314 002e 4A95      		dec r20
 1315 0030 02F4      		brpl 1b
 1316 0032 B501      		movw r22,r10
 1317               	.LVL133:
 1318 0034 A401      		movw r20,r8
 1319               	.LVL134:
 1320 0036 4C01      		movw r8,r24
 1321 0038 5D01      		movw r10,r26
 1322 003a 00C0      		rjmp 2f
 1323               		1:
 1324 003c 880C      		lsl r8
 1325 003e 991C      		rol r9
 1326 0040 AA1C      		rol r10
 1327 0042 BB1C      		rol r11
 1328               		2:
 1329 0044 2A95      		dec r18
 1330 0046 02F4      		brpl 1b
 1331 0048 4829      		or r20,r8
 1332 004a 5929      		or r21,r9
 1333 004c 6A29      		or r22,r10
 1334 004e 7B29      		or r23,r11
 1335               	.LVL135:
 870:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 1336               		.loc 1 870 0
 1337 0050 00C0      		rjmp 2f
 1338               		1:
 1339 0052 880F      		lsl r24
 1340 0054 991F      		rol r25
 1341 0056 AA1F      		rol r26
 1342 0058 BB1F      		rol r27
 1343               		2:
 1344 005a 0A95      		dec r16
 1345 005c 02F4      		brpl 1b
 1346               	.LVL136:
 871:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1347               		.loc 1 871 0
 1348 005e 8A01      		movw r16,r20
 1349               	.LVL137:
 1350 0060 9B01      		movw r18,r22
 1351               	.LVL138:
 1352 0062 0C21      		and r16,r12
 1353 0064 1D21      		and r17,r13
 1354 0066 2E21      		and r18,r14
 1355 0068 3F21      		and r19,r15
 1356 006a 0417      		cp r16,r20
 1357 006c 1507      		cpc r17,r21
 1358 006e 2607      		cpc r18,r22
 1359 0070 3707      		cpc r19,r23
 1360 0072 01F4      		brne .L94
 1361               		.loc 1 871 0 is_stmt 0 discriminator 1
 1362 0074 8C29      		or r24,r12
 1363               	.LVL139:
 1364 0076 9D29      		or r25,r13
 1365 0078 AE29      		or r26,r14
 1366 007a BF29      		or r27,r15
 1367               	.L93:
 872:quantum/quantum.c **** }
 1368               		.loc 1 872 0 is_stmt 1
 1369 007c BC01      		movw r22,r24
 1370 007e CD01      		movw r24,r26
 1371               	/* epilogue start */
 1372 0080 1F91      		pop r17
 1373               	.LVL140:
 1374 0082 0F91      		pop r16
 1375               	.LVL141:
 1376 0084 FF90      		pop r15
 1377 0086 EF90      		pop r14
 1378 0088 DF90      		pop r13
 1379 008a CF90      		pop r12
 1380 008c BF90      		pop r11
 1381 008e AF90      		pop r10
 1382 0090 9F90      		pop r9
 1383 0092 8F90      		pop r8
 1384               	.LVL142:
 1385 0094 0895      		ret
 1386               	.LVL143:
 1387               	.L94:
 871:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1388               		.loc 1 871 0 discriminator 2
 1389 0096 8095      		com r24
 1390 0098 9095      		com r25
 1391 009a A095      		com r26
 1392 009c B095      		com r27
 1393               	.LVL144:
 1394 009e 8C21      		and r24,r12
 1395               	.LVL145:
 1396 00a0 9D21      		and r25,r13
 1397 00a2 AE21      		and r26,r14
 1398 00a4 BF21      		and r27,r15
 1399 00a6 00C0      		rjmp .L93
 1400               		.cfi_endproc
 1401               	.LFE50:
 1403               		.section	.text.update_tri_layer,"ax",@progbits
 1404               	.global	update_tri_layer
 1406               	update_tri_layer:
 1407               	.LFB51:
 873:quantum/quantum.c **** 
 874:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1408               		.loc 1 874 0
 1409               		.cfi_startproc
 1410               	.LVL146:
 1411 0000 0F93      		push r16
 1412               	.LCFI40:
 1413               		.cfi_def_cfa_offset 3
 1414               		.cfi_offset 16, -2
 1415               	/* prologue: function */
 1416               	/* frame size = 0 */
 1417               	/* stack size = 1 */
 1418               	.L__stack_usage = 1
 1419 0002 382F      		mov r19,r24
 1420 0004 262F      		mov r18,r22
 875:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1421               		.loc 1 875 0
 1422 0006 6091 0000 		lds r22,layer_state
 1423 000a 7091 0000 		lds r23,layer_state+1
 1424 000e 8091 0000 		lds r24,layer_state+2
 1425 0012 9091 0000 		lds r25,layer_state+3
 1426               	.LVL147:
 1427 0016 042F      		mov r16,r20
 1428 0018 432F      		mov r20,r19
 1429               	.LVL148:
 1430 001a 0E94 0000 		call update_tri_layer_state
 1431               	.LVL149:
 1432               	/* epilogue start */
 876:quantum/quantum.c **** }
 1433               		.loc 1 876 0
 1434 001e 0F91      		pop r16
 1435               	.LVL150:
 875:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1436               		.loc 1 875 0
 1437 0020 0C94 0000 		jmp layer_state_set
 1438               	.LVL151:
 1439               		.cfi_endproc
 1440               	.LFE51:
 1442               		.section	.text.tap_random_base64,"ax",@progbits
 1443               	.global	tap_random_base64
 1445               	tap_random_base64:
 1446               	.LFB52:
 877:quantum/quantum.c **** 
 878:quantum/quantum.c **** void tap_random_base64(void) {
 1447               		.loc 1 878 0
 1448               		.cfi_startproc
 1449 0000 CF93      		push r28
 1450               	.LCFI41:
 1451               		.cfi_def_cfa_offset 3
 1452               		.cfi_offset 28, -2
 1453 0002 DF93      		push r29
 1454               	.LCFI42:
 1455               		.cfi_def_cfa_offset 4
 1456               		.cfi_offset 29, -3
 1457               	/* prologue: function */
 1458               	/* frame size = 0 */
 1459               	/* stack size = 2 */
 1460               	.L__stack_usage = 2
 879:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 880:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1461               		.loc 1 880 0
 1462 0004 46B5      		in r20,0x26
 1463 0006 2091 8400 		lds r18,132
 1464 000a 3091 8500 		lds r19,132+1
 1465 000e C091 9400 		lds r28,148
 1466 0012 D091 9500 		lds r29,148+1
 1467 0016 8091 BE00 		lds r24,190
 1468 001a 9091 BF00 		lds r25,190+1
 1469 001e C20F      		add r28,r18
 1470 0020 C40F      		add r28,r20
 1471 0022 C80F      		add r28,r24
 1472 0024 CF73      		andi r28,lo8(63)
 1473               	.LVL152:
 881:quantum/quantum.c ****   #else
 882:quantum/quantum.c ****     uint8_t key = rand() % 64;
 883:quantum/quantum.c ****   #endif
 884:quantum/quantum.c ****   switch (key) {
 1474               		.loc 1 884 0
 1475 0026 CE33      		cpi r28,lo8(62)
 1476 0028 00F4      		brsh .L99
 1477 002a C533      		cpi r28,lo8(53)
 1478 002c 00F4      		brsh .L100
 1479 002e CA31      		cpi r28,lo8(26)
 1480 0030 00F0      		brlo .L98
 1481 0032 C433      		cpi r28,lo8(52)
 1482 0034 00F4      		brsh .L105
 885:quantum/quantum.c ****     case 0 ... 25:
 886:quantum/quantum.c ****       register_code(KC_LSFT);
 887:quantum/quantum.c ****       register_code(key + KC_A);
 888:quantum/quantum.c ****       unregister_code(key + KC_A);
 889:quantum/quantum.c ****       unregister_code(KC_LSFT);
 890:quantum/quantum.c ****       break;
 891:quantum/quantum.c ****     case 26 ... 51:
 892:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1483               		.loc 1 892 0
 1484 0036 C651      		subi r28,lo8(-(-22))
 1485               	.LVL153:
 1486               	.L108:
 893:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 894:quantum/quantum.c ****       break;
 895:quantum/quantum.c ****     case 52:
 896:quantum/quantum.c ****       register_code(KC_0);
 897:quantum/quantum.c ****       unregister_code(KC_0);
 898:quantum/quantum.c ****       break;
 899:quantum/quantum.c ****     case 53 ... 61:
 900:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1487               		.loc 1 900 0
 1488 0038 8C2F      		mov r24,r28
 1489 003a 0E94 0000 		call register_code
 1490               	.LVL154:
 901:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1491               		.loc 1 901 0
 1492 003e 8C2F      		mov r24,r28
 1493 0040 00C0      		rjmp .L106
 1494               	.LVL155:
 1495               	.L99:
 884:quantum/quantum.c ****     case 0 ... 25:
 1496               		.loc 1 884 0
 1497 0042 CE33      		cpi r28,lo8(62)
 1498 0044 01F0      		breq .L103
 1499 0046 CF33      		cpi r28,lo8(63)
 1500 0048 01F0      		breq .L104
 1501               	.L98:
 886:quantum/quantum.c ****       register_code(key + KC_A);
 1502               		.loc 1 886 0
 1503 004a 81EE      		ldi r24,lo8(-31)
 1504 004c 0E94 0000 		call register_code
 1505               	.LVL156:
 887:quantum/quantum.c ****       unregister_code(key + KC_A);
 1506               		.loc 1 887 0
 1507 0050 CC5F      		subi r28,lo8(-(4))
 1508               	.LVL157:
 1509 0052 8C2F      		mov r24,r28
 1510 0054 0E94 0000 		call register_code
 1511               	.LVL158:
 888:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1512               		.loc 1 888 0
 1513 0058 8C2F      		mov r24,r28
 1514               	.LVL159:
 1515               	.L107:
 902:quantum/quantum.c ****       break;
 903:quantum/quantum.c ****     case 62:
 904:quantum/quantum.c ****       register_code(KC_LSFT);
 905:quantum/quantum.c ****       register_code(KC_EQL);
 906:quantum/quantum.c ****       unregister_code(KC_EQL);
 1516               		.loc 1 906 0
 1517 005a 0E94 0000 		call unregister_code
 1518               	.LVL160:
 907:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1519               		.loc 1 907 0
 1520 005e 81EE      		ldi r24,lo8(-31)
 1521 0060 00C0      		rjmp .L106
 1522               	.LVL161:
 1523               	.L105:
 896:quantum/quantum.c ****       unregister_code(KC_0);
 1524               		.loc 1 896 0
 1525 0062 87E2      		ldi r24,lo8(39)
 1526 0064 0E94 0000 		call register_code
 1527               	.LVL162:
 897:quantum/quantum.c ****       break;
 1528               		.loc 1 897 0
 1529 0068 87E2      		ldi r24,lo8(39)
 1530               	.LVL163:
 1531               	.L106:
 1532               	/* epilogue start */
 908:quantum/quantum.c ****       break;
 909:quantum/quantum.c ****     case 63:
 910:quantum/quantum.c ****       register_code(KC_SLSH);
 911:quantum/quantum.c ****       unregister_code(KC_SLSH);
 912:quantum/quantum.c ****       break;
 913:quantum/quantum.c ****   }
 914:quantum/quantum.c **** }
 1533               		.loc 1 914 0
 1534 006a DF91      		pop r29
 1535 006c CF91      		pop r28
 911:quantum/quantum.c ****       break;
 1536               		.loc 1 911 0
 1537 006e 0C94 0000 		jmp unregister_code
 1538               	.LVL164:
 1539               	.L100:
 900:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1540               		.loc 1 900 0
 1541 0072 C751      		subi r28,lo8(-(-23))
 1542               	.LVL165:
 1543 0074 00C0      		rjmp .L108
 1544               	.LVL166:
 1545               	.L103:
 904:quantum/quantum.c ****       register_code(KC_EQL);
 1546               		.loc 1 904 0
 1547 0076 81EE      		ldi r24,lo8(-31)
 1548 0078 0E94 0000 		call register_code
 1549               	.LVL167:
 905:quantum/quantum.c ****       unregister_code(KC_EQL);
 1550               		.loc 1 905 0
 1551 007c 8EE2      		ldi r24,lo8(46)
 1552 007e 0E94 0000 		call register_code
 1553               	.LVL168:
 906:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1554               		.loc 1 906 0
 1555 0082 8EE2      		ldi r24,lo8(46)
 1556 0084 00C0      		rjmp .L107
 1557               	.L104:
 910:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1558               		.loc 1 910 0
 1559 0086 88E3      		ldi r24,lo8(56)
 1560 0088 0E94 0000 		call register_code
 1561               	.LVL169:
 911:quantum/quantum.c ****       break;
 1562               		.loc 1 911 0
 1563 008c 88E3      		ldi r24,lo8(56)
 1564 008e 00C0      		rjmp .L106
 1565               		.cfi_endproc
 1566               	.LFE52:
 1568               		.section	.text.bootmagic_lite,"ax",@progbits
 1569               		.weak	bootmagic_lite
 1571               	bootmagic_lite:
 1572               	.LFB53:
 915:quantum/quantum.c **** 
 916:quantum/quantum.c **** __attribute__((weak))
 917:quantum/quantum.c **** void bootmagic_lite(void) {
 1573               		.loc 1 917 0
 1574               		.cfi_startproc
 1575               	/* prologue: function */
 1576               	/* frame size = 0 */
 1577               	/* stack size = 0 */
 1578               	.L__stack_usage = 0
 918:quantum/quantum.c ****   // The lite version of TMK's bootmagic based on Wilba.
 919:quantum/quantum.c ****   // 100% less potential for accidentally making the
 920:quantum/quantum.c ****   // keyboard do stupid things.
 921:quantum/quantum.c **** 
 922:quantum/quantum.c ****   // We need multiple scans because debouncing can't be turned off.
 923:quantum/quantum.c ****   matrix_scan();
 1579               		.loc 1 923 0
 1580 0000 0E94 0000 		call matrix_scan
 1581               	.LVL170:
 1582               	.LBB49:
 1583               	.LBB50:
 1584               		.loc 2 187 0
 1585 0004 8FE3      		ldi r24,lo8(-25537)
 1586 0006 9CE9      		ldi r25,hi8(-25537)
 1587 0008 0197      	1:	sbiw r24,1
 1588 000a 01F4      		brne 1b
 1589 000c 00C0      		rjmp .
 1590 000e 0000      		nop
 1591               	.LVL171:
 1592               	.LBE50:
 1593               	.LBE49:
 924:quantum/quantum.c ****   #if defined(DEBOUNCING_DELAY) && DEBOUNCING_DELAY > 0
 925:quantum/quantum.c ****     wait_ms(DEBOUNCING_DELAY * 2);
 926:quantum/quantum.c ****   #elif defined(DEBOUNCE) && DEBOUNCE > 0
 927:quantum/quantum.c ****     wait_ms(DEBOUNCE * 2);
 928:quantum/quantum.c ****   #else
 929:quantum/quantum.c ****     wait_ms(30);
 930:quantum/quantum.c ****   #endif
 931:quantum/quantum.c ****   matrix_scan();
 1594               		.loc 1 931 0
 1595 0010 0E94 0000 		call matrix_scan
 1596               	.LVL172:
 932:quantum/quantum.c **** 
 933:quantum/quantum.c ****   // If the Esc and space bar are held down on power up,
 934:quantum/quantum.c ****   // reset the EEPROM valid state and jump to bootloader.
 935:quantum/quantum.c ****   // Assumes Esc is at [0,0].
 936:quantum/quantum.c ****   // This isn't very generalized, but we need something that doesn't
 937:quantum/quantum.c ****   // rely on user's keymaps in firmware or EEPROM.
 938:quantum/quantum.c ****   if (matrix_get_row(BOOTMAGIC_LITE_ROW) & (1 << BOOTMAGIC_LITE_COLUMN)) {
 1597               		.loc 1 938 0
 1598 0014 80E0      		ldi r24,0
 1599 0016 0E94 0000 		call matrix_get_row
 1600               	.LVL173:
 1601 001a 80FF      		sbrs r24,0
 1602 001c 00C0      		rjmp .L109
 939:quantum/quantum.c ****     eeconfig_disable();
 1603               		.loc 1 939 0
 1604 001e 0E94 0000 		call eeconfig_disable
 1605               	.LVL174:
 940:quantum/quantum.c ****     // Jump to bootloader.
 941:quantum/quantum.c ****     bootloader_jump();
 1606               		.loc 1 941 0
 1607 0022 0C94 0000 		jmp bootloader_jump
 1608               	.LVL175:
 1609               	.L109:
 1610               	/* epilogue start */
 942:quantum/quantum.c ****   }
 943:quantum/quantum.c **** }
 1611               		.loc 1 943 0
 1612 0026 0895      		ret
 1613               		.cfi_endproc
 1614               	.LFE53:
 1616               		.section	.text.matrix_init_quantum,"ax",@progbits
 1617               	.global	matrix_init_quantum
 1619               	matrix_init_quantum:
 1620               	.LFB54:
 944:quantum/quantum.c **** 
 945:quantum/quantum.c **** void matrix_init_quantum() {
 1621               		.loc 1 945 0
 1622               		.cfi_startproc
 1623               	/* prologue: function */
 1624               	/* frame size = 0 */
 1625               	/* stack size = 0 */
 1626               	.L__stack_usage = 0
 946:quantum/quantum.c ****   #ifdef BOOTMAGIC_LITE
 947:quantum/quantum.c ****     bootmagic_lite();
 948:quantum/quantum.c ****   #endif
 949:quantum/quantum.c ****   if (!eeconfig_is_enabled()) {
 1627               		.loc 1 949 0
 1628 0000 0E94 0000 		call eeconfig_is_enabled
 1629               	.LVL176:
 1630 0004 8111      		cpse r24,__zero_reg__
 1631 0006 00C0      		rjmp .L112
 950:quantum/quantum.c ****     eeconfig_init();
 1632               		.loc 1 950 0
 1633 0008 0E94 0000 		call eeconfig_init
 1634               	.LVL177:
 1635               	.L112:
 951:quantum/quantum.c ****   }
 952:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 953:quantum/quantum.c ****     #ifdef LED_MATRIX_ENABLE
 954:quantum/quantum.c ****         led_matrix_init();
 955:quantum/quantum.c ****     #else
 956:quantum/quantum.c ****         backlight_init_ports();
 957:quantum/quantum.c ****     #endif
 958:quantum/quantum.c ****   #endif
 959:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 960:quantum/quantum.c ****     audio_init();
 961:quantum/quantum.c ****   #endif
 962:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 963:quantum/quantum.c ****     rgb_matrix_init();
 964:quantum/quantum.c ****   #endif
 965:quantum/quantum.c ****   #ifdef ENCODER_ENABLE
 966:quantum/quantum.c ****     encoder_init();
 967:quantum/quantum.c ****   #endif
 968:quantum/quantum.c ****   #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 969:quantum/quantum.c ****     unicode_input_mode_init();
 970:quantum/quantum.c ****   #endif
 971:quantum/quantum.c ****   #ifdef HAPTIC_ENABLE
 972:quantum/quantum.c ****     haptic_init();
 973:quantum/quantum.c ****   #endif
 974:quantum/quantum.c ****   #ifdef OUTPUT_AUTO_ENABLE
 975:quantum/quantum.c ****     set_output(OUTPUT_AUTO);
 976:quantum/quantum.c ****   #endif
 977:quantum/quantum.c ****   matrix_init_kb();
 1636               		.loc 1 977 0
 1637 000c 0C94 0000 		jmp matrix_init_kb
 1638               	.LVL178:
 1639               		.cfi_endproc
 1640               	.LFE54:
 1642               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1643               	.global	matrix_scan_quantum
 1645               	matrix_scan_quantum:
 1646               	.LFB55:
 978:quantum/quantum.c **** }
 979:quantum/quantum.c **** 
 980:quantum/quantum.c **** void matrix_scan_quantum() {
 1647               		.loc 1 980 0
 1648               		.cfi_startproc
 1649               	/* prologue: function */
 1650               	/* frame size = 0 */
 1651               	/* stack size = 0 */
 1652               	.L__stack_usage = 0
 981:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 982:quantum/quantum.c ****     matrix_scan_music();
 983:quantum/quantum.c ****   #endif
 984:quantum/quantum.c **** 
 985:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 986:quantum/quantum.c ****     matrix_scan_tap_dance();
 987:quantum/quantum.c ****   #endif
 988:quantum/quantum.c **** 
 989:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 990:quantum/quantum.c ****     matrix_scan_combo();
 991:quantum/quantum.c ****   #endif
 992:quantum/quantum.c **** 
 993:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE)
 994:quantum/quantum.c ****     #if defined(LED_MATRIX_ENABLE)
 995:quantum/quantum.c ****         led_matrix_task();
 996:quantum/quantum.c ****     #elif defined(BACKLIGHT_PIN)
 997:quantum/quantum.c ****         backlight_task();
 998:quantum/quantum.c ****     #endif
 999:quantum/quantum.c ****   #endif
1000:quantum/quantum.c **** 
1001:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
1002:quantum/quantum.c ****     rgb_matrix_task();
1003:quantum/quantum.c ****   #endif
1004:quantum/quantum.c **** 
1005:quantum/quantum.c ****   #ifdef ENCODER_ENABLE
1006:quantum/quantum.c ****     encoder_read();
1007:quantum/quantum.c ****   #endif
1008:quantum/quantum.c **** 
1009:quantum/quantum.c ****   #ifdef HAPTIC_ENABLE
1010:quantum/quantum.c ****     haptic_task();
1011:quantum/quantum.c ****   #endif
1012:quantum/quantum.c **** 
1013:quantum/quantum.c ****   matrix_scan_kb();
 1653               		.loc 1 1013 0
 1654 0000 0C94 0000 		jmp matrix_scan_kb
 1655               	.LVL179:
 1656               		.cfi_endproc
 1657               	.LFE55:
 1659               		.section	.text.backlight_init_ports,"ax",@progbits
 1660               		.weak	backlight_init_ports
 1662               	backlight_init_ports:
 1663               	.LFB97:
 1664               		.cfi_startproc
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 0 */
 1668               	.L__stack_usage = 0
 1669               	/* epilogue start */
 1670 0000 0895      		ret
 1671               		.cfi_endproc
 1672               	.LFE97:
 1674               		.section	.text.send_nibble,"ax",@progbits
 1675               	.global	send_nibble
 1677               	send_nibble:
 1678               	.LFB61:
1014:quantum/quantum.c **** }
1015:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && (defined(BACKLIGHT_PIN) || defined(BACKLIGHT_PINS))
1016:quantum/quantum.c **** 
1017:quantum/quantum.c **** // The logic is a bit complex, we support 3 setups:
1018:quantum/quantum.c **** // 1. hardware PWM when backlight is wired to a PWM pin
1019:quantum/quantum.c **** // depending on this pin, we use a different output compare unit
1020:quantum/quantum.c **** // 2. software PWM with hardware timers, but the used timer depends
1021:quantum/quantum.c **** // on the audio setup (audio wins other backlight)
1022:quantum/quantum.c **** // 3. full software PWM
1023:quantum/quantum.c **** 
1024:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
1025:quantum/quantum.c **** #  define HARDWARE_PWM
1026:quantum/quantum.c **** #  define TCCRxA TCCR1A
1027:quantum/quantum.c **** #  define TCCRxB TCCR1B
1028:quantum/quantum.c **** #  define COMxx1 COM1C1
1029:quantum/quantum.c **** #  define OCRxx  OCR1C
1030:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER1_OVF_vect
1031:quantum/quantum.c **** #  define TOIEx  TOIE1
1032:quantum/quantum.c **** #  define ICRx   ICR1
1033:quantum/quantum.c **** #  define TIMSKx TIMSK1
1034:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
1035:quantum/quantum.c **** #  define HARDWARE_PWM
1036:quantum/quantum.c **** #  define TCCRxA TCCR1A
1037:quantum/quantum.c **** #  define TCCRxB TCCR1B
1038:quantum/quantum.c **** #  define COMxx1 COM1B1
1039:quantum/quantum.c **** #  define OCRxx  OCR1B
1040:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER1_OVF_vect
1041:quantum/quantum.c **** #  define TOIEx  TOIE1
1042:quantum/quantum.c **** #  define ICRx   ICR1
1043:quantum/quantum.c **** #  define TIMSKx TIMSK1
1044:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
1045:quantum/quantum.c **** #  define HARDWARE_PWM
1046:quantum/quantum.c **** #  define TCCRxA TCCR1A
1047:quantum/quantum.c **** #  define TCCRxB TCCR1B
1048:quantum/quantum.c **** #  define COMxx1 COM1A1
1049:quantum/quantum.c **** #  define OCRxx  OCR1A
1050:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER1_OVF_vect
1051:quantum/quantum.c **** #  define TOIEx  TOIE1
1052:quantum/quantum.c **** #  define ICRx   ICR1
1053:quantum/quantum.c **** #  define TIMSKx TIMSK1
1054:quantum/quantum.c **** #elif BACKLIGHT_PIN == C6
1055:quantum/quantum.c **** #  define HARDWARE_PWM
1056:quantum/quantum.c **** #  define TCCRxA TCCR3A
1057:quantum/quantum.c **** #  define TCCRxB TCCR3B
1058:quantum/quantum.c **** #  define COMxx1 COM3A1
1059:quantum/quantum.c **** #  define OCRxx  OCR3A
1060:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER3_OVF_vect
1061:quantum/quantum.c **** #  define TOIEx  TOIE3
1062:quantum/quantum.c **** #  define ICRx   ICR3
1063:quantum/quantum.c **** #  define TIMSKx TIMSK3
1064:quantum/quantum.c **** #elif defined(__AVR_ATmega32A__) && BACKLIGHT_PIN == D4
1065:quantum/quantum.c **** #  define TCCRxA TCCR1A
1066:quantum/quantum.c **** #  define TCCRxB TCCR1B
1067:quantum/quantum.c **** #  define COMxx1 COM1B1
1068:quantum/quantum.c **** #  define OCRxx  OCR1B
1069:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER1_OVF_vect
1070:quantum/quantum.c **** #  define TOIEx  TOIE1
1071:quantum/quantum.c **** #  define ICRx   ICR1
1072:quantum/quantum.c **** #  define TIMSKx TIMSK1
1073:quantum/quantum.c **** #else
1074:quantum/quantum.c **** #  if !defined(BACKLIGHT_CUSTOM_DRIVER)
1075:quantum/quantum.c **** #    if !defined(B5_AUDIO) && !defined(B6_AUDIO) && !defined(B7_AUDIO)
1076:quantum/quantum.c ****      // timer 1 is not used by audio , backlight can use it
1077:quantum/quantum.c **** #pragma message "Using hardware timer 1 with software PWM"
1078:quantum/quantum.c **** #      define HARDWARE_PWM
1079:quantum/quantum.c **** #      define BACKLIGHT_PWM_TIMER
1080:quantum/quantum.c **** #      define TCCRxA TCCR1A
1081:quantum/quantum.c **** #      define TCCRxB TCCR1B
1082:quantum/quantum.c **** #      define OCRxx  OCR1A
1083:quantum/quantum.c **** #      define TIMERx_COMPA_vect TIMER1_COMPA_vect
1084:quantum/quantum.c **** #      define TIMERx_OVF_vect TIMER1_OVF_vect
1085:quantum/quantum.c **** #      define OCIExA OCIE1A
1086:quantum/quantum.c **** #      define TOIEx  TOIE1
1087:quantum/quantum.c **** #      define ICRx   ICR1
1088:quantum/quantum.c **** #      if defined(__AVR_ATmega32A__) // This MCU has only one TIMSK register
1089:quantum/quantum.c **** #        define TIMSKx TIMSK
1090:quantum/quantum.c **** #      else
1091:quantum/quantum.c **** #        define TIMSKx TIMSK1
1092:quantum/quantum.c **** #      endif
1093:quantum/quantum.c **** #    elif !defined(C6_AUDIO) && !defined(C5_AUDIO) && !defined(C4_AUDIO)
1094:quantum/quantum.c **** #pragma message "Using hardware timer 3 with software PWM"
1095:quantum/quantum.c **** // timer 3 is not used by audio, backlight can use it
1096:quantum/quantum.c **** #      define HARDWARE_PWM
1097:quantum/quantum.c **** #      define BACKLIGHT_PWM_TIMER
1098:quantum/quantum.c **** #      define TCCRxA TCCR3A
1099:quantum/quantum.c **** #      define TCCRxB TCCR3B
1100:quantum/quantum.c **** #      define OCRxx OCR3A
1101:quantum/quantum.c **** #      define TIMERx_COMPA_vect TIMER3_COMPA_vect
1102:quantum/quantum.c **** #      define TIMERx_OVF_vect TIMER3_OVF_vect
1103:quantum/quantum.c **** #      define OCIExA OCIE3A
1104:quantum/quantum.c **** #      define TOIEx  TOIE3
1105:quantum/quantum.c **** #      define ICRx   ICR1
1106:quantum/quantum.c **** #      define TIMSKx TIMSK3
1107:quantum/quantum.c **** #    else
1108:quantum/quantum.c **** #pragma message "Audio in use - using pure software PWM"
1109:quantum/quantum.c **** #define NO_HARDWARE_PWM
1110:quantum/quantum.c **** #    endif
1111:quantum/quantum.c **** #  else
1112:quantum/quantum.c **** #pragma message "Custom driver defined - using pure software PWM"
1113:quantum/quantum.c **** #define NO_HARDWARE_PWM
1114:quantum/quantum.c **** #  endif
1115:quantum/quantum.c **** #endif
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
1118:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
1119:quantum/quantum.c **** #endif
1120:quantum/quantum.c **** 
1121:quantum/quantum.c **** void backlight_on(uint8_t backlight_pin) {
1122:quantum/quantum.c **** #if BACKLIGHT_ON_STATE == 0
1123:quantum/quantum.c ****   writePinLow(backlight_pin);
1124:quantum/quantum.c **** #else
1125:quantum/quantum.c ****   writePinHigh(backlight_pin);
1126:quantum/quantum.c **** #endif
1127:quantum/quantum.c **** }
1128:quantum/quantum.c **** 
1129:quantum/quantum.c **** void backlight_off(uint8_t backlight_pin) {
1130:quantum/quantum.c **** #if BACKLIGHT_ON_STATE == 0
1131:quantum/quantum.c ****   writePinHigh(backlight_pin);
1132:quantum/quantum.c **** #else
1133:quantum/quantum.c ****   writePinLow(backlight_pin);
1134:quantum/quantum.c **** #endif
1135:quantum/quantum.c **** }
1136:quantum/quantum.c **** 
1137:quantum/quantum.c **** 
1138:quantum/quantum.c **** #if defined(NO_HARDWARE_PWM) || defined(BACKLIGHT_PWM_TIMER)  // pwm through software
1139:quantum/quantum.c **** 
1140:quantum/quantum.c **** // we support multiple backlight pins
1141:quantum/quantum.c **** #ifndef BACKLIGHT_LED_COUNT
1142:quantum/quantum.c **** #define BACKLIGHT_LED_COUNT 1
1143:quantum/quantum.c **** #endif
1144:quantum/quantum.c **** 
1145:quantum/quantum.c **** #if BACKLIGHT_LED_COUNT == 1
1146:quantum/quantum.c **** #define BACKLIGHT_PIN_INIT { BACKLIGHT_PIN }
1147:quantum/quantum.c **** #else
1148:quantum/quantum.c **** #define BACKLIGHT_PIN_INIT BACKLIGHT_PINS
1149:quantum/quantum.c **** #endif
1150:quantum/quantum.c **** 
1151:quantum/quantum.c **** #define FOR_EACH_LED(x)                             \
1152:quantum/quantum.c ****   for (uint8_t i = 0; i < BACKLIGHT_LED_COUNT; i++) \
1153:quantum/quantum.c ****   {                                                 \
1154:quantum/quantum.c ****     uint8_t backlight_pin = backlight_pins[i];      \
1155:quantum/quantum.c ****     { \
1156:quantum/quantum.c ****       x                         \
1157:quantum/quantum.c ****     }                                             \
1158:quantum/quantum.c ****   }
1159:quantum/quantum.c **** 
1160:quantum/quantum.c **** static const uint8_t backlight_pins[BACKLIGHT_LED_COUNT] = BACKLIGHT_PIN_INIT;
1161:quantum/quantum.c **** 
1162:quantum/quantum.c **** #else // full hardware PWM
1163:quantum/quantum.c **** 
1164:quantum/quantum.c **** // we support only one backlight pin
1165:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
1166:quantum/quantum.c **** #define FOR_EACH_LED(x) x
1167:quantum/quantum.c **** 
1168:quantum/quantum.c **** #endif
1169:quantum/quantum.c **** 
1170:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM
1171:quantum/quantum.c **** __attribute__((weak))
1172:quantum/quantum.c **** void backlight_init_ports(void)
1173:quantum/quantum.c **** {
1174:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1175:quantum/quantum.c ****   FOR_EACH_LED(
1176:quantum/quantum.c ****     setPinOutput(backlight_pin);
1177:quantum/quantum.c ****     backlight_on(backlight_pin);
1178:quantum/quantum.c ****   )
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** __attribute__ ((weak))
1182:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1183:quantum/quantum.c **** 
1184:quantum/quantum.c **** uint8_t backlight_tick = 0;
1185:quantum/quantum.c **** 
1186:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
1187:quantum/quantum.c **** void backlight_task(void) {
1188:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
1189:quantum/quantum.c ****     FOR_EACH_LED(
1190:quantum/quantum.c ****       backlight_on(backlight_pin);
1191:quantum/quantum.c ****     )
1192:quantum/quantum.c ****   }
1193:quantum/quantum.c ****   else {
1194:quantum/quantum.c ****     FOR_EACH_LED(
1195:quantum/quantum.c ****       backlight_off(backlight_pin);
1196:quantum/quantum.c ****     )
1197:quantum/quantum.c ****   }
1198:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
1199:quantum/quantum.c **** }
1200:quantum/quantum.c **** #endif
1201:quantum/quantum.c **** 
1202:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1203:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
1204:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
1205:quantum/quantum.c ****   #endif
1206:quantum/quantum.c **** #endif
1207:quantum/quantum.c **** 
1208:quantum/quantum.c **** #else // hardware pwm through timer
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** #ifdef BACKLIGHT_PWM_TIMER
1211:quantum/quantum.c **** 
1212:quantum/quantum.c **** // The idea of software PWM assisted by hardware timers is the following
1213:quantum/quantum.c **** // we use the hardware timer in fast PWM mode like for hardware PWM, but
1214:quantum/quantum.c **** // instead of letting the Output Match Comparator control the led pin
1215:quantum/quantum.c **** // (which is not possible since the backlight is not wired to PWM pins on the
1216:quantum/quantum.c **** // CPU), we do the LED on/off by oursleves.
1217:quantum/quantum.c **** // The timer is setup to count up to 0xFFFF, and we set the Output Compare
1218:quantum/quantum.c **** // register to the current 16bits backlight level (after CIE correction).
1219:quantum/quantum.c **** // This means the CPU will trigger a compare match interrupt when the counter
1220:quantum/quantum.c **** // reaches the backlight level, where we turn off the LEDs,
1221:quantum/quantum.c **** // but also an overflow interrupt when the counter rolls back to 0,
1222:quantum/quantum.c **** // in which we're going to turn on the LEDs.
1223:quantum/quantum.c **** // The LED will then be on for OCRxx/0xFFFF time, adjusted every 244Hz.
1224:quantum/quantum.c **** 
1225:quantum/quantum.c **** // Triggered when the counter reaches the OCRx value
1226:quantum/quantum.c **** ISR(TIMERx_COMPA_vect) {
1227:quantum/quantum.c ****   FOR_EACH_LED(
1228:quantum/quantum.c ****     backlight_off(backlight_pin);
1229:quantum/quantum.c ****   )
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** // Triggered when the counter reaches the TOP value
1233:quantum/quantum.c **** // this one triggers at F_CPU/65536 =~ 244 Hz
1234:quantum/quantum.c **** ISR(TIMERx_OVF_vect) {
1235:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1236:quantum/quantum.c ****   breathing_task();
1237:quantum/quantum.c **** #endif
1238:quantum/quantum.c ****   // for very small values of OCRxx (or backlight level)
1239:quantum/quantum.c ****   // we can't guarantee this whole code won't execute
1240:quantum/quantum.c ****   // at the same time as the compare match interrupt
1241:quantum/quantum.c ****   // which means that we might turn on the leds while
1242:quantum/quantum.c ****   // trying to turn them off, leading to flickering
1243:quantum/quantum.c ****   // artifacts (especially while breathing, because breathing_task
1244:quantum/quantum.c ****   // takes many computation cycles).
1245:quantum/quantum.c ****   // so better not turn them on while the counter TOP is very low.
1246:quantum/quantum.c ****   if (OCRxx > 256) {
1247:quantum/quantum.c ****     FOR_EACH_LED(
1248:quantum/quantum.c ****       backlight_on(backlight_pin);
1249:quantum/quantum.c ****     )
1250:quantum/quantum.c ****   }
1251:quantum/quantum.c **** }
1252:quantum/quantum.c **** 
1253:quantum/quantum.c **** #endif
1254:quantum/quantum.c **** 
1255:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
1256:quantum/quantum.c **** 
1257:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
1258:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
1259:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
1260:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
1261:quantum/quantum.c ****   else {
1262:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
1263:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
1264:quantum/quantum.c ****     // and revert what we've done again after squaring.
1265:quantum/quantum.c ****     y = y * y * y >> 8;
1266:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
1267:quantum/quantum.c ****       return 0xFFFFU;
1268:quantum/quantum.c ****     else
1269:quantum/quantum.c ****       return (uint16_t) y;
1270:quantum/quantum.c ****   }
1271:quantum/quantum.c **** }
1272:quantum/quantum.c **** 
1273:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
1274:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
1275:quantum/quantum.c **** 	OCRxx = val;
1276:quantum/quantum.c **** }
1277:quantum/quantum.c **** 
1278:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void backlight_set(uint8_t level) {
1281:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
1282:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
1283:quantum/quantum.c **** 
1284:quantum/quantum.c ****   if (level == 0) {
1285:quantum/quantum.c ****     #ifdef BACKLIGHT_PWM_TIMER
1286:quantum/quantum.c ****       if (OCRxx) {
1287:quantum/quantum.c ****         TIMSKx &= ~(_BV(OCIExA));
1288:quantum/quantum.c ****         TIMSKx &= ~(_BV(TOIEx));
1289:quantum/quantum.c ****         FOR_EACH_LED(
1290:quantum/quantum.c ****           backlight_off(backlight_pin);
1291:quantum/quantum.c ****         )
1292:quantum/quantum.c ****       }
1293:quantum/quantum.c ****     #else
1294:quantum/quantum.c ****     // Turn off PWM control on backlight pin
1295:quantum/quantum.c ****     TCCRxA &= ~(_BV(COMxx1));
1296:quantum/quantum.c ****     #endif
1297:quantum/quantum.c ****   } else {
1298:quantum/quantum.c ****     #ifdef BACKLIGHT_PWM_TIMER
1299:quantum/quantum.c ****       if (!OCRxx) {
1300:quantum/quantum.c ****         TIMSKx |= _BV(OCIExA);
1301:quantum/quantum.c ****         TIMSKx |= _BV(TOIEx);
1302:quantum/quantum.c ****       }
1303:quantum/quantum.c ****     #else
1304:quantum/quantum.c ****     // Turn on PWM control of backlight pin
1305:quantum/quantum.c ****     TCCRxA |= _BV(COMxx1);
1306:quantum/quantum.c ****     #endif
1307:quantum/quantum.c ****   }
1308:quantum/quantum.c ****   // Set the brightness
1309:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1310:quantum/quantum.c **** }
1311:quantum/quantum.c **** 
1312:quantum/quantum.c **** void backlight_task(void) {}
1313:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1314:quantum/quantum.c **** 
1315:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1316:quantum/quantum.c **** 
1317:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1318:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1319:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1320:quantum/quantum.c **** #define BREATHING_STEPS 128
1321:quantum/quantum.c **** 
1322:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1323:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1324:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1325:quantum/quantum.c **** 
1326:quantum/quantum.c **** #ifdef BACKLIGHT_PWM_TIMER
1327:quantum/quantum.c **** static bool breathing = false;
1328:quantum/quantum.c **** 
1329:quantum/quantum.c **** bool is_breathing(void) {
1330:quantum/quantum.c ****   return breathing;
1331:quantum/quantum.c **** }
1332:quantum/quantum.c **** 
1333:quantum/quantum.c **** #define breathing_interrupt_enable() do { breathing = true; } while (0)
1334:quantum/quantum.c **** #define breathing_interrupt_disable() do { breathing = false; } while (0)
1335:quantum/quantum.c **** #else
1336:quantum/quantum.c **** 
1337:quantum/quantum.c **** bool is_breathing(void) {
1338:quantum/quantum.c ****     return !!(TIMSKx & _BV(TOIEx));
1339:quantum/quantum.c **** }
1340:quantum/quantum.c **** 
1341:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSKx |= _BV(TOIEx);} while (0)
1342:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSKx &= ~_BV(TOIEx);} while (0)
1343:quantum/quantum.c **** #endif
1344:quantum/quantum.c **** 
1345:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1346:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1347:quantum/quantum.c **** 
1348:quantum/quantum.c **** void breathing_enable(void)
1349:quantum/quantum.c **** {
1350:quantum/quantum.c ****   breathing_counter = 0;
1351:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1352:quantum/quantum.c ****   breathing_interrupt_enable();
1353:quantum/quantum.c **** }
1354:quantum/quantum.c **** 
1355:quantum/quantum.c **** void breathing_pulse(void)
1356:quantum/quantum.c **** {
1357:quantum/quantum.c ****     if (get_backlight_level() == 0)
1358:quantum/quantum.c ****       breathing_min();
1359:quantum/quantum.c ****     else
1360:quantum/quantum.c ****       breathing_max();
1361:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1362:quantum/quantum.c ****     breathing_interrupt_enable();
1363:quantum/quantum.c **** }
1364:quantum/quantum.c **** 
1365:quantum/quantum.c **** void breathing_disable(void)
1366:quantum/quantum.c **** {
1367:quantum/quantum.c ****     breathing_interrupt_disable();
1368:quantum/quantum.c ****     // Restore backlight level
1369:quantum/quantum.c ****     backlight_set(get_backlight_level());
1370:quantum/quantum.c **** }
1371:quantum/quantum.c **** 
1372:quantum/quantum.c **** void breathing_self_disable(void)
1373:quantum/quantum.c **** {
1374:quantum/quantum.c ****   if (get_backlight_level() == 0)
1375:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1376:quantum/quantum.c ****   else
1377:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1378:quantum/quantum.c **** }
1379:quantum/quantum.c **** 
1380:quantum/quantum.c **** void breathing_toggle(void) {
1381:quantum/quantum.c ****   if (is_breathing())
1382:quantum/quantum.c ****     breathing_disable();
1383:quantum/quantum.c ****   else
1384:quantum/quantum.c ****     breathing_enable();
1385:quantum/quantum.c **** }
1386:quantum/quantum.c **** 
1387:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1388:quantum/quantum.c **** {
1389:quantum/quantum.c ****   if (!value)
1390:quantum/quantum.c ****     value = 1;
1391:quantum/quantum.c ****   breathing_period = value;
1392:quantum/quantum.c **** }
1393:quantum/quantum.c **** 
1394:quantum/quantum.c **** void breathing_period_default(void) {
1395:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1396:quantum/quantum.c **** }
1397:quantum/quantum.c **** 
1398:quantum/quantum.c **** void breathing_period_inc(void)
1399:quantum/quantum.c **** {
1400:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1401:quantum/quantum.c **** }
1402:quantum/quantum.c **** 
1403:quantum/quantum.c **** void breathing_period_dec(void)
1404:quantum/quantum.c **** {
1405:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1406:quantum/quantum.c **** }
1407:quantum/quantum.c **** 
1408:quantum/quantum.c **** /* To generate breathing curve in python:
1409:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1410:quantum/quantum.c ****  */
1411:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1412:quantum/quantum.c **** 
1413:quantum/quantum.c **** // Use this before the cie_lightness function.
1414:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1415:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1416:quantum/quantum.c **** }
1417:quantum/quantum.c **** 
1418:quantum/quantum.c **** #ifdef BACKLIGHT_PWM_TIMER
1419:quantum/quantum.c **** void breathing_task(void)
1420:quantum/quantum.c **** #else
1421:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1422:quantum/quantum.c ****  * about 244 times per second.
1423:quantum/quantum.c ****  */
1424:quantum/quantum.c **** ISR(TIMERx_OVF_vect)
1425:quantum/quantum.c **** #endif
1426:quantum/quantum.c **** {
1427:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1428:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1429:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1430:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1431:quantum/quantum.c **** 
1432:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1433:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1434:quantum/quantum.c ****   {
1435:quantum/quantum.c ****       breathing_interrupt_disable();
1436:quantum/quantum.c ****   }
1437:quantum/quantum.c **** 
1438:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1439:quantum/quantum.c **** }
1440:quantum/quantum.c **** 
1441:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1442:quantum/quantum.c **** 
1443:quantum/quantum.c **** __attribute__ ((weak))
1444:quantum/quantum.c **** void backlight_init_ports(void)
1445:quantum/quantum.c **** {
1446:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1447:quantum/quantum.c ****   FOR_EACH_LED(
1448:quantum/quantum.c ****     setPinOutput(backlight_pin);
1449:quantum/quantum.c ****     backlight_on(backlight_pin);
1450:quantum/quantum.c ****   )
1451:quantum/quantum.c **** 
1452:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1453:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1454:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1455:quantum/quantum.c **** 
1456:quantum/quantum.c **** #ifdef BACKLIGHT_PWM_TIMER
1457:quantum/quantum.c ****   // TimerX setup, Fast PWM mode count to TOP set in ICRx
1458:quantum/quantum.c ****   TCCRxA = _BV(WGM11); // = 0b00000010;
1459:quantum/quantum.c ****   // clock select clk/1
1460:quantum/quantum.c ****   TCCRxB = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1461:quantum/quantum.c **** #else // hardware PWM
1462:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1463:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1464:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1465:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1466:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1467:quantum/quantum.c **** 
1468:quantum/quantum.c ****   /*
1469:quantum/quantum.c ****   14.8.3:
1470:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1471:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1472:quantum/quantum.c ****   */
1473:quantum/quantum.c ****   TCCRxA = _BV(COMxx1) | _BV(WGM11);            // = 0b00001010;
1474:quantum/quantum.c ****   TCCRxB = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1475:quantum/quantum.c **** #endif
1476:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1477:quantum/quantum.c ****   ICRx = TIMER_TOP;
1478:quantum/quantum.c **** 
1479:quantum/quantum.c ****   backlight_init();
1480:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1481:quantum/quantum.c ****     breathing_enable();
1482:quantum/quantum.c ****   #endif
1483:quantum/quantum.c **** }
1484:quantum/quantum.c **** 
1485:quantum/quantum.c **** #endif // hardware backlight
1486:quantum/quantum.c **** 
1487:quantum/quantum.c **** #else // no backlight
1488:quantum/quantum.c **** 
1489:quantum/quantum.c **** __attribute__ ((weak))
1490:quantum/quantum.c **** void backlight_init_ports(void) {}
1491:quantum/quantum.c **** 
1492:quantum/quantum.c **** __attribute__ ((weak))
1493:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1494:quantum/quantum.c **** 
1495:quantum/quantum.c **** #endif // backlight
1496:quantum/quantum.c **** 
1497:quantum/quantum.c **** #ifdef HD44780_ENABLED
1498:quantum/quantum.c **** #include "hd44780.h"
1499:quantum/quantum.c **** #endif
1500:quantum/quantum.c **** 
1501:quantum/quantum.c **** 
1502:quantum/quantum.c **** // Functions for spitting out values
1503:quantum/quantum.c **** //
1504:quantum/quantum.c **** 
1505:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1506:quantum/quantum.c ****     uint16_t word = (number >> 16);
1507:quantum/quantum.c ****     send_word(word);
1508:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1509:quantum/quantum.c **** }
1510:quantum/quantum.c **** 
1511:quantum/quantum.c **** void send_word(uint16_t number) {
1512:quantum/quantum.c ****     uint8_t byte = number >> 8;
1513:quantum/quantum.c ****     send_byte(byte);
1514:quantum/quantum.c ****     send_byte(number & 0xFF);
1515:quantum/quantum.c **** }
1516:quantum/quantum.c **** 
1517:quantum/quantum.c **** void send_byte(uint8_t number) {
1518:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1519:quantum/quantum.c ****     send_nibble(nibble);
1520:quantum/quantum.c ****     send_nibble(number & 0xF);
1521:quantum/quantum.c **** }
1522:quantum/quantum.c **** 
1523:quantum/quantum.c **** void send_nibble(uint8_t number) {
 1679               		.loc 1 1523 0
 1680               		.cfi_startproc
 1681               	.LVL180:
 1682               		.loc 1 1523 0
 1683 0000 CF93      		push r28
 1684               	.LCFI43:
 1685               		.cfi_def_cfa_offset 3
 1686               		.cfi_offset 28, -2
 1687               	/* prologue: function */
 1688               	/* frame size = 0 */
 1689               	/* stack size = 1 */
 1690               	.L__stack_usage = 1
1524:quantum/quantum.c ****     switch (number) {
 1691               		.loc 1 1524 0
 1692 0002 8A30      		cpi r24,lo8(10)
 1693 0004 00F4      		brsh .L117
 1694 0006 8130      		cpi r24,lo8(1)
 1695 0008 00F0      		brlo .L121
1525:quantum/quantum.c ****         case 0:
1526:quantum/quantum.c ****             register_code(KC_0);
1527:quantum/quantum.c ****             unregister_code(KC_0);
1528:quantum/quantum.c ****             break;
1529:quantum/quantum.c ****         case 1 ... 9:
1530:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
 1696               		.loc 1 1530 0
 1697 000a CDE1      		ldi r28,lo8(29)
 1698               	.L124:
1531:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1532:quantum/quantum.c ****             break;
1533:quantum/quantum.c ****         case 0xA ... 0xF:
1534:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 1699               		.loc 1 1534 0
 1700 000c C80F      		add r28,r24
 1701 000e 8C2F      		mov r24,r28
 1702               	.LVL181:
 1703 0010 0E94 0000 		call register_code
 1704               	.LVL182:
1535:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1705               		.loc 1 1535 0
 1706 0014 8C2F      		mov r24,r28
 1707 0016 00C0      		rjmp .L123
 1708               	.LVL183:
 1709               	.L117:
1534:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1710               		.loc 1 1534 0
 1711 0018 CAEF      		ldi r28,lo8(-6)
1524:quantum/quantum.c ****         case 0:
 1712               		.loc 1 1524 0
 1713 001a 8031      		cpi r24,lo8(16)
 1714 001c 00F0      		brlo .L124
 1715               	/* epilogue start */
1536:quantum/quantum.c ****             break;
1537:quantum/quantum.c ****     }
1538:quantum/quantum.c **** }
 1716               		.loc 1 1538 0
 1717 001e CF91      		pop r28
 1718 0020 0895      		ret
 1719               	.L121:
1526:quantum/quantum.c ****             unregister_code(KC_0);
 1720               		.loc 1 1526 0
 1721 0022 87E2      		ldi r24,lo8(39)
 1722               	.LVL184:
 1723 0024 0E94 0000 		call register_code
 1724               	.LVL185:
1527:quantum/quantum.c ****             break;
 1725               		.loc 1 1527 0
 1726 0028 87E2      		ldi r24,lo8(39)
 1727               	.L123:
 1728               	/* epilogue start */
 1729               		.loc 1 1538 0
 1730 002a CF91      		pop r28
1535:quantum/quantum.c ****             break;
 1731               		.loc 1 1535 0
 1732 002c 0C94 0000 		jmp unregister_code
 1733               	.LVL186:
 1734               		.cfi_endproc
 1735               	.LFE61:
 1737               		.section	.text.send_byte,"ax",@progbits
 1738               	.global	send_byte
 1740               	send_byte:
 1741               	.LFB60:
1517:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 1742               		.loc 1 1517 0
 1743               		.cfi_startproc
 1744               	.LVL187:
 1745 0000 CF93      		push r28
 1746               	.LCFI44:
 1747               		.cfi_def_cfa_offset 3
 1748               		.cfi_offset 28, -2
 1749               	/* prologue: function */
 1750               	/* frame size = 0 */
 1751               	/* stack size = 1 */
 1752               	.L__stack_usage = 1
 1753 0002 C82F      		mov r28,r24
 1754               	.LVL188:
1519:quantum/quantum.c ****     send_nibble(number & 0xF);
 1755               		.loc 1 1519 0
 1756 0004 8295      		swap r24
 1757               	.LVL189:
 1758 0006 8F70      		andi r24,lo8(15)
 1759 0008 0E94 0000 		call send_nibble
 1760               	.LVL190:
1520:quantum/quantum.c **** }
 1761               		.loc 1 1520 0
 1762 000c 8C2F      		mov r24,r28
 1763 000e 8F70      		andi r24,lo8(15)
 1764               	/* epilogue start */
1521:quantum/quantum.c **** 
 1765               		.loc 1 1521 0
 1766 0010 CF91      		pop r28
 1767               	.LVL191:
1520:quantum/quantum.c **** }
 1768               		.loc 1 1520 0
 1769 0012 0C94 0000 		jmp send_nibble
 1770               	.LVL192:
 1771               		.cfi_endproc
 1772               	.LFE60:
 1774               		.section	.text.send_word,"ax",@progbits
 1775               	.global	send_word
 1777               	send_word:
 1778               	.LFB59:
1511:quantum/quantum.c ****     uint8_t byte = number >> 8;
 1779               		.loc 1 1511 0
 1780               		.cfi_startproc
 1781               	.LVL193:
 1782 0000 CF93      		push r28
 1783               	.LCFI45:
 1784               		.cfi_def_cfa_offset 3
 1785               		.cfi_offset 28, -2
 1786               	/* prologue: function */
 1787               	/* frame size = 0 */
 1788               	/* stack size = 1 */
 1789               	.L__stack_usage = 1
 1790 0002 C82F      		mov r28,r24
 1791               	.LVL194:
1513:quantum/quantum.c ****     send_byte(number & 0xFF);
 1792               		.loc 1 1513 0
 1793 0004 892F      		mov r24,r25
 1794               	.LVL195:
 1795 0006 0E94 0000 		call send_byte
 1796               	.LVL196:
1514:quantum/quantum.c **** }
 1797               		.loc 1 1514 0
 1798 000a 8C2F      		mov r24,r28
 1799               	/* epilogue start */
1515:quantum/quantum.c **** 
 1800               		.loc 1 1515 0
 1801 000c CF91      		pop r28
1514:quantum/quantum.c **** }
 1802               		.loc 1 1514 0
 1803 000e 0C94 0000 		jmp send_byte
 1804               	.LVL197:
 1805               		.cfi_endproc
 1806               	.LFE59:
 1808               		.section	.text.send_dword,"ax",@progbits
 1809               	.global	send_dword
 1811               	send_dword:
 1812               	.LFB58:
1505:quantum/quantum.c ****     uint16_t word = (number >> 16);
 1813               		.loc 1 1505 0
 1814               		.cfi_startproc
 1815               	.LVL198:
 1816 0000 CF92      		push r12
 1817               	.LCFI46:
 1818               		.cfi_def_cfa_offset 3
 1819               		.cfi_offset 12, -2
 1820 0002 DF92      		push r13
 1821               	.LCFI47:
 1822               		.cfi_def_cfa_offset 4
 1823               		.cfi_offset 13, -3
 1824 0004 EF92      		push r14
 1825               	.LCFI48:
 1826               		.cfi_def_cfa_offset 5
 1827               		.cfi_offset 14, -4
 1828 0006 FF92      		push r15
 1829               	.LCFI49:
 1830               		.cfi_def_cfa_offset 6
 1831               		.cfi_offset 15, -5
 1832               	/* prologue: function */
 1833               	/* frame size = 0 */
 1834               	/* stack size = 4 */
 1835               	.L__stack_usage = 4
 1836 0008 6B01      		movw r12,r22
1507:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 1837               		.loc 1 1507 0
 1838 000a 0E94 0000 		call send_word
 1839               	.LVL199:
1508:quantum/quantum.c **** }
 1840               		.loc 1 1508 0
 1841 000e C601      		movw r24,r12
 1842               	/* epilogue start */
1509:quantum/quantum.c **** 
 1843               		.loc 1 1509 0
 1844 0010 FF90      		pop r15
 1845 0012 EF90      		pop r14
 1846 0014 DF90      		pop r13
 1847 0016 CF90      		pop r12
1508:quantum/quantum.c **** }
 1848               		.loc 1 1508 0
 1849 0018 0C94 0000 		jmp send_word
 1850               	.LVL200:
 1851               		.cfi_endproc
 1852               	.LFE58:
 1854               		.section	.text.hex_to_keycode,"ax",@progbits
 1855               		.weak	hex_to_keycode
 1857               	hex_to_keycode:
 1858               	.LFB62:
1539:quantum/quantum.c **** 
1540:quantum/quantum.c **** 
1541:quantum/quantum.c **** __attribute__((weak))
1542:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1543:quantum/quantum.c **** {
 1859               		.loc 1 1543 0
 1860               		.cfi_startproc
 1861               	.LVL201:
 1862               	/* prologue: function */
 1863               	/* frame size = 0 */
 1864               	/* stack size = 0 */
 1865               	.L__stack_usage = 0
1544:quantum/quantum.c ****   hex = hex & 0xF;
 1866               		.loc 1 1544 0
 1867 0000 282F      		mov r18,r24
 1868 0002 2F70      		andi r18,lo8(15)
 1869               	.LVL202:
1545:quantum/quantum.c ****   if (hex == 0x0) {
 1870               		.loc 1 1545 0
 1871 0004 01F0      		breq .L131
 1872 0006 822F      		mov r24,r18
 1873 0008 90E0      		ldi r25,0
1546:quantum/quantum.c ****     return KC_0;
1547:quantum/quantum.c ****   } else if (hex < 0xA) {
 1874               		.loc 1 1547 0
 1875 000a 2A30      		cpi r18,lo8(10)
 1876 000c 00F4      		brsh .L130
1548:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 1877               		.loc 1 1548 0
 1878 000e 4D96      		adiw r24,29
 1879 0010 0895      		ret
 1880               	.L130:
1549:quantum/quantum.c ****   } else {
1550:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 1881               		.loc 1 1550 0
 1882 0012 0697      		sbiw r24,6
 1883 0014 0895      		ret
 1884               	.L131:
1546:quantum/quantum.c ****   } else if (hex < 0xA) {
 1885               		.loc 1 1546 0
 1886 0016 87E2      		ldi r24,lo8(39)
 1887 0018 90E0      		ldi r25,0
 1888               	/* epilogue start */
1551:quantum/quantum.c ****   }
1552:quantum/quantum.c **** }
 1889               		.loc 1 1552 0
 1890 001a 0895      		ret
 1891               		.cfi_endproc
 1892               	.LFE62:
 1894               		.section	.text.api_send_unicode,"ax",@progbits
 1895               	.global	api_send_unicode
 1897               	api_send_unicode:
 1898               	.LFB63:
1553:quantum/quantum.c **** 
1554:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1899               		.loc 1 1554 0
 1900               		.cfi_startproc
 1901               	.LVL203:
 1902               	/* prologue: function */
 1903               	/* frame size = 0 */
 1904               	/* stack size = 0 */
 1905               	.L__stack_usage = 0
 1906               	/* epilogue start */
1555:quantum/quantum.c **** #ifdef API_ENABLE
1556:quantum/quantum.c ****     uint8_t chunk[4];
1557:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1558:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1559:quantum/quantum.c **** #endif
1560:quantum/quantum.c **** }
 1907               		.loc 1 1560 0
 1908 0000 0895      		ret
 1909               		.cfi_endproc
 1910               	.LFE63:
 1912               		.section	.text.led_set_user,"ax",@progbits
 1913               		.weak	led_set_user
 1915               	led_set_user:
 1916               	.LFB64:
1561:quantum/quantum.c **** 
1562:quantum/quantum.c **** __attribute__ ((weak))
1563:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 1917               		.loc 1 1563 0
 1918               		.cfi_startproc
 1919               	.LVL204:
 1920               	/* prologue: function */
 1921               	/* frame size = 0 */
 1922               	/* stack size = 0 */
 1923               	.L__stack_usage = 0
 1924               	/* epilogue start */
1564:quantum/quantum.c **** 
1565:quantum/quantum.c **** }
 1925               		.loc 1 1565 0
 1926 0000 0895      		ret
 1927               		.cfi_endproc
 1928               	.LFE64:
 1930               		.set	led_set_user.localalias.1,led_set_user
 1931               		.section	.text.backlight_set,"ax",@progbits
 1932               		.weak	backlight_set
 1934               	backlight_set:
 1935               	.LFB99:
 1936               		.cfi_startproc
 1937               	/* prologue: function */
 1938               	/* frame size = 0 */
 1939               	/* stack size = 0 */
 1940               	.L__stack_usage = 0
 1941               	/* epilogue start */
 1942 0000 0895      		ret
 1943               		.cfi_endproc
 1944               	.LFE99:
 1946               		.section	.text.led_set_kb,"ax",@progbits
 1947               		.weak	led_set_kb
 1949               	led_set_kb:
 1950               	.LFB65:
1566:quantum/quantum.c **** 
1567:quantum/quantum.c **** __attribute__ ((weak))
1568:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 1951               		.loc 1 1568 0
 1952               		.cfi_startproc
 1953               	.LVL205:
 1954               	/* prologue: function */
 1955               	/* frame size = 0 */
 1956               	/* stack size = 0 */
 1957               	.L__stack_usage = 0
1569:quantum/quantum.c ****     led_set_user(usb_led);
 1958               		.loc 1 1569 0
 1959 0000 0C94 0000 		jmp led_set_user
 1960               	.LVL206:
 1961               		.cfi_endproc
 1962               	.LFE65:
 1964               		.section	.text.led_init_ports,"ax",@progbits
 1965               		.weak	led_init_ports
 1967               	led_init_ports:
 1968               	.LFB66:
1570:quantum/quantum.c **** }
1571:quantum/quantum.c **** 
1572:quantum/quantum.c **** __attribute__ ((weak))
1573:quantum/quantum.c **** void led_init_ports(void)
1574:quantum/quantum.c **** {
 1969               		.loc 1 1574 0
 1970               		.cfi_startproc
 1971               	/* prologue: function */
 1972               	/* frame size = 0 */
 1973               	/* stack size = 0 */
 1974               	.L__stack_usage = 0
 1975               	/* epilogue start */
1575:quantum/quantum.c **** 
1576:quantum/quantum.c **** }
 1976               		.loc 1 1576 0
 1977 0000 0895      		ret
 1978               		.cfi_endproc
 1979               	.LFE66:
 1981               		.section	.text.led_set,"ax",@progbits
 1982               		.weak	led_set
 1984               	led_set:
 1985               	.LFB67:
1577:quantum/quantum.c **** 
1578:quantum/quantum.c **** __attribute__ ((weak))
1579:quantum/quantum.c **** void led_set(uint8_t usb_led)
1580:quantum/quantum.c **** {
 1986               		.loc 1 1580 0
 1987               		.cfi_startproc
 1988               	.LVL207:
 1989               	/* prologue: function */
 1990               	/* frame size = 0 */
 1991               	/* stack size = 0 */
 1992               	.L__stack_usage = 0
1581:quantum/quantum.c **** 
1582:quantum/quantum.c ****   // Example LED Code
1583:quantum/quantum.c ****   //
1584:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1585:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1586:quantum/quantum.c ****     // {
1587:quantum/quantum.c ****     //     // Output high.
1588:quantum/quantum.c ****     //     DDRE |= (1<<6);
1589:quantum/quantum.c ****     //     PORTE |= (1<<6);
1590:quantum/quantum.c ****     // }
1591:quantum/quantum.c ****     // else
1592:quantum/quantum.c ****     // {
1593:quantum/quantum.c ****     //     // Output low.
1594:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1595:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1596:quantum/quantum.c ****     // }
1597:quantum/quantum.c **** 
1598:quantum/quantum.c **** #if defined(BACKLIGHT_CAPS_LOCK) && defined(BACKLIGHT_ENABLE)
1599:quantum/quantum.c ****   // Use backlight as Caps Lock indicator
1600:quantum/quantum.c ****   uint8_t bl_toggle_lvl = 0;
1601:quantum/quantum.c **** 
1602:quantum/quantum.c ****   if (IS_LED_ON(usb_led, USB_LED_CAPS_LOCK) && !backlight_config.enable) {
1603:quantum/quantum.c ****     // Turning Caps Lock ON and backlight is disabled in config
1604:quantum/quantum.c ****     // Toggling backlight to the brightest level
1605:quantum/quantum.c ****     bl_toggle_lvl = BACKLIGHT_LEVELS;
1606:quantum/quantum.c ****   } else if (IS_LED_OFF(usb_led, USB_LED_CAPS_LOCK) && backlight_config.enable) {
1607:quantum/quantum.c ****     // Turning Caps Lock OFF and backlight is enabled in config
1608:quantum/quantum.c ****     // Toggling backlight and restoring config level
1609:quantum/quantum.c ****     bl_toggle_lvl = backlight_config.level;
1610:quantum/quantum.c ****   }
1611:quantum/quantum.c **** 
1612:quantum/quantum.c ****   // Set level without modify backlight_config to keep ability to restore state
1613:quantum/quantum.c ****   backlight_set(bl_toggle_lvl);
1614:quantum/quantum.c **** #endif
1615:quantum/quantum.c **** 
1616:quantum/quantum.c ****   led_set_kb(usb_led);
 1993               		.loc 1 1616 0
 1994 0000 0C94 0000 		jmp led_set_kb
 1995               	.LVL208:
 1996               		.cfi_endproc
 1997               	.LFE67:
 1999               		.section	.text.startup_user,"ax",@progbits
 2000               		.weak	startup_user
 2002               	startup_user:
 2003               	.LFB71:
 2004               		.cfi_startproc
 2005               	/* prologue: function */
 2006               	/* frame size = 0 */
 2007               	/* stack size = 0 */
 2008               	.L__stack_usage = 0
 2009               	/* epilogue start */
 2010 0000 0895      		ret
 2011               		.cfi_endproc
 2012               	.LFE71:
 2014               		.section	.text.shutdown_user,"ax",@progbits
 2015               		.weak	shutdown_user
 2017               	shutdown_user:
 2018               	.LFB73:
 2019               		.cfi_startproc
 2020               	/* prologue: function */
 2021               	/* frame size = 0 */
 2022               	/* stack size = 0 */
 2023               	.L__stack_usage = 0
 2024               	/* epilogue start */
 2025 0000 0895      		ret
 2026               		.cfi_endproc
 2027               	.LFE73:
 2029               		.section	.text.reset_keyboard,"ax",@progbits
 2030               	.global	reset_keyboard
 2032               	reset_keyboard:
 2033               	.LFB40:
 166:quantum/quantum.c ****   clear_keyboard();
 2034               		.loc 1 166 0
 2035               		.cfi_startproc
 2036               	/* prologue: function */
 2037               	/* frame size = 0 */
 2038               	/* stack size = 0 */
 2039               	.L__stack_usage = 0
 167:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 2040               		.loc 1 167 0
 2041 0000 0E94 0000 		call clear_keyboard
 2042               	.LVL209:
 182:quantum/quantum.c ****   wait_ms(250);
 2043               		.loc 1 182 0
 2044 0004 0E94 0000 		call shutdown_user
 2045               	.LVL210:
 2046               	.LBB51:
 2047               	.LBB52:
 2048               		.loc 2 187 0
 2049 0008 2FEF      		ldi r18,lo8(799999)
 2050 000a 84E3      		ldi r24,hi8(799999)
 2051 000c 9CE0      		ldi r25,hlo8(799999)
 2052 000e 2150      	1:	subi r18,1
 2053 0010 8040      		sbci r24,0
 2054 0012 9040      		sbci r25,0
 2055 0014 01F4      		brne 1b
 2056 0016 00C0      		rjmp .
 2057 0018 0000      		nop
 2058               	.LVL211:
 2059               	.LBE52:
 2060               	.LBE51:
 192:quantum/quantum.c **** }
 2061               		.loc 1 192 0
 2062 001a 0C94 0000 		jmp bootloader_jump
 2063               	.LVL212:
 2064               		.cfi_endproc
 2065               	.LFE40:
 2067               		.section	.text.process_record_quantum,"ax",@progbits
 2068               	.global	process_record_quantum
 2070               	process_record_quantum:
 2071               	.LFB43:
 231:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record);
 2072               		.loc 1 231 0
 2073               		.cfi_startproc
 2074               	.LVL213:
 2075 0000 0F93      		push r16
 2076               	.LCFI50:
 2077               		.cfi_def_cfa_offset 3
 2078               		.cfi_offset 16, -2
 2079 0002 1F93      		push r17
 2080               	.LCFI51:
 2081               		.cfi_def_cfa_offset 4
 2082               		.cfi_offset 17, -3
 2083 0004 CF93      		push r28
 2084               	.LCFI52:
 2085               		.cfi_def_cfa_offset 5
 2086               		.cfi_offset 28, -4
 2087 0006 DF93      		push r29
 2088               	.LCFI53:
 2089               		.cfi_def_cfa_offset 6
 2090               		.cfi_offset 29, -5
 2091               	/* prologue: function */
 2092               	/* frame size = 0 */
 2093               	/* stack size = 4 */
 2094               	.L__stack_usage = 4
 2095 0008 8C01      		movw r16,r24
 232:quantum/quantum.c **** 
 2096               		.loc 1 232 0
 2097 000a 0E94 0000 		call get_record_keycode
 2098               	.LVL214:
 2099 000e EC01      		movw r28,r24
 2100               	.LVL215:
 264:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 2101               		.loc 1 264 0
 2102 0010 B801      		movw r22,r16
 2103 0012 0E94 0000 		call process_record_kb
 2104               	.LVL216:
 2105 0016 8823      		tst r24
 2106 0018 01F4      		brne .+2
 2107 001a 00C0      		rjmp .L141
 299:quantum/quantum.c ****   #endif
 2108               		.loc 1 299 0 discriminator 2
 2109 001c B801      		movw r22,r16
 2110 001e CE01      		movw r24,r28
 2111 0020 0E94 0000 		call process_space_cadet
 2112               	.LVL217:
 264:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 2113               		.loc 1 264 0 discriminator 2
 2114 0024 8823      		tst r24
 2115 0026 01F4      		brne .+2
 2116 0028 00C0      		rjmp .L141
 307:quantum/quantum.c ****     case RESET:
 2117               		.loc 1 307 0
 2118 002a C531      		cpi r28,21
 2119 002c 8CE5      		ldi r24,92
 2120 002e D807      		cpc r29,r24
 2121 0030 00F4      		brsh .L146
 2122 0032 C230      		cpi r28,2
 2123 0034 ECE5      		ldi r30,92
 2124 0036 DE07      		cpc r29,r30
 2125 0038 00F0      		brlo .+2
 2126 003a 00C0      		rjmp .L147
 2127 003c C115      		cp r28,__zero_reg__
 2128 003e FCE5      		ldi r31,92
 2129 0040 DF07      		cpc r29,r31
 2130 0042 01F0      		breq .L148
 2131 0044 C130      		cpi r28,1
 2132 0046 DC45      		sbci r29,92
 2133 0048 01F4      		brne .+2
 2134 004a 00C0      		rjmp .L149
 2135               	.L145:
 717:quantum/quantum.c **** }
 2136               		.loc 1 717 0
 2137 004c C801      		movw r24,r16
 2138               	/* epilogue start */
 718:quantum/quantum.c **** 
 2139               		.loc 1 718 0
 2140 004e DF91      		pop r29
 2141 0050 CF91      		pop r28
 2142               	.LVL218:
 2143 0052 1F91      		pop r17
 2144 0054 0F91      		pop r16
 2145               	.LVL219:
 717:quantum/quantum.c **** }
 2146               		.loc 1 717 0
 2147 0056 0C94 0000 		jmp process_action_kb
 2148               	.LVL220:
 2149               	.L146:
 307:quantum/quantum.c ****     case RESET:
 2150               		.loc 1 307 0
 2151 005a CC3D      		cpi r28,-36
 2152 005c ECE5      		ldi r30,92
 2153 005e DE07      		cpc r29,r30
 2154 0060 01F4      		brne .+2
 2155 0062 00C0      		rjmp .L150
 2156 0064 00F4      		brsh .L151
 2157 0066 C631      		cpi r28,22
 2158 0068 DC45      		sbci r29,92
 2159 006a 01F4      		brne .L145
 2160               	.LBB53:
 663:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 2161               		.loc 1 663 0
 2162 006c 0E94 0000 		call get_mods
 2163               	.LVL221:
 696:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 2164               		.loc 1 696 0
 2165 0070 F801      		movw r30,r16
 2166 0072 9281      		ldd r25,Z+2
 2167 0074 9923      		tst r25
 2168 0076 01F4      		brne .+2
 2169 0078 00C0      		rjmp .L178
 663:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 2170               		.loc 1 663 0
 2171 007a 8A7A      		andi r24,lo8(-86)
 2172               	.LVL222:
 697:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 2173               		.loc 1 697 0
 2174 007c 91E0      		ldi r25,lo8(1)
 2175 007e 01F4      		brne .L179
 2176 0080 90E0      		ldi r25,0
 2177               	.L179:
 2178 0082 9093 0000 		sts grave_esc_was_shifted,r25
 698:quantum/quantum.c ****       }
 2179               		.loc 1 698 0
 2180 0086 8111      		cpse r24,__zero_reg__
 2181 0088 00C0      		rjmp .L183
 2182 008a 89E2      		ldi r24,lo8(41)
 2183               	.LVL223:
 2184               	.L180:
 698:quantum/quantum.c ****       }
 2185               		.loc 1 698 0 is_stmt 0 discriminator 4
 2186 008c 0E94 0000 		call add_key
 2187               	.LVL224:
 2188               	.L181:
 704:quantum/quantum.c ****       return false;
 2189               		.loc 1 704 0 is_stmt 1
 2190 0090 0E94 0000 		call send_keyboard_report
 2191               	.LVL225:
 705:quantum/quantum.c ****     }
 2192               		.loc 1 705 0
 2193 0094 00C0      		rjmp .L141
 2194               	.L151:
 2195               	.LBE53:
 307:quantum/quantum.c ****     case RESET:
 2196               		.loc 1 307 0
 2197 0096 CD3D      		cpi r28,-35
 2198 0098 ECE5      		ldi r30,92
 2199 009a DE07      		cpc r29,r30
 2200 009c 01F0      		breq .L153
 2201 009e CE3D      		cpi r28,-34
 2202 00a0 DC45      		sbci r29,92
 2203 00a2 01F4      		brne .L145
 324:quantum/quantum.c ****           eeconfig_init();
 2204               		.loc 1 324 0
 2205 00a4 F801      		movw r30,r16
 2206 00a6 8281      		ldd r24,Z+2
 2207 00a8 8823      		tst r24
 2208 00aa 01F0      		breq .L141
 325:quantum/quantum.c ****       }
 2209               		.loc 1 325 0
 2210 00ac 0E94 0000 		call eeconfig_init
 2211               	.LVL226:
 2212 00b0 00C0      		rjmp .L141
 2213               	.L148:
 309:quantum/quantum.c ****         reset_keyboard();
 2214               		.loc 1 309 0
 2215 00b2 F801      		movw r30,r16
 2216 00b4 8281      		ldd r24,Z+2
 2217 00b6 8111      		cpse r24,__zero_reg__
 310:quantum/quantum.c ****       }
 2218               		.loc 1 310 0
 2219 00b8 0E94 0000 		call reset_keyboard
 2220               	.LVL227:
 2221               	.L141:
 718:quantum/quantum.c **** 
 2222               		.loc 1 718 0
 2223 00bc 80E0      		ldi r24,0
 2224               	/* epilogue start */
 2225 00be DF91      		pop r29
 2226 00c0 CF91      		pop r28
 2227               	.LVL228:
 2228 00c2 1F91      		pop r17
 2229 00c4 0F91      		pop r16
 2230               	.LVL229:
 2231 00c6 0895      		ret
 2232               	.LVL230:
 2233               	.L149:
 314:quantum/quantum.c ****         debug_enable ^= 1;
 2234               		.loc 1 314 0
 2235 00c8 F801      		movw r30,r16
 2236 00ca 8281      		ldd r24,Z+2
 2237 00cc 8823      		tst r24
 2238 00ce 01F0      		breq .L141
 315:quantum/quantum.c ****         if (debug_enable) {
 2239               		.loc 1 315 0
 2240 00d0 9091 0000 		lds r25,debug_config
 2241 00d4 892F      		mov r24,r25
 2242 00d6 8E7F      		andi r24,~(1<<0)
 2243 00d8 90FF      		sbrs r25,0
 2244 00da 8160      		ori r24,1<<0
 2245 00dc 8093 0000 		sts debug_config,r24
 316:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 2246               		.loc 1 316 0
 2247 00e0 80FF      		sbrs r24,0
 2248 00e2 00C0      		rjmp .L155
 317:quantum/quantum.c ****         } else {
 2249               		.loc 1 317 0
 2250 00e4 80E0      		ldi r24,lo8(__c.3381)
 2251 00e6 90E0      		ldi r25,hi8(__c.3381)
 2252               	.L207:
 319:quantum/quantum.c ****         }
 2253               		.loc 1 319 0
 2254 00e8 0E94 0000 		call xputs
 2255               	.LVL231:
 2256 00ec 00C0      		rjmp .L141
 2257               	.L155:
 2258 00ee 80E0      		ldi r24,lo8(__c.3383)
 2259 00f0 90E0      		ldi r25,hi8(__c.3383)
 2260 00f2 00C0      		rjmp .L207
 2261               	.L150:
 549:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 2262               		.loc 1 549 0
 2263 00f4 F801      		movw r30,r16
 2264 00f6 8281      		ldd r24,Z+2
 2265 00f8 8823      		tst r24
 2266 00fa 01F0      		breq .L141
 550:quantum/quantum.c ****       }
 2267               		.loc 1 550 0
 2268 00fc 80E0      		ldi r24,0
 2269               	.L208:
 555:quantum/quantum.c ****       }
 2270               		.loc 1 555 0
 2271 00fe 0E94 0000 		call set_output
 2272               	.LVL232:
 2273 0102 00C0      		rjmp .L141
 2274               	.L153:
 554:quantum/quantum.c ****         set_output(OUTPUT_USB);
 2275               		.loc 1 554 0
 2276 0104 F801      		movw r30,r16
 2277 0106 8281      		ldd r24,Z+2
 2278 0108 8823      		tst r24
 2279 010a 01F0      		breq .L141
 555:quantum/quantum.c ****       }
 2280               		.loc 1 555 0
 2281 010c 82E0      		ldi r24,lo8(2)
 2282 010e 00C0      		rjmp .L208
 2283               	.L147:
 567:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 2284               		.loc 1 567 0
 2285 0110 F801      		movw r30,r16
 2286 0112 8281      		ldd r24,Z+2
 2287 0114 8823      		tst r24
 2288 0116 01F4      		brne .+2
 2289 0118 00C0      		rjmp .L145
 569:quantum/quantum.c ****             eeconfig_init();
 2290               		.loc 1 569 0
 2291 011a 0E94 0000 		call eeconfig_is_enabled
 2292               	.LVL233:
 2293 011e 8111      		cpse r24,__zero_reg__
 2294 0120 00C0      		rjmp .L156
 570:quantum/quantum.c ****         }
 2295               		.loc 1 570 0
 2296 0122 0E94 0000 		call eeconfig_init
 2297               	.LVL234:
 2298               	.L156:
 573:quantum/quantum.c ****         switch (keycode)
 2299               		.loc 1 573 0
 2300 0126 0E94 0000 		call eeconfig_read_keymap
 2301               	.LVL235:
 2302 012a 90E0      		ldi r25,0
 2303 012c 9093 0000 		sts keymap_config+1,r25
 2304 0130 8093 0000 		sts keymap_config,r24
 574:quantum/quantum.c ****         {
 2305               		.loc 1 574 0
 2306 0134 FE01      		movw r30,r28
 2307 0136 E350      		subi r30,3
 2308 0138 FC45      		sbci r31,92
 577:quantum/quantum.c ****             break;
 2309               		.loc 1 577 0
 2310 013a 8091 0000 		lds r24,keymap_config
 2311 013e 8160      		ori r24,lo8(1<<0)
 574:quantum/quantum.c ****         {
 2312               		.loc 1 574 0
 2313 0140 E231      		cpi r30,18
 2314 0142 F105      		cpc r31,__zero_reg__
 2315 0144 00F4      		brsh .L206
 2316 0146 E050      		subi r30,lo8(-(gs(.L159)))
 2317 0148 F040      		sbci r31,hi8(-(gs(.L159)))
 2318 014a 0C94 0000 		jmp __tablejump2__
 2319               		.p2align	1
 2320               	.L159:
 2321 014e 0000      		.word gs(.L158)
 2322 0150 0000      		.word gs(.L160)
 2323 0152 0000      		.word gs(.L161)
 2324 0154 0000      		.word gs(.L162)
 2325 0156 0000      		.word gs(.L163)
 2326 0158 0000      		.word gs(.L164)
 2327 015a 0000      		.word gs(.L165)
 2328 015c 0000      		.word gs(.L166)
 2329 015e 0000      		.word gs(.L167)
 2330 0160 0000      		.word gs(.L168)
 2331 0162 0000      		.word gs(.L169)
 2332 0164 0000      		.word gs(.L170)
 2333 0166 0000      		.word gs(.L171)
 2334 0168 0000      		.word gs(.L172)
 2335 016a 0000      		.word gs(.L173)
 2336 016c 0000      		.word gs(.L174)
 2337 016e 0000      		.word gs(.L175)
 2338 0170 0000      		.word gs(.L176)
 2339               	.L158:
 580:quantum/quantum.c ****             break;
 2340               		.loc 1 580 0
 2341 0172 8091 0000 		lds r24,keymap_config
 2342 0176 8260      		ori r24,lo8(1<<1)
 2343               	.L206:
 650:quantum/quantum.c ****             break;
 2344               		.loc 1 650 0
 2345 0178 8093 0000 		sts keymap_config,r24
 655:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 2346               		.loc 1 655 0
 2347 017c 8091 0000 		lds r24,keymap_config
 2348 0180 0E94 0000 		call eeconfig_update_keymap
 2349               	.LVL236:
 656:quantum/quantum.c **** 
 2350               		.loc 1 656 0
 2351 0184 0E94 0000 		call clear_keyboard
 2352               	.LVL237:
 658:quantum/quantum.c ****       }
 2353               		.loc 1 658 0
 2354 0188 00C0      		rjmp .L141
 2355               	.L160:
 583:quantum/quantum.c ****             break;
 2356               		.loc 1 583 0
 2357 018a 8091 0000 		lds r24,keymap_config
 2358 018e 8460      		ori r24,lo8(1<<2)
 2359 0190 00C0      		rjmp .L206
 2360               	.L161:
 586:quantum/quantum.c ****             break;
 2361               		.loc 1 586 0
 2362 0192 8091 0000 		lds r24,keymap_config
 2363               	.L210:
 602:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2364               		.loc 1 602 0
 2365 0196 8860      		ori r24,lo8(1<<3)
 2366 0198 00C0      		rjmp .L206
 2367               	.L162:
 589:quantum/quantum.c ****             break;
 2368               		.loc 1 589 0
 2369 019a 8091 0000 		lds r24,keymap_config
 2370 019e 8061      		ori r24,lo8(1<<4)
 2371 01a0 00C0      		rjmp .L206
 2372               	.L163:
 592:quantum/quantum.c ****             break;
 2373               		.loc 1 592 0
 2374 01a2 8091 0000 		lds r24,keymap_config
 2375 01a6 8062      		ori r24,lo8(1<<5)
 2376 01a8 00C0      		rjmp .L206
 2377               	.L164:
 595:quantum/quantum.c ****             break;
 2378               		.loc 1 595 0
 2379 01aa 8091 0000 		lds r24,keymap_config
 2380 01ae 8064      		ori r24,lo8(1<<6)
 2381 01b0 00C0      		rjmp .L206
 2382               	.L165:
 598:quantum/quantum.c ****             break;
 2383               		.loc 1 598 0
 2384 01b2 8091 0000 		lds r24,keymap_config
 2385 01b6 8068      		ori r24,lo8(1<<7)
 2386 01b8 00C0      		rjmp .L206
 2387               	.L166:
 601:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 2388               		.loc 1 601 0
 2389 01ba 8091 0000 		lds r24,keymap_config
 602:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2390               		.loc 1 602 0
 2391 01be 8460      		ori r24,lo8(4)
 2392 01c0 00C0      		rjmp .L210
 2393               	.L167:
 608:quantum/quantum.c ****             break;
 2394               		.loc 1 608 0
 2395 01c2 8091 0000 		lds r24,keymap_config
 2396 01c6 8E7F      		andi r24,lo8(~(1<<0))
 2397 01c8 00C0      		rjmp .L206
 2398               	.L168:
 611:quantum/quantum.c ****             break;
 2399               		.loc 1 611 0
 2400 01ca 8091 0000 		lds r24,keymap_config
 2401 01ce 8D7F      		andi r24,lo8(~(1<<1))
 2402 01d0 00C0      		rjmp .L206
 2403               	.L169:
 614:quantum/quantum.c ****             break;
 2404               		.loc 1 614 0
 2405 01d2 8091 0000 		lds r24,keymap_config
 2406 01d6 8B7F      		andi r24,lo8(~(1<<2))
 2407 01d8 00C0      		rjmp .L206
 2408               	.L170:
 617:quantum/quantum.c ****             break;
 2409               		.loc 1 617 0
 2410 01da 8091 0000 		lds r24,keymap_config
 2411               	.L209:
 633:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2412               		.loc 1 633 0
 2413 01de 877F      		andi r24,lo8(~(1<<3))
 2414 01e0 00C0      		rjmp .L206
 2415               	.L171:
 620:quantum/quantum.c ****             break;
 2416               		.loc 1 620 0
 2417 01e2 8091 0000 		lds r24,keymap_config
 2418 01e6 8F7E      		andi r24,lo8(~(1<<4))
 2419 01e8 00C0      		rjmp .L206
 2420               	.L172:
 623:quantum/quantum.c ****             break;
 2421               		.loc 1 623 0
 2422 01ea 8091 0000 		lds r24,keymap_config
 2423 01ee 8F7D      		andi r24,lo8(~(1<<5))
 2424 01f0 00C0      		rjmp .L206
 2425               	.L173:
 626:quantum/quantum.c ****             break;
 2426               		.loc 1 626 0
 2427 01f2 8091 0000 		lds r24,keymap_config
 2428 01f6 8F7B      		andi r24,lo8(~(1<<6))
 2429 01f8 00C0      		rjmp .L206
 2430               	.L174:
 629:quantum/quantum.c ****             break;
 2431               		.loc 1 629 0
 2432 01fa 8091 0000 		lds r24,keymap_config
 2433 01fe 8F77      		andi r24,lo8(~(1<<7))
 2434 0200 00C0      		rjmp .L206
 2435               	.L175:
 632:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 2436               		.loc 1 632 0
 2437 0202 8091 0000 		lds r24,keymap_config
 633:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2438               		.loc 1 633 0
 2439 0206 8B7F      		andi r24,lo8(-5)
 2440 0208 00C0      		rjmp .L209
 2441               	.L176:
 650:quantum/quantum.c ****             break;
 2442               		.loc 1 650 0
 2443 020a 9091 0000 		lds r25,keymap_config
 2444 020e 892F      		mov r24,r25
 2445 0210 97FB      		bst r25,7
 2446 0212 87F9      		bld r24,7
 2447 0214 8058      		subi r24,0x80
 2448 0216 00C0      		rjmp .L206
 2449               	.LVL238:
 2450               	.L183:
 2451               	.LBB54:
 698:quantum/quantum.c ****       }
 2452               		.loc 1 698 0
 2453 0218 85E3      		ldi r24,lo8(53)
 2454               	.LVL239:
 2455 021a 00C0      		rjmp .L180
 2456               	.LVL240:
 2457               	.L178:
 701:quantum/quantum.c ****       }
 2458               		.loc 1 701 0
 2459 021c 8091 0000 		lds r24,grave_esc_was_shifted
 2460               	.LVL241:
 2461 0220 8111      		cpse r24,__zero_reg__
 2462 0222 00C0      		rjmp .L184
 2463 0224 89E2      		ldi r24,lo8(41)
 2464               	.L182:
 701:quantum/quantum.c ****       }
 2465               		.loc 1 701 0 is_stmt 0 discriminator 4
 2466 0226 0E94 0000 		call del_key
 2467               	.LVL242:
 2468 022a 00C0      		rjmp .L181
 2469               	.L184:
 701:quantum/quantum.c ****       }
 2470               		.loc 1 701 0
 2471 022c 85E3      		ldi r24,lo8(53)
 2472 022e 00C0      		rjmp .L182
 2473               	.LBE54:
 2474               		.cfi_endproc
 2475               	.LFE43:
 2477               		.section	.progmem.data.__c.3383,"a",@progbits
 2480               	__c.3383:
 2481 0000 4445 4255 		.string	"DEBUG: disabled.\n"
 2481      473A 2064 
 2481      6973 6162 
 2481      6C65 642E 
 2481      0A00 
 2482               		.section	.progmem.data.__c.3381,"a",@progbits
 2485               	__c.3381:
 2486 0000 4445 4255 		.string	"DEBUG: enabled.\n"
 2486      473A 2065 
 2486      6E61 626C 
 2486      6564 2E0A 
 2486      00
 2487               		.weak	ascii_to_keycode_lut
 2488               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2491               	ascii_to_keycode_lut:
 2492 0000 00        		.byte	0
 2493 0001 00        		.byte	0
 2494 0002 00        		.byte	0
 2495 0003 00        		.byte	0
 2496 0004 00        		.byte	0
 2497 0005 00        		.byte	0
 2498 0006 00        		.byte	0
 2499 0007 00        		.byte	0
 2500 0008 2A        		.byte	42
 2501 0009 2B        		.byte	43
 2502 000a 28        		.byte	40
 2503 000b 00        		.byte	0
 2504 000c 00        		.byte	0
 2505 000d 00        		.byte	0
 2506 000e 00        		.byte	0
 2507 000f 00        		.byte	0
 2508 0010 00        		.byte	0
 2509 0011 00        		.byte	0
 2510 0012 00        		.byte	0
 2511 0013 00        		.byte	0
 2512 0014 00        		.byte	0
 2513 0015 00        		.byte	0
 2514 0016 00        		.byte	0
 2515 0017 00        		.byte	0
 2516 0018 00        		.byte	0
 2517 0019 00        		.byte	0
 2518 001a 00        		.byte	0
 2519 001b 29        		.byte	41
 2520 001c 00        		.byte	0
 2521 001d 00        		.byte	0
 2522 001e 00        		.byte	0
 2523 001f 00        		.byte	0
 2524 0020 2C        		.byte	44
 2525 0021 1E        		.byte	30
 2526 0022 34        		.byte	52
 2527 0023 20        		.byte	32
 2528 0024 21        		.byte	33
 2529 0025 22        		.byte	34
 2530 0026 24        		.byte	36
 2531 0027 34        		.byte	52
 2532 0028 26        		.byte	38
 2533 0029 27        		.byte	39
 2534 002a 25        		.byte	37
 2535 002b 2E        		.byte	46
 2536 002c 36        		.byte	54
 2537 002d 2D        		.byte	45
 2538 002e 37        		.byte	55
 2539 002f 38        		.byte	56
 2540 0030 27        		.byte	39
 2541 0031 1E        		.byte	30
 2542 0032 1F        		.byte	31
 2543 0033 20        		.byte	32
 2544 0034 21        		.byte	33
 2545 0035 22        		.byte	34
 2546 0036 23        		.byte	35
 2547 0037 24        		.byte	36
 2548 0038 25        		.byte	37
 2549 0039 26        		.byte	38
 2550 003a 33        		.byte	51
 2551 003b 33        		.byte	51
 2552 003c 36        		.byte	54
 2553 003d 2E        		.byte	46
 2554 003e 37        		.byte	55
 2555 003f 38        		.byte	56
 2556 0040 1F        		.byte	31
 2557 0041 04        		.byte	4
 2558 0042 05        		.byte	5
 2559 0043 06        		.byte	6
 2560 0044 07        		.byte	7
 2561 0045 08        		.byte	8
 2562 0046 09        		.byte	9
 2563 0047 0A        		.byte	10
 2564 0048 0B        		.byte	11
 2565 0049 0C        		.byte	12
 2566 004a 0D        		.byte	13
 2567 004b 0E        		.byte	14
 2568 004c 0F        		.byte	15
 2569 004d 10        		.byte	16
 2570 004e 11        		.byte	17
 2571 004f 12        		.byte	18
 2572 0050 13        		.byte	19
 2573 0051 14        		.byte	20
 2574 0052 15        		.byte	21
 2575 0053 16        		.byte	22
 2576 0054 17        		.byte	23
 2577 0055 18        		.byte	24
 2578 0056 19        		.byte	25
 2579 0057 1A        		.byte	26
 2580 0058 1B        		.byte	27
 2581 0059 1C        		.byte	28
 2582 005a 1D        		.byte	29
 2583 005b 2F        		.byte	47
 2584 005c 31        		.byte	49
 2585 005d 30        		.byte	48
 2586 005e 23        		.byte	35
 2587 005f 2D        		.byte	45
 2588 0060 35        		.byte	53
 2589 0061 04        		.byte	4
 2590 0062 05        		.byte	5
 2591 0063 06        		.byte	6
 2592 0064 07        		.byte	7
 2593 0065 08        		.byte	8
 2594 0066 09        		.byte	9
 2595 0067 0A        		.byte	10
 2596 0068 0B        		.byte	11
 2597 0069 0C        		.byte	12
 2598 006a 0D        		.byte	13
 2599 006b 0E        		.byte	14
 2600 006c 0F        		.byte	15
 2601 006d 10        		.byte	16
 2602 006e 11        		.byte	17
 2603 006f 12        		.byte	18
 2604 0070 13        		.byte	19
 2605 0071 14        		.byte	20
 2606 0072 15        		.byte	21
 2607 0073 16        		.byte	22
 2608 0074 17        		.byte	23
 2609 0075 18        		.byte	24
 2610 0076 19        		.byte	25
 2611 0077 1A        		.byte	26
 2612 0078 1B        		.byte	27
 2613 0079 1C        		.byte	28
 2614 007a 1D        		.byte	29
 2615 007b 2F        		.byte	47
 2616 007c 31        		.byte	49
 2617 007d 30        		.byte	48
 2618 007e 35        		.byte	53
 2619 007f 4C        		.byte	76
 2620               		.weak	ascii_to_altgr_lut
 2621               		.section	.progmem.data.ascii_to_altgr_lut,"a",@progbits
 2624               	ascii_to_altgr_lut:
 2625 0000 0000 0000 		.zero	128
 2625      0000 0000 
 2625      0000 0000 
 2625      0000 0000 
 2625      0000 0000 
 2626               		.weak	ascii_to_shift_lut
 2627               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2630               	ascii_to_shift_lut:
 2631 0000 00        		.byte	0
 2632 0001 00        		.byte	0
 2633 0002 00        		.byte	0
 2634 0003 00        		.byte	0
 2635 0004 00        		.byte	0
 2636 0005 00        		.byte	0
 2637 0006 00        		.byte	0
 2638 0007 00        		.byte	0
 2639 0008 00        		.byte	0
 2640 0009 00        		.byte	0
 2641 000a 00        		.byte	0
 2642 000b 00        		.byte	0
 2643 000c 00        		.byte	0
 2644 000d 00        		.byte	0
 2645 000e 00        		.byte	0
 2646 000f 00        		.byte	0
 2647 0010 00        		.byte	0
 2648 0011 00        		.byte	0
 2649 0012 00        		.byte	0
 2650 0013 00        		.byte	0
 2651 0014 00        		.byte	0
 2652 0015 00        		.byte	0
 2653 0016 00        		.byte	0
 2654 0017 00        		.byte	0
 2655 0018 00        		.byte	0
 2656 0019 00        		.byte	0
 2657 001a 00        		.byte	0
 2658 001b 00        		.byte	0
 2659 001c 00        		.byte	0
 2660 001d 00        		.byte	0
 2661 001e 00        		.byte	0
 2662 001f 00        		.byte	0
 2663 0020 00        		.byte	0
 2664 0021 01        		.byte	1
 2665 0022 01        		.byte	1
 2666 0023 01        		.byte	1
 2667 0024 01        		.byte	1
 2668 0025 01        		.byte	1
 2669 0026 01        		.byte	1
 2670 0027 00        		.byte	0
 2671 0028 01        		.byte	1
 2672 0029 01        		.byte	1
 2673 002a 01        		.byte	1
 2674 002b 01        		.byte	1
 2675 002c 00        		.byte	0
 2676 002d 00        		.byte	0
 2677 002e 00        		.byte	0
 2678 002f 00        		.byte	0
 2679 0030 00        		.byte	0
 2680 0031 00        		.byte	0
 2681 0032 00        		.byte	0
 2682 0033 00        		.byte	0
 2683 0034 00        		.byte	0
 2684 0035 00        		.byte	0
 2685 0036 00        		.byte	0
 2686 0037 00        		.byte	0
 2687 0038 00        		.byte	0
 2688 0039 00        		.byte	0
 2689 003a 01        		.byte	1
 2690 003b 00        		.byte	0
 2691 003c 01        		.byte	1
 2692 003d 00        		.byte	0
 2693 003e 01        		.byte	1
 2694 003f 01        		.byte	1
 2695 0040 01        		.byte	1
 2696 0041 01        		.byte	1
 2697 0042 01        		.byte	1
 2698 0043 01        		.byte	1
 2699 0044 01        		.byte	1
 2700 0045 01        		.byte	1
 2701 0046 01        		.byte	1
 2702 0047 01        		.byte	1
 2703 0048 01        		.byte	1
 2704 0049 01        		.byte	1
 2705 004a 01        		.byte	1
 2706 004b 01        		.byte	1
 2707 004c 01        		.byte	1
 2708 004d 01        		.byte	1
 2709 004e 01        		.byte	1
 2710 004f 01        		.byte	1
 2711 0050 01        		.byte	1
 2712 0051 01        		.byte	1
 2713 0052 01        		.byte	1
 2714 0053 01        		.byte	1
 2715 0054 01        		.byte	1
 2716 0055 01        		.byte	1
 2717 0056 01        		.byte	1
 2718 0057 01        		.byte	1
 2719 0058 01        		.byte	1
 2720 0059 01        		.byte	1
 2721 005a 01        		.byte	1
 2722 005b 00        		.byte	0
 2723 005c 00        		.byte	0
 2724 005d 00        		.byte	0
 2725 005e 01        		.byte	1
 2726 005f 01        		.byte	1
 2727 0060 00        		.byte	0
 2728 0061 00        		.byte	0
 2729 0062 00        		.byte	0
 2730 0063 00        		.byte	0
 2731 0064 00        		.byte	0
 2732 0065 00        		.byte	0
 2733 0066 00        		.byte	0
 2734 0067 00        		.byte	0
 2735 0068 00        		.byte	0
 2736 0069 00        		.byte	0
 2737 006a 00        		.byte	0
 2738 006b 00        		.byte	0
 2739 006c 00        		.byte	0
 2740 006d 00        		.byte	0
 2741 006e 00        		.byte	0
 2742 006f 00        		.byte	0
 2743 0070 00        		.byte	0
 2744 0071 00        		.byte	0
 2745 0072 00        		.byte	0
 2746 0073 00        		.byte	0
 2747 0074 00        		.byte	0
 2748 0075 00        		.byte	0
 2749 0076 00        		.byte	0
 2750 0077 00        		.byte	0
 2751 0078 00        		.byte	0
 2752 0079 00        		.byte	0
 2753 007a 00        		.byte	0
 2754 007b 01        		.byte	1
 2755 007c 01        		.byte	1
 2756 007d 01        		.byte	1
 2757 007e 01        		.byte	1
 2758 007f 00        		.byte	0
 2759               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2762               	grave_esc_was_shifted:
 2763 0000 00        		.zero	1
 2764               		.text
 2765               	.Letext0:
 2766               		.file 3 "/usr/local/Cellar/avr-gcc/7.2.0/avr/include/stdint.h"
 2767               		.file 4 "/usr/local/Cellar/avr-gcc/7.2.0/lib/avr-gcc/7/gcc/avr/7.2.0/include/stddef.h"
 2768               		.file 5 "tmk_core/common/keyboard.h"
 2769               		.file 6 "tmk_core/common/action.h"
 2770               		.file 7 "tmk_core/common/report.h"
 2771               		.file 8 "tmk_core/common/host.h"
 2772               		.file 9 "tmk_core/common/avr/xprintf.h"
 2773               		.file 10 "tmk_core/common/debug.h"
 2774               		.file 11 "quantum/keycode_config.h"
 2775               		.file 12 "tmk_core/common/keycode.h"
 2776               		.file 13 "quantum/quantum_keycodes.h"
 2777               		.file 14 "quantum/keymap.h"
 2778               		.file 15 "tmk_core/common/action_layer.h"
 2779               		.file 16 "tmk_core/common/timer.h"
 2780               		.file 17 "tmk_core/common/action_util.h"
 2781               		.file 18 "/usr/local/Cellar/avr-gcc/7.2.0/avr/include/stdlib.h"
 2782               		.file 19 "quantum/quantum.h"
 2783               		.file 20 "tmk_core/protocol/lufa/outputselect.h"
 2784               		.file 21 "tmk_core/common/backlight.h"
 2785               		.file 22 "quantum/rgb.h"
 2786               		.file 23 "tmk_core/common/eeconfig.h"
 2787               		.file 24 "tmk_core/common/matrix.h"
 2788               		.file 25 "tmk_core/common/bootloader.h"
 2789               		.file 26 "quantum/process_keycode/process_space_cadet.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:4      *ABS*:000000000000003f __SREG__
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:12     .text.do_code16:0000000000000000 do_code16
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:132    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:162    .text.qk_register_mods:0000000000000000 qk_register_mods
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:175    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:205    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:219    .text.rgblight_toggle:0000000000000000 rgblight_toggle
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:234    .text.rgblight_step:0000000000000000 rgblight_step
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:249    .text.rgblight_step_reverse:0000000000000000 rgblight_step_reverse
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:264    .text.rgblight_increase_hue:0000000000000000 rgblight_increase_hue
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:279    .text.rgblight_decrease_hue:0000000000000000 rgblight_decrease_hue
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:294    .text.rgblight_increase_sat:0000000000000000 rgblight_increase_sat
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:309    .text.rgblight_decrease_sat:0000000000000000 rgblight_decrease_sat
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:324    .text.rgblight_increase_val:0000000000000000 rgblight_increase_val
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:339    .text.rgblight_decrease_val:0000000000000000 rgblight_decrease_val
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:354    .text.rgblight_increase_speed:0000000000000000 rgblight_increase_speed
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:369    .text.rgblight_decrease_speed:0000000000000000 rgblight_decrease_speed
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:384    .text.register_code16:0000000000000000 register_code16
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:440    .text.unregister_code16:0000000000000000 unregister_code16
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:494    .text.tap_code16:0000000000000000 tap_code16
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:531    .text.process_action_kb:0000000000000000 process_action_kb
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:551    .text.process_record_user:0000000000000000 process_record_user
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:571    .text.process_record_kb:0000000000000000 process_record_kb
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:589    .text.get_event_keycode:0000000000000000 get_event_keycode
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:686    .text.get_record_keycode:0000000000000000 get_record_keycode
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:711    .text.send_char:0000000000000000 send_char
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2491   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2630   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2624   .progmem.data.ascii_to_altgr_lut:0000000000000000 ascii_to_altgr_lut
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:839    .text.send_string_with_delay:0000000000000000 send_string_with_delay
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:985    .text.send_string:0000000000000000 send_string
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1004   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1182   .text.send_string_P:0000000000000000 send_string_P
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1201   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1249   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1406   .text.update_tri_layer:0000000000000000 update_tri_layer
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1445   .text.tap_random_base64:0000000000000000 tap_random_base64
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1571   .text.bootmagic_lite:0000000000000000 bootmagic_lite
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1619   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1645   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1662   .text.backlight_init_ports:0000000000000000 backlight_init_ports
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1677   .text.send_nibble:0000000000000000 send_nibble
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1740   .text.send_byte:0000000000000000 send_byte
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1777   .text.send_word:0000000000000000 send_word
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1811   .text.send_dword:0000000000000000 send_dword
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1857   .text.hex_to_keycode:0000000000000000 hex_to_keycode
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1897   .text.api_send_unicode:0000000000000000 api_send_unicode
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1915   .text.led_set_user:0000000000000000 led_set_user
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1915   .text.led_set_user:0000000000000000 led_set_user.localalias.1
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1934   .text.backlight_set:0000000000000000 backlight_set
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1949   .text.led_set_kb:0000000000000000 led_set_kb
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1967   .text.led_init_ports:0000000000000000 led_init_ports
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:1984   .text.led_set:0000000000000000 led_set
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2002   .text.startup_user:0000000000000000 startup_user
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2017   .text.shutdown_user:0000000000000000 shutdown_user
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2032   .text.reset_keyboard:0000000000000000 reset_keyboard
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2070   .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2762   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2485   .progmem.data.__c.3381:0000000000000000 __c.3381
/var/folders/3r/yll9b16919931vhbnddhf4vc0000gp/T//ccYyglBO.s:2480   .progmem.data.__c.3383:0000000000000000 __c.3383

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
keymap_key_to_keycode
read_source_layers_cache
tap_code
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_scan
matrix_get_row
eeconfig_disable
bootloader_jump
eeconfig_is_enabled
eeconfig_init
matrix_init_kb
matrix_scan_kb
clear_keyboard
process_space_cadet
get_mods
add_key
debug_config
xputs
set_output
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
del_key
__do_clear_bss
