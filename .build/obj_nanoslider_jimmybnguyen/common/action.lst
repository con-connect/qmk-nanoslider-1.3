   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB106:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "backlight.h"
  24:tmk_core/common/action.c **** #include "action_layer.h"
  25:tmk_core/common/action.c **** #include "action_tapping.h"
  26:tmk_core/common/action.c **** #include "action_macro.h"
  27:tmk_core/common/action.c **** #include "action_util.h"
  28:tmk_core/common/action.c **** #include "action.h"
  29:tmk_core/common/action.c **** #include "wait.h"
  30:tmk_core/common/action.c **** 
  31:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:tmk_core/common/action.c **** #include "debug.h"
  33:tmk_core/common/action.c **** #else
  34:tmk_core/common/action.c **** #include "nodebug.h"
  35:tmk_core/common/action.c **** #endif
  36:tmk_core/common/action.c **** 
  37:tmk_core/common/action.c **** int tp_buttons;
  38:tmk_core/common/action.c **** 
  39:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:tmk_core/common/action.c **** #endif
  42:tmk_core/common/action.c **** 
  43:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:tmk_core/common/action.c **** #include <fauxclicky.h>
  45:tmk_core/common/action.c **** #endif
  46:tmk_core/common/action.c **** 
  47:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  48:tmk_core/common/action.c **** #  define TAP_HOLD_CAPS_DELAY 200
  49:tmk_core/common/action.c **** #endif
  50:tmk_core/common/action.c **** /** \brief Called to execute an action.
  51:tmk_core/common/action.c ****  *
  52:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  53:tmk_core/common/action.c ****  */
  54:tmk_core/common/action.c **** void action_exec(keyevent_t event)
  55:tmk_core/common/action.c **** {
  16               		.loc 1 55 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  56:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  57:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  58:tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  59:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  60:tmk_core/common/action.c ****         retro_tapping_counter++;
  61:tmk_core/common/action.c **** #endif
  62:tmk_core/common/action.c ****     }
  63:tmk_core/common/action.c **** 
  64:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  65:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  66:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  67:tmk_core/common/action.c ****     }
  68:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  69:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  70:tmk_core/common/action.c ****     }
  71:tmk_core/common/action.c ****     fauxclicky_check();
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c **** 
  74:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  75:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  76:tmk_core/common/action.c ****         process_hand_swap(&event);
  77:tmk_core/common/action.c ****     }
  78:tmk_core/common/action.c **** #endif
  79:tmk_core/common/action.c **** 
  80:tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  48               		.loc 1 80 0
  49 001e DE01      		movw r26,r28
  50 0020 1196      		adiw r26,1
  51 0022 86E0      		ldi r24,lo8(6)
  52 0024 FD01      		movw r30,r26
  53               		0:
  54 0026 1192      		st Z+,__zero_reg__
  55 0028 8A95      		dec r24
  56 002a 01F4      		brne 0b
  57 002c 85E0      		ldi r24,lo8(5)
  58 002e FE01      		movw r30,r28
  59 0030 3796      		adiw r30,7
  60               		0:
  61 0032 0190      		ld r0,Z+
  62 0034 0D92      		st X+,r0
  63 0036 8A95      		dec r24
  64 0038 01F4      		brne 0b
  81:tmk_core/common/action.c **** 
  82:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  83:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  84:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  85:tmk_core/common/action.c ****     }
  86:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  87:tmk_core/common/action.c ****         clear_oneshot_mods();
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  92:tmk_core/common/action.c ****     action_tapping_process(record);
  65               		.loc 1 92 0
  66 003a 4981      		ldd r20,Y+1
  67               	.LVL1:
  68 003c 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70 003e 6B81      		ldd r22,Y+3
  71 0040 7C81      		ldd r23,Y+4
  72 0042 8D81      		ldd r24,Y+5
  73 0044 9E81      		ldd r25,Y+6
  74 0046 0E94 0000 		call action_tapping_process
  75               	.LVL3:
  76               	/* epilogue start */
  93:tmk_core/common/action.c **** #else
  94:tmk_core/common/action.c ****     process_record(&record);
  95:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  96:tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c **** #endif
  99:tmk_core/common/action.c **** }
  77               		.loc 1 99 0
  78 004a 2B96      		adiw r28,11
  79 004c 0FB6      		in __tmp_reg__,__SREG__
  80 004e F894      		cli
  81 0050 DEBF      		out __SP_H__,r29
  82 0052 0FBE      		out __SREG__,__tmp_reg__
  83 0054 CDBF      		out __SP_L__,r28
  84 0056 DF91      		pop r29
  85 0058 CF91      		pop r28
  86 005a 0895      		ret
  87               		.cfi_endproc
  88               	.LFE106:
  90               		.section	.text.process_record_quantum,"ax",@progbits
  91               		.weak	process_record_quantum
  93               	process_record_quantum:
  94               	.LFB108:
 100:tmk_core/common/action.c **** 
 101:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 102:tmk_core/common/action.c **** bool swap_hands = false;
 103:tmk_core/common/action.c **** bool swap_held = false;
 104:tmk_core/common/action.c **** 
 105:tmk_core/common/action.c **** /** \brief Process Hand Swap
 106:tmk_core/common/action.c ****  *
 107:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 108:tmk_core/common/action.c ****  */
 109:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 110:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 111:tmk_core/common/action.c **** 
 112:tmk_core/common/action.c ****     keypos_t pos = event->key;
 113:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 114:tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 115:tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 116:tmk_core/common/action.c **** 
 117:tmk_core/common/action.c ****     if (do_swap) {
 118:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 119:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 120:tmk_core/common/action.c ****     } else {
 121:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 122:tmk_core/common/action.c ****     }
 123:tmk_core/common/action.c **** }
 124:tmk_core/common/action.c **** #endif
 125:tmk_core/common/action.c **** 
 126:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 127:tmk_core/common/action.c **** bool disable_action_cache = false;
 128:tmk_core/common/action.c **** 
 129:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 130:tmk_core/common/action.c **** {
 131:tmk_core/common/action.c ****     disable_action_cache = true;
 132:tmk_core/common/action.c ****     process_record(record);
 133:tmk_core/common/action.c ****     disable_action_cache = false;
 134:tmk_core/common/action.c **** }
 135:tmk_core/common/action.c **** #else
 136:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 137:tmk_core/common/action.c **** {
 138:tmk_core/common/action.c ****     process_record(record);
 139:tmk_core/common/action.c **** }
 140:tmk_core/common/action.c **** #endif
 141:tmk_core/common/action.c **** 
 142:tmk_core/common/action.c **** __attribute__ ((weak))
 143:tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  95               		.loc 1 143 0
  96               		.cfi_startproc
  97               	.LVL4:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 144:tmk_core/common/action.c ****     return true;
 145:tmk_core/common/action.c **** }
 102               		.loc 1 145 0
 103 0000 81E0      		ldi r24,lo8(1)
 104               	.LVL5:
 105 0002 0895      		ret
 106               		.cfi_endproc
 107               	.LFE108:
 109               		.section	.text.process_record_tap_hint,"ax",@progbits
 110               	.global	process_record_tap_hint
 112               	process_record_tap_hint:
 113               	.LFB109:
 146:tmk_core/common/action.c **** 
 147:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 148:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 149:tmk_core/common/action.c ****  *
 150:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 151:tmk_core/common/action.c ****  */
 152:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 153:tmk_core/common/action.c **** {
 114               		.loc 1 153 0
 115               		.cfi_startproc
 116               	.LVL6:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 154:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 121               		.loc 1 154 0
 122 0000 FC01      		movw r30,r24
 123 0002 8081      		ld r24,Z
 124 0004 9181      		ldd r25,Z+1
 125               	.LVL7:
 126 0006 0E94 0000 		call layer_switch_get_action
 127               	.LVL8:
 128 000a 0895      		ret
 129               		.cfi_endproc
 130               	.LFE109:
 132               		.section	.text.register_code,"ax",@progbits
 133               	.global	register_code
 135               	register_code:
 136               	.LFB112:
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c ****     switch (action.kind.id) {
 157:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 158:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 159:tmk_core/common/action.c ****             switch (action.swap.code) {
 160:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 161:tmk_core/common/action.c ****                 default:
 162:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 163:tmk_core/common/action.c ****                     swap_held = true;
 164:tmk_core/common/action.c ****             }
 165:tmk_core/common/action.c ****             break;
 166:tmk_core/common/action.c **** #endif
 167:tmk_core/common/action.c ****     }
 168:tmk_core/common/action.c **** }
 169:tmk_core/common/action.c **** #endif
 170:tmk_core/common/action.c **** 
 171:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 172:tmk_core/common/action.c ****  *
 173:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 174:tmk_core/common/action.c ****  */
 175:tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 176:tmk_core/common/action.c **** {
 177:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 178:tmk_core/common/action.c **** 
 179:tmk_core/common/action.c ****     if(!process_record_quantum(record))
 180:tmk_core/common/action.c ****         return;
 181:tmk_core/common/action.c **** 
 182:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 183:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 184:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 185:tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 186:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 187:tmk_core/common/action.c **** #endif
 188:tmk_core/common/action.c ****     dprintln();
 189:tmk_core/common/action.c **** 
 190:tmk_core/common/action.c ****     process_action(record, action);
 191:tmk_core/common/action.c **** }
 192:tmk_core/common/action.c **** 
 193:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 194:tmk_core/common/action.c ****  *
 195:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 196:tmk_core/common/action.c ****  */
 197:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 198:tmk_core/common/action.c **** {
 199:tmk_core/common/action.c ****     keyevent_t event = record->event;
 200:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 201:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 202:tmk_core/common/action.c **** #endif
 203:tmk_core/common/action.c **** 
 204:tmk_core/common/action.c ****     if (event.pressed) {
 205:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 206:tmk_core/common/action.c ****         clear_weak_mods();
 207:tmk_core/common/action.c ****     }
 208:tmk_core/common/action.c **** 
 209:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 210:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 211:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 212:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 213:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 214:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 215:tmk_core/common/action.c ****     }
 216:tmk_core/common/action.c **** #endif
 217:tmk_core/common/action.c **** 
 218:tmk_core/common/action.c ****     switch (action.kind.id) {
 219:tmk_core/common/action.c ****         /* Key and Mods */
 220:tmk_core/common/action.c ****         case ACT_LMODS:
 221:tmk_core/common/action.c ****         case ACT_RMODS:
 222:tmk_core/common/action.c ****             {
 223:tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 224:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 225:tmk_core/common/action.c ****                 if (event.pressed) {
 226:tmk_core/common/action.c ****                     if (mods) {
 227:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 228:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 229:tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 230:tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 231:tmk_core/common/action.c ****                             add_mods(mods);
 232:tmk_core/common/action.c ****                         } else {
 233:tmk_core/common/action.c ****                             add_weak_mods(mods);
 234:tmk_core/common/action.c ****                         }
 235:tmk_core/common/action.c ****                         send_keyboard_report();
 236:tmk_core/common/action.c ****                     }
 237:tmk_core/common/action.c ****                     register_code(action.key.code);
 238:tmk_core/common/action.c ****                 } else {
 239:tmk_core/common/action.c ****                     unregister_code(action.key.code);
 240:tmk_core/common/action.c ****                     if (mods) {
 241:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 242:tmk_core/common/action.c ****                             del_mods(mods);
 243:tmk_core/common/action.c ****                         } else {
 244:tmk_core/common/action.c ****                             del_weak_mods(mods);
 245:tmk_core/common/action.c ****                         }
 246:tmk_core/common/action.c ****                         send_keyboard_report();
 247:tmk_core/common/action.c ****                     }
 248:tmk_core/common/action.c ****                 }
 249:tmk_core/common/action.c ****             }
 250:tmk_core/common/action.c ****             break;
 251:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 252:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 253:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 254:tmk_core/common/action.c ****             {
 255:tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 256:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 257:tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 258:tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 259:tmk_core/common/action.c ****                     case MODS_ONESHOT:
 260:tmk_core/common/action.c ****                         // Oneshot modifier
 261:tmk_core/common/action.c ****                         if (event.pressed) {
 262:tmk_core/common/action.c ****                             if (tap_count == 0) {
 263:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 264:tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 265:tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 266:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 267:tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 268:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 269:tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 270:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 271:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 272:tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 273:tmk_core/common/action.c ****                                 register_mods(mods);
 274:tmk_core/common/action.c ****                     #endif
 275:tmk_core/common/action.c ****                             } else {
 276:tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 277:tmk_core/common/action.c ****                             }
 278:tmk_core/common/action.c ****                         } else {
 279:tmk_core/common/action.c ****                             if (tap_count == 0) {
 280:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 281:tmk_core/common/action.c ****                                 unregister_mods(mods);
 282:tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 283:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 284:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 285:tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 286:tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 287:tmk_core/common/action.c ****                                     clear_oneshot_mods();
 288:tmk_core/common/action.c ****                                     unregister_mods(mods);
 289:tmk_core/common/action.c ****                                 }
 290:tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 291:tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 292:tmk_core/common/action.c ****                     #endif
 293:tmk_core/common/action.c ****                             } else {
 294:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 295:tmk_core/common/action.c ****                                 unregister_mods(mods);
 296:tmk_core/common/action.c ****                             }
 297:tmk_core/common/action.c ****                         }
 298:tmk_core/common/action.c ****                         break;
 299:tmk_core/common/action.c ****     #endif
 300:tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 301:tmk_core/common/action.c ****                         if (event.pressed) {
 302:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 303:tmk_core/common/action.c ****                                 register_mods(mods);
 304:tmk_core/common/action.c ****                             }
 305:tmk_core/common/action.c ****                         } else {
 306:tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 307:tmk_core/common/action.c ****                                 unregister_mods(mods);
 308:tmk_core/common/action.c ****                             }
 309:tmk_core/common/action.c ****                         }
 310:tmk_core/common/action.c ****                         break;
 311:tmk_core/common/action.c ****                     default:
 312:tmk_core/common/action.c ****                         if (event.pressed) {
 313:tmk_core/common/action.c ****                             if (tap_count > 0) {
 314:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 315:tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 316:tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 317:tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 318:tmk_core/common/action.c ****                                     record->tap.count = 0;
 319:tmk_core/common/action.c ****                                     register_mods(mods);
 320:tmk_core/common/action.c ****                                 } else
 321:tmk_core/common/action.c **** #endif
 322:tmk_core/common/action.c ****                                 {
 323:tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 324:tmk_core/common/action.c ****                                     register_code(action.key.code);
 325:tmk_core/common/action.c ****                                 }
 326:tmk_core/common/action.c ****                             } else {
 327:tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 328:tmk_core/common/action.c ****                                 register_mods(mods);
 329:tmk_core/common/action.c ****                             }
 330:tmk_core/common/action.c ****                         } else {
 331:tmk_core/common/action.c ****                             if (tap_count > 0) {
 332:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 333:tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 334:tmk_core/common/action.c ****                             } else {
 335:tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 336:tmk_core/common/action.c ****                                 unregister_mods(mods);
 337:tmk_core/common/action.c ****                             }
 338:tmk_core/common/action.c ****                         }
 339:tmk_core/common/action.c ****                         break;
 340:tmk_core/common/action.c ****                 }
 341:tmk_core/common/action.c ****             }
 342:tmk_core/common/action.c ****             break;
 343:tmk_core/common/action.c **** #endif
 344:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 345:tmk_core/common/action.c ****         /* other HID usage */
 346:tmk_core/common/action.c ****         case ACT_USAGE:
 347:tmk_core/common/action.c ****             switch (action.usage.page) {
 348:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 349:tmk_core/common/action.c ****                     if (event.pressed) {
 350:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 351:tmk_core/common/action.c ****                     } else {
 352:tmk_core/common/action.c ****                         host_system_send(0);
 353:tmk_core/common/action.c ****                     }
 354:tmk_core/common/action.c ****                     break;
 355:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 356:tmk_core/common/action.c ****                     if (event.pressed) {
 357:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 358:tmk_core/common/action.c ****                     } else {
 359:tmk_core/common/action.c ****                         host_consumer_send(0);
 360:tmk_core/common/action.c ****                     }
 361:tmk_core/common/action.c ****                     break;
 362:tmk_core/common/action.c ****             }
 363:tmk_core/common/action.c ****             break;
 364:tmk_core/common/action.c **** #endif
 365:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 366:tmk_core/common/action.c ****         /* Mouse key */
 367:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 368:tmk_core/common/action.c ****             if (event.pressed) {
 369:tmk_core/common/action.c ****                 switch (action.key.code) {
 370:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 371:tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 372:tmk_core/common/action.c ****                         break;
 373:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 374:tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 375:tmk_core/common/action.c ****                         break;
 376:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 377:tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 378:tmk_core/common/action.c ****                         break;
 379:tmk_core/common/action.c ****                     default:
 380:tmk_core/common/action.c ****                         break;
 381:tmk_core/common/action.c ****                 }
 382:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 383:tmk_core/common/action.c ****                 mousekey_send();
 384:tmk_core/common/action.c ****             } else {
 385:tmk_core/common/action.c ****                 switch (action.key.code) {
 386:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 387:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 388:tmk_core/common/action.c ****                         break;
 389:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 390:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 391:tmk_core/common/action.c ****                         break;
 392:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 393:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 394:tmk_core/common/action.c ****                         break;
 395:tmk_core/common/action.c ****                     default:
 396:tmk_core/common/action.c ****                         break;
 397:tmk_core/common/action.c ****                 }
 398:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 399:tmk_core/common/action.c ****                 mousekey_send();
 400:tmk_core/common/action.c ****             }
 401:tmk_core/common/action.c ****             break;
 402:tmk_core/common/action.c **** #endif
 403:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 404:tmk_core/common/action.c ****         case ACT_LAYER:
 405:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 406:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 407:tmk_core/common/action.c ****                 if (!event.pressed) {
 408:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 409:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 410:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 411:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 412:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 413:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 414:tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 415:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_set(bits | mask); break;
 416:tmk_core/common/action.c ****                     }
 417:tmk_core/common/action.c ****                 }
 418:tmk_core/common/action.c ****             } else {
 419:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 420:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 421:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 422:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 423:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 424:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 425:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 426:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 427:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 428:tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 429:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_state_set(bits | mask); break;
 430:tmk_core/common/action.c ****                     }
 431:tmk_core/common/action.c ****                 }
 432:tmk_core/common/action.c ****             }
 433:tmk_core/common/action.c ****             break;
 434:tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 435:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 436:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 437:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 438:tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 439:tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 440:tmk_core/common/action.c ****                     if (event.pressed) {
 441:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 442:tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 443:tmk_core/common/action.c ****                     } else {
 444:tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 445:tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 446:tmk_core/common/action.c ****                     }
 447:tmk_core/common/action.c ****                     break;
 448:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 449:tmk_core/common/action.c ****                     /* tap toggle */
 450:tmk_core/common/action.c ****                     if (event.pressed) {
 451:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 452:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 453:tmk_core/common/action.c ****                         }
 454:tmk_core/common/action.c ****                     } else {
 455:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 456:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 457:tmk_core/common/action.c ****                         }
 458:tmk_core/common/action.c ****                     }
 459:tmk_core/common/action.c ****                     break;
 460:tmk_core/common/action.c ****                 case OP_ON_OFF:
 461:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 462:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 463:tmk_core/common/action.c ****                     break;
 464:tmk_core/common/action.c ****                 case OP_OFF_ON:
 465:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 466:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 467:tmk_core/common/action.c ****                     break;
 468:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 469:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 470:tmk_core/common/action.c ****                                     layer_clear();
 471:tmk_core/common/action.c ****                     break;
 472:tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 473:tmk_core/common/action.c ****                 case OP_ONESHOT:
 474:tmk_core/common/action.c ****                     // Oneshot modifier
 475:tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 476:tmk_core/common/action.c ****                     do_release_oneshot = false;
 477:tmk_core/common/action.c ****                     if (event.pressed) {
 478:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 479:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 480:tmk_core/common/action.c ****                             reset_oneshot_layer();
 481:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 482:tmk_core/common/action.c ****                             break;
 483:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 484:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 485:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 486:tmk_core/common/action.c ****                         }
 487:tmk_core/common/action.c ****                     } else {
 488:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 489:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 490:tmk_core/common/action.c ****                             reset_oneshot_layer();
 491:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 492:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 493:tmk_core/common/action.c ****                         } else {
 494:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 495:tmk_core/common/action.c ****                         }
 496:tmk_core/common/action.c ****                     }
 497:tmk_core/common/action.c ****                 #else
 498:tmk_core/common/action.c ****                     if (event.pressed) {
 499:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 500:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 501:tmk_core/common/action.c ****                     } else {
 502:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 503:tmk_core/common/action.c ****                         if (tap_count > 1) {
 504:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 505:tmk_core/common/action.c ****                         }
 506:tmk_core/common/action.c ****                     }
 507:tmk_core/common/action.c ****                 #endif
 508:tmk_core/common/action.c ****                     break;
 509:tmk_core/common/action.c ****             #endif
 510:tmk_core/common/action.c ****                 default:
 511:tmk_core/common/action.c ****                     /* tap key */
 512:tmk_core/common/action.c ****                     if (event.pressed) {
 513:tmk_core/common/action.c ****                         if (tap_count > 0) {
 514:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 515:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 516:tmk_core/common/action.c ****                         } else {
 517:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 518:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 519:tmk_core/common/action.c ****                         }
 520:tmk_core/common/action.c ****                     } else {
 521:tmk_core/common/action.c ****                         if (tap_count > 0) {
 522:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 523:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 524:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 525:tmk_core/common/action.c ****                             }
 526:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 527:tmk_core/common/action.c ****                         } else {
 528:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 529:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 530:tmk_core/common/action.c ****                         }
 531:tmk_core/common/action.c ****                     }
 532:tmk_core/common/action.c ****                     break;
 533:tmk_core/common/action.c ****             }
 534:tmk_core/common/action.c ****             break;
 535:tmk_core/common/action.c ****     #endif
 536:tmk_core/common/action.c **** #endif
 537:tmk_core/common/action.c ****         /* Extentions */
 538:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 539:tmk_core/common/action.c ****         case ACT_MACRO:
 540:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 541:tmk_core/common/action.c ****             break;
 542:tmk_core/common/action.c **** #endif
 543:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) | defined(LED_MATRIX_ENABLE)
 544:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 545:tmk_core/common/action.c ****             if (!event.pressed) {
 546:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 547:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 548:tmk_core/common/action.c ****                         backlight_increase();
 549:tmk_core/common/action.c ****                         break;
 550:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 551:tmk_core/common/action.c ****                         backlight_decrease();
 552:tmk_core/common/action.c ****                         break;
 553:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 554:tmk_core/common/action.c ****                         backlight_toggle();
 555:tmk_core/common/action.c ****                         break;
 556:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 557:tmk_core/common/action.c ****                         backlight_step();
 558:tmk_core/common/action.c ****                         break;
 559:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 560:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 561:tmk_core/common/action.c ****                         break;
 562:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 563:tmk_core/common/action.c ****                         backlight_level(0);
 564:tmk_core/common/action.c ****                         break;
 565:tmk_core/common/action.c ****                 }
 566:tmk_core/common/action.c ****             }
 567:tmk_core/common/action.c ****             break;
 568:tmk_core/common/action.c **** #endif
 569:tmk_core/common/action.c ****         case ACT_COMMAND:
 570:tmk_core/common/action.c ****             break;
 571:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 572:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 573:tmk_core/common/action.c ****             switch (action.swap.code) {
 574:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 575:tmk_core/common/action.c ****                     if (event.pressed) {
 576:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 577:tmk_core/common/action.c ****                     }
 578:tmk_core/common/action.c ****                     break;
 579:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 580:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 581:tmk_core/common/action.c ****                     break;
 582:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 583:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 584:tmk_core/common/action.c ****                     break;
 585:tmk_core/common/action.c ****                 case OP_SH_ON:
 586:tmk_core/common/action.c ****                     if (!event.pressed) {
 587:tmk_core/common/action.c ****                         swap_hands = true;
 588:tmk_core/common/action.c ****                     }
 589:tmk_core/common/action.c ****                     break;
 590:tmk_core/common/action.c ****                 case OP_SH_OFF:
 591:tmk_core/common/action.c ****                     if (!event.pressed) {
 592:tmk_core/common/action.c ****                         swap_hands = false;
 593:tmk_core/common/action.c ****                     }
 594:tmk_core/common/action.c ****                     break;
 595:tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 596:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 597:tmk_core/common/action.c ****                     /* tap toggle */
 598:tmk_core/common/action.c **** 
 599:tmk_core/common/action.c ****                     if (event.pressed) {
 600:tmk_core/common/action.c ****                         if (swap_held) {
 601:tmk_core/common/action.c ****                             swap_held = false;
 602:tmk_core/common/action.c ****                         } else {
 603:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 604:tmk_core/common/action.c ****                         }
 605:tmk_core/common/action.c ****                     } else {
 606:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 607:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 608:tmk_core/common/action.c ****                         }
 609:tmk_core/common/action.c ****                     }
 610:tmk_core/common/action.c ****                     break;
 611:tmk_core/common/action.c ****                 default:
 612:tmk_core/common/action.c ****                     /* tap key */
 613:tmk_core/common/action.c ****                     if (tap_count > 0) {
 614:tmk_core/common/action.c ****                         if (swap_held) {
 615:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 616:tmk_core/common/action.c ****                             swap_held = false;
 617:tmk_core/common/action.c ****                         }
 618:tmk_core/common/action.c ****                         if (event.pressed) {
 619:tmk_core/common/action.c ****                             register_code(action.swap.code);
 620:tmk_core/common/action.c ****                         } else {
 621:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 622:tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 623:tmk_core/common/action.c ****                         }
 624:tmk_core/common/action.c ****                     } else {
 625:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 626:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 627:tmk_core/common/action.c ****                             swap_held = false;
 628:tmk_core/common/action.c ****                         }
 629:tmk_core/common/action.c ****                     }
 630:tmk_core/common/action.c ****     #endif
 631:tmk_core/common/action.c ****             }
 632:tmk_core/common/action.c **** #endif
 633:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 634:tmk_core/common/action.c ****         case ACT_FUNCTION:
 635:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 636:tmk_core/common/action.c ****             break;
 637:tmk_core/common/action.c **** #endif
 638:tmk_core/common/action.c ****         default:
 639:tmk_core/common/action.c ****             break;
 640:tmk_core/common/action.c ****     }
 641:tmk_core/common/action.c **** 
 642:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 643:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 644:tmk_core/common/action.c ****     switch (action.kind.id) {
 645:tmk_core/common/action.c ****         case ACT_LAYER:
 646:tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 647:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 648:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 649:tmk_core/common/action.c ****         #endif
 650:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 651:tmk_core/common/action.c ****             break;
 652:tmk_core/common/action.c ****         default:
 653:tmk_core/common/action.c ****             break;
 654:tmk_core/common/action.c ****     }
 655:tmk_core/common/action.c **** #endif
 656:tmk_core/common/action.c **** 
 657:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 658:tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 659:tmk_core/common/action.c ****   if (!is_tap_action(action)) {
 660:tmk_core/common/action.c ****     retro_tapping_counter = 0;
 661:tmk_core/common/action.c ****   } else {
 662:tmk_core/common/action.c ****     if (event.pressed) {
 663:tmk_core/common/action.c ****         if (tap_count > 0) {
 664:tmk_core/common/action.c ****           retro_tapping_counter = 0;
 665:tmk_core/common/action.c ****         } else {
 666:tmk_core/common/action.c **** 
 667:tmk_core/common/action.c ****         }
 668:tmk_core/common/action.c ****     } else {
 669:tmk_core/common/action.c ****       if (tap_count > 0) {
 670:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 671:tmk_core/common/action.c ****       } else {
 672:tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 673:tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 674:tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 675:tmk_core/common/action.c ****         }
 676:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 677:tmk_core/common/action.c ****       }
 678:tmk_core/common/action.c ****     }
 679:tmk_core/common/action.c ****   }
 680:tmk_core/common/action.c ****   #endif
 681:tmk_core/common/action.c **** #endif
 682:tmk_core/common/action.c **** 
 683:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 684:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 685:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 686:tmk_core/common/action.c ****      */
 687:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 688:tmk_core/common/action.c ****         record->event.pressed = false;
 689:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 690:tmk_core/common/action.c ****         process_record(record);
 691:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 692:tmk_core/common/action.c ****     }
 693:tmk_core/common/action.c **** #endif
 694:tmk_core/common/action.c **** }
 695:tmk_core/common/action.c **** 
 696:tmk_core/common/action.c **** 
 697:tmk_core/common/action.c **** 
 698:tmk_core/common/action.c **** 
 699:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 700:tmk_core/common/action.c ****  *
 701:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 702:tmk_core/common/action.c ****  */
 703:tmk_core/common/action.c **** void register_code(uint8_t code)
 704:tmk_core/common/action.c **** {
 137               		.loc 1 704 0
 138               		.cfi_startproc
 139               	.LVL9:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 705:tmk_core/common/action.c ****     if (code == KC_NO) {
 144               		.loc 1 705 0
 145 0000 8823      		tst r24
 146 0002 01F4      		brne .+2
 147 0004 00C0      		rjmp .L4
 148 0006 682F      		mov r22,r24
 706:tmk_core/common/action.c ****         return;
 707:tmk_core/common/action.c ****     }
 708:tmk_core/common/action.c **** 
 709:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 710:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 149               		.loc 1 710 0
 150 0008 8238      		cpi r24,lo8(-126)
 151 000a 01F4      		brne .L7
 711:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 712:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 713:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 152               		.loc 1 713 0
 153 000c 0E94 0000 		call host_keyboard_leds
 154               	.LVL10:
 155 0010 81FD      		sbrc r24,1
 156 0012 00C0      		rjmp .L4
 157               	.LVL11:
 158               	.LBB46:
 159               	.LBB47:
 160               		.file 2 "tmk_core/common/action_util.h"
   1:tmk_core/common/action_util.h **** /*
   2:tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action_util.h **** 
   4:tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action_util.h **** (at your option) any later version.
   8:tmk_core/common/action_util.h **** 
   9:tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:tmk_core/common/action_util.h **** 
  14:tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action_util.h **** */
  17:tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:tmk_core/common/action_util.h **** 
  20:tmk_core/common/action_util.h **** #include <stdint.h>
  21:tmk_core/common/action_util.h **** #include "report.h"
  22:tmk_core/common/action_util.h **** 
  23:tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:tmk_core/common/action_util.h **** extern "C" {
  25:tmk_core/common/action_util.h **** #endif
  26:tmk_core/common/action_util.h **** 
  27:tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:tmk_core/common/action_util.h **** 
  29:tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:tmk_core/common/action_util.h **** 
  31:tmk_core/common/action_util.h **** /* key */
  32:tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 161               		.loc 2 33 0
 162 0014 69E3      		ldi r22,lo8(57)
 163 0016 8091 0000 		lds r24,keyboard_report
 164 001a 9091 0000 		lds r25,keyboard_report+1
 165 001e 0E94 0000 		call add_key_to_report
 166               	.LVL12:
 167               	.LBE47:
 168               	.LBE46:
 714:tmk_core/common/action.c **** #endif
 715:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 716:tmk_core/common/action.c ****         send_keyboard_report();
 169               		.loc 1 716 0
 170 0022 0E94 0000 		call send_keyboard_report
 171               	.LVL13:
 172               	.LBB48:
 173               	.LBB49:
 174               		.file 3 "d:\\program files\\msys2\\home\\bnguy\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\util\
   1:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 175               		.loc 3 187 0
 176 0026 2FEF      		ldi r18,lo8(319999)
 177 0028 81EE      		ldi r24,hi8(319999)
 178 002a 94E0      		ldi r25,hlo8(319999)
 179 002c 2150      	1:	subi r18,1
 180 002e 8040      		sbci r24,0
 181 0030 9040      		sbci r25,0
 182 0032 01F4      		brne 1b
 183 0034 00C0      		rjmp .
 184 0036 0000      		nop
 185               	.LVL14:
 186               	.LBE49:
 187               	.LBE48:
 188               	.LBB50:
 189               	.LBB51:
  34:tmk_core/common/action_util.h **** }
  35:tmk_core/common/action_util.h **** 
  36:tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 190               		.loc 2 37 0
 191 0038 69E3      		ldi r22,lo8(57)
 192 003a 00C0      		rjmp .L41
 193               	.LVL15:
 194               	.L7:
 195               	.LBE51:
 196               	.LBE50:
 717:tmk_core/common/action.c ****         wait_ms(100);
 718:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 719:tmk_core/common/action.c ****         send_keyboard_report();
 720:tmk_core/common/action.c ****     }
 721:tmk_core/common/action.c **** 
 722:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 197               		.loc 1 722 0
 198 003c 8338      		cpi r24,lo8(-125)
 199 003e 01F4      		brne .L9
 723:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 724:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 200               		.loc 1 724 0
 201 0040 0E94 0000 		call host_keyboard_leds
 202               	.LVL16:
 203 0044 80FD      		sbrc r24,0
 204 0046 00C0      		rjmp .L4
 205               	.LVL17:
 206               	.LBB52:
 207               	.LBB53:
  33:tmk_core/common/action_util.h **** }
 208               		.loc 2 33 0
 209 0048 63E5      		ldi r22,lo8(83)
 210 004a 8091 0000 		lds r24,keyboard_report
 211 004e 9091 0000 		lds r25,keyboard_report+1
 212 0052 0E94 0000 		call add_key_to_report
 213               	.LVL18:
 214               	.LBE53:
 215               	.LBE52:
 725:tmk_core/common/action.c **** #endif
 726:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 727:tmk_core/common/action.c ****         send_keyboard_report();
 216               		.loc 1 727 0
 217 0056 0E94 0000 		call send_keyboard_report
 218               	.LVL19:
 219               	.LBB54:
 220               	.LBB55:
 221               		.loc 3 187 0
 222 005a 2FEF      		ldi r18,lo8(319999)
 223 005c 81EE      		ldi r24,hi8(319999)
 224 005e 94E0      		ldi r25,hlo8(319999)
 225 0060 2150      	1:	subi r18,1
 226 0062 8040      		sbci r24,0
 227 0064 9040      		sbci r25,0
 228 0066 01F4      		brne 1b
 229 0068 00C0      		rjmp .
 230 006a 0000      		nop
 231               	.LVL20:
 232               	.LBE55:
 233               	.LBE54:
 234               	.LBB56:
 235               	.LBB57:
 236               		.loc 2 37 0
 237 006c 63E5      		ldi r22,lo8(83)
 238               	.LVL21:
 239               	.L41:
 240 006e 8091 0000 		lds r24,keyboard_report
 241 0072 9091 0000 		lds r25,keyboard_report+1
 242 0076 0E94 0000 		call del_key_from_report
 243               	.LVL22:
 244               	.L42:
 245               	.LBE57:
 246               	.LBE56:
 728:tmk_core/common/action.c ****         wait_ms(100);
 729:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 730:tmk_core/common/action.c ****         send_keyboard_report();
 247               		.loc 1 730 0
 248 007a 0C94 0000 		jmp send_keyboard_report
 249               	.LVL23:
 250               	.L9:
 731:tmk_core/common/action.c ****     }
 732:tmk_core/common/action.c **** 
 733:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 251               		.loc 1 733 0
 252 007e 8438      		cpi r24,lo8(-124)
 253 0080 01F4      		brne .L10
 734:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 735:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 254               		.loc 1 735 0
 255 0082 0E94 0000 		call host_keyboard_leds
 256               	.LVL24:
 257 0086 82FD      		sbrc r24,2
 258 0088 00C0      		rjmp .L4
 259               	.LVL25:
 260               	.LBB58:
 261               	.LBB59:
  33:tmk_core/common/action_util.h **** }
 262               		.loc 2 33 0
 263 008a 67E4      		ldi r22,lo8(71)
 264 008c 8091 0000 		lds r24,keyboard_report
 265 0090 9091 0000 		lds r25,keyboard_report+1
 266 0094 0E94 0000 		call add_key_to_report
 267               	.LVL26:
 268               	.LBE59:
 269               	.LBE58:
 736:tmk_core/common/action.c **** #endif
 737:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 738:tmk_core/common/action.c ****         send_keyboard_report();
 270               		.loc 1 738 0
 271 0098 0E94 0000 		call send_keyboard_report
 272               	.LVL27:
 273               	.LBB60:
 274               	.LBB61:
 275               		.loc 3 187 0
 276 009c 2FEF      		ldi r18,lo8(319999)
 277 009e 81EE      		ldi r24,hi8(319999)
 278 00a0 94E0      		ldi r25,hlo8(319999)
 279 00a2 2150      	1:	subi r18,1
 280 00a4 8040      		sbci r24,0
 281 00a6 9040      		sbci r25,0
 282 00a8 01F4      		brne 1b
 283 00aa 00C0      		rjmp .
 284 00ac 0000      		nop
 285               	.LVL28:
 286               	.LBE61:
 287               	.LBE60:
 288               	.LBB62:
 289               	.LBB63:
 290               		.loc 2 37 0
 291 00ae 67E4      		ldi r22,lo8(71)
 292 00b0 00C0      		rjmp .L41
 293               	.LVL29:
 294               	.L10:
 295               	.LBE63:
 296               	.LBE62:
 739:tmk_core/common/action.c ****         wait_ms(100);
 740:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 741:tmk_core/common/action.c ****         send_keyboard_report();
 742:tmk_core/common/action.c ****     }
 743:tmk_core/common/action.c **** #endif
 744:tmk_core/common/action.c **** 
 745:tmk_core/common/action.c ****     else if IS_KEY(code) {
 297               		.loc 1 745 0
 298 00b2 8CEF      		ldi r24,lo8(-4)
 299 00b4 860F      		add r24,r22
 300 00b6 813A      		cpi r24,lo8(-95)
 301 00b8 00F4      		brsh .L11
 302               	.LVL30:
 303               	.LBB64:
 304               	.LBB65:
  33:tmk_core/common/action_util.h **** }
 305               		.loc 2 33 0
 306 00ba 8091 0000 		lds r24,keyboard_report
 307 00be 9091 0000 		lds r25,keyboard_report+1
 308 00c2 0E94 0000 		call add_key_to_report
 309               	.LVL31:
 310 00c6 00C0      		rjmp .L42
 311               	.LVL32:
 312               	.L11:
 313               	.LBE65:
 314               	.LBE64:
 746:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 747:tmk_core/common/action.c ****         if (command_proc(code)) return;
 748:tmk_core/common/action.c **** 
 749:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 750:tmk_core/common/action.c **** /* TODO: remove
 751:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 752:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 753:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 754:tmk_core/common/action.c **** 
 755:tmk_core/common/action.c ****             add_key(code);
 756:tmk_core/common/action.c ****             send_keyboard_report();
 757:tmk_core/common/action.c **** 
 758:tmk_core/common/action.c ****             set_mods(tmp_mods);
 759:tmk_core/common/action.c ****             send_keyboard_report();
 760:tmk_core/common/action.c ****             oneshot_cancel();
 761:tmk_core/common/action.c ****         } else
 762:tmk_core/common/action.c **** */
 763:tmk_core/common/action.c **** #endif
 764:tmk_core/common/action.c ****         {
 765:tmk_core/common/action.c ****             add_key(code);
 766:tmk_core/common/action.c ****             send_keyboard_report();
 767:tmk_core/common/action.c ****         }
 768:tmk_core/common/action.c ****     }
 769:tmk_core/common/action.c ****     else if IS_MOD(code) {
 315               		.loc 1 769 0
 316 00c8 80E2      		ldi r24,lo8(32)
 317 00ca 860F      		add r24,r22
 318 00cc 8830      		cpi r24,lo8(8)
 319 00ce 00F4      		brsh .L12
 770:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 320               		.loc 1 770 0
 321 00d0 6770      		andi r22,lo8(7)
 322               	.LVL33:
 323 00d2 81E0      		ldi r24,lo8(1)
 324 00d4 00C0      		rjmp 2f
 325               		1:
 326 00d6 880F      		lsl r24
 327               		2:
 328 00d8 6A95      		dec r22
 329 00da 02F4      		brpl 1b
 330 00dc 0E94 0000 		call add_mods
 331               	.LVL34:
 332 00e0 00C0      		rjmp .L42
 333               	.LVL35:
 334               	.L12:
 771:tmk_core/common/action.c ****         send_keyboard_report();
 772:tmk_core/common/action.c ****     }
 773:tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 335               		.loc 1 773 0
 336 00e2 8BE5      		ldi r24,lo8(91)
 337 00e4 860F      		add r24,r22
 338 00e6 8330      		cpi r24,lo8(3)
 339 00e8 00F4      		brsh .L13
 774:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 340               		.loc 1 774 0
 341 00ea 653A      		cpi r22,lo8(-91)
 342 00ec 01F0      		breq .L16
 343               		.loc 1 774 0 is_stmt 0 discriminator 1
 344 00ee 663A      		cpi r22,lo8(-90)
 345 00f0 01F0      		breq .L17
 346               		.loc 1 774 0
 347 00f2 83E8      		ldi r24,lo8(-125)
 348 00f4 90E0      		ldi r25,0
 349 00f6 00C0      		rjmp .L14
 350               	.L16:
 351 00f8 81E8      		ldi r24,lo8(-127)
 352 00fa 90E0      		ldi r25,0
 353 00fc 00C0      		rjmp .L14
 354               	.L17:
 355 00fe 82E8      		ldi r24,lo8(-126)
 356 0100 90E0      		ldi r25,0
 357               	.L14:
 358               		.loc 1 774 0 discriminator 12
 359 0102 0C94 0000 		jmp host_system_send
 360               	.LVL36:
 361               	.L13:
 775:tmk_core/common/action.c ****     }
 776:tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 362               		.loc 1 776 0 is_stmt 1
 363 0106 88E5      		ldi r24,lo8(88)
 364 0108 860F      		add r24,r22
 365 010a 8731      		cpi r24,lo8(23)
 366 010c 00F0      		brlo .+2
 367 010e 00C0      		rjmp .L4
 777:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 368               		.loc 1 777 0
 369 0110 683A      		cpi r22,lo8(-88)
 370 0112 01F4      		brne .+2
 371 0114 00C0      		rjmp .L18
 372               		.loc 1 777 0 is_stmt 0 discriminator 1
 373 0116 693A      		cpi r22,lo8(-87)
 374 0118 01F4      		brne .+2
 375 011a 00C0      		rjmp .L19
 376               		.loc 1 777 0 discriminator 3
 377 011c 6A3A      		cpi r22,lo8(-86)
 378 011e 01F4      		brne .+2
 379 0120 00C0      		rjmp .L20
 380               		.loc 1 777 0 discriminator 5
 381 0122 6B3A      		cpi r22,lo8(-85)
 382 0124 01F4      		brne .+2
 383 0126 00C0      		rjmp .L21
 384               		.loc 1 777 0 discriminator 7
 385 0128 6C3A      		cpi r22,lo8(-84)
 386 012a 01F4      		brne .+2
 387 012c 00C0      		rjmp .L22
 388               		.loc 1 777 0 discriminator 9
 389 012e 6B3B      		cpi r22,lo8(-69)
 390 0130 01F4      		brne .+2
 391 0132 00C0      		rjmp .L23
 392               		.loc 1 777 0 discriminator 11
 393 0134 6C3B      		cpi r22,lo8(-68)
 394 0136 01F4      		brne .+2
 395 0138 00C0      		rjmp .L24
 396               		.loc 1 777 0 discriminator 13
 397 013a 6D3A      		cpi r22,lo8(-83)
 398 013c 01F4      		brne .+2
 399 013e 00C0      		rjmp .L25
 400               		.loc 1 777 0 discriminator 15
 401 0140 603B      		cpi r22,lo8(-80)
 402 0142 01F4      		brne .+2
 403 0144 00C0      		rjmp .L26
 404               		.loc 1 777 0 discriminator 17
 405 0146 6E3A      		cpi r22,lo8(-82)
 406 0148 01F4      		brne .+2
 407 014a 00C0      		rjmp .L27
 408               		.loc 1 777 0 discriminator 19
 409 014c 6F3A      		cpi r22,lo8(-81)
 410 014e 01F4      		brne .+2
 411 0150 00C0      		rjmp .L28
 412               		.loc 1 777 0 discriminator 21
 413 0152 613B      		cpi r22,lo8(-79)
 414 0154 01F4      		brne .+2
 415 0156 00C0      		rjmp .L29
 416               		.loc 1 777 0 discriminator 23
 417 0158 623B      		cpi r22,lo8(-78)
 418 015a 01F4      		brne .+2
 419 015c 00C0      		rjmp .L30
 420               		.loc 1 777 0 discriminator 25
 421 015e 633B      		cpi r22,lo8(-77)
 422 0160 01F4      		brne .+2
 423 0162 00C0      		rjmp .L31
 424               		.loc 1 777 0 discriminator 27
 425 0164 643B      		cpi r22,lo8(-76)
 426 0166 01F4      		brne .+2
 427 0168 00C0      		rjmp .L32
 428               		.loc 1 777 0 discriminator 29
 429 016a 653B      		cpi r22,lo8(-75)
 430 016c 01F4      		brne .+2
 431 016e 00C0      		rjmp .L33
 432               		.loc 1 777 0 discriminator 31
 433 0170 663B      		cpi r22,lo8(-74)
 434 0172 01F4      		brne .+2
 435 0174 00C0      		rjmp .L34
 436               		.loc 1 777 0 discriminator 33
 437 0176 673B      		cpi r22,lo8(-73)
 438 0178 01F4      		brne .+2
 439 017a 00C0      		rjmp .L35
 440               		.loc 1 777 0 discriminator 35
 441 017c 683B      		cpi r22,lo8(-72)
 442 017e 01F4      		brne .+2
 443 0180 00C0      		rjmp .L36
 444               		.loc 1 777 0 discriminator 37
 445 0182 693B      		cpi r22,lo8(-71)
 446 0184 01F4      		brne .+2
 447 0186 00C0      		rjmp .L37
 448               		.loc 1 777 0 discriminator 39
 449 0188 6D3B      		cpi r22,lo8(-67)
 450 018a 01F4      		brne .+2
 451 018c 00C0      		rjmp .L38
 452               		.loc 1 777 0 discriminator 41
 453 018e 6E3B      		cpi r22,lo8(-66)
 454 0190 01F4      		brne .+2
 455 0192 00C0      		rjmp .L39
 456               		.loc 1 777 0 discriminator 43
 457 0194 6A3B      		cpi r22,lo8(-70)
 458 0196 01F4      		brne .+2
 459 0198 00C0      		rjmp .L40
 460               		.loc 1 777 0
 461 019a 80E0      		ldi r24,0
 462 019c 90E0      		ldi r25,0
 463 019e 00C0      		rjmp .L15
 464               	.L18:
 465 01a0 82EE      		ldi r24,lo8(-30)
 466 01a2 90E0      		ldi r25,0
 467 01a4 00C0      		rjmp .L15
 468               	.L19:
 469 01a6 89EE      		ldi r24,lo8(-23)
 470 01a8 90E0      		ldi r25,0
 471 01aa 00C0      		rjmp .L15
 472               	.L20:
 473 01ac 8AEE      		ldi r24,lo8(-22)
 474 01ae 90E0      		ldi r25,0
 475 01b0 00C0      		rjmp .L15
 476               	.L21:
 477 01b2 85EB      		ldi r24,lo8(-75)
 478 01b4 90E0      		ldi r25,0
 479 01b6 00C0      		rjmp .L15
 480               	.L22:
 481 01b8 86EB      		ldi r24,lo8(-74)
 482 01ba 90E0      		ldi r25,0
 483 01bc 00C0      		rjmp .L15
 484               	.L23:
 485 01be 83EB      		ldi r24,lo8(-77)
 486 01c0 90E0      		ldi r25,0
 487 01c2 00C0      		rjmp .L15
 488               	.L24:
 489 01c4 84EB      		ldi r24,lo8(-76)
 490 01c6 90E0      		ldi r25,0
 491 01c8 00C0      		rjmp .L15
 492               	.L25:
 493 01ca 87EB      		ldi r24,lo8(-73)
 494 01cc 90E0      		ldi r25,0
 495 01ce 00C0      		rjmp .L15
 496               	.L26:
 497 01d0 8CEC      		ldi r24,lo8(-52)
 498 01d2 90E0      		ldi r25,0
 499 01d4 00C0      		rjmp .L15
 500               	.L27:
 501 01d6 8DEC      		ldi r24,lo8(-51)
 502 01d8 90E0      		ldi r25,0
 503 01da 00C0      		rjmp .L15
 504               	.L28:
 505 01dc 83E8      		ldi r24,lo8(-125)
 506 01de 91E0      		ldi r25,lo8(1)
 507 01e0 00C0      		rjmp .L15
 508               	.L29:
 509 01e2 8AE8      		ldi r24,lo8(-118)
 510 01e4 91E0      		ldi r25,lo8(1)
 511 01e6 00C0      		rjmp .L15
 512               	.L30:
 513 01e8 82E9      		ldi r24,lo8(-110)
 514 01ea 91E0      		ldi r25,lo8(1)
 515 01ec 00C0      		rjmp .L15
 516               	.L31:
 517 01ee 84E9      		ldi r24,lo8(-108)
 518 01f0 91E0      		ldi r25,lo8(1)
 519 01f2 00C0      		rjmp .L15
 520               	.L32:
 521 01f4 81E2      		ldi r24,lo8(33)
 522 01f6 92E0      		ldi r25,lo8(2)
 523 01f8 00C0      		rjmp .L15
 524               	.L33:
 525 01fa 83E2      		ldi r24,lo8(35)
 526 01fc 92E0      		ldi r25,lo8(2)
 527 01fe 00C0      		rjmp .L15
 528               	.L34:
 529 0200 84E2      		ldi r24,lo8(36)
 530 0202 92E0      		ldi r25,lo8(2)
 531 0204 00C0      		rjmp .L15
 532               	.L35:
 533 0206 85E2      		ldi r24,lo8(37)
 534 0208 92E0      		ldi r25,lo8(2)
 535 020a 00C0      		rjmp .L15
 536               	.L36:
 537 020c 86E2      		ldi r24,lo8(38)
 538 020e 92E0      		ldi r25,lo8(2)
 539 0210 00C0      		rjmp .L15
 540               	.L37:
 541 0212 87E2      		ldi r24,lo8(39)
 542 0214 92E0      		ldi r25,lo8(2)
 543 0216 00C0      		rjmp .L15
 544               	.L38:
 545 0218 8FE6      		ldi r24,lo8(111)
 546 021a 90E0      		ldi r25,0
 547 021c 00C0      		rjmp .L15
 548               	.L39:
 549 021e 80E7      		ldi r24,lo8(112)
 550 0220 90E0      		ldi r25,0
 551 0222 00C0      		rjmp .L15
 552               	.L40:
 553 0224 8AE2      		ldi r24,lo8(42)
 554 0226 92E0      		ldi r25,lo8(2)
 555               	.L15:
 556               		.loc 1 777 0 discriminator 92
 557 0228 0C94 0000 		jmp host_consumer_send
 558               	.LVL37:
 559               	.L4:
 560 022c 0895      		ret
 561               		.cfi_endproc
 562               	.LFE112:
 564               		.section	.text.unregister_code,"ax",@progbits
 565               	.global	unregister_code
 567               	unregister_code:
 568               	.LFB113:
 778:tmk_core/common/action.c ****     }
 779:tmk_core/common/action.c **** 
 780:tmk_core/common/action.c ****     #ifdef MOUSEKEY_ENABLE
 781:tmk_core/common/action.c ****       else if IS_MOUSEKEY(code) {
 782:tmk_core/common/action.c ****         mousekey_on(code);
 783:tmk_core/common/action.c ****         mousekey_send();
 784:tmk_core/common/action.c ****       }
 785:tmk_core/common/action.c ****     #endif
 786:tmk_core/common/action.c **** }
 787:tmk_core/common/action.c **** 
 788:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 789:tmk_core/common/action.c ****  *
 790:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 791:tmk_core/common/action.c ****  */
 792:tmk_core/common/action.c **** void unregister_code(uint8_t code)
 793:tmk_core/common/action.c **** {
 569               		.loc 1 793 0 is_stmt 1
 570               		.cfi_startproc
 571               	.LVL38:
 572               	/* prologue: function */
 573               	/* frame size = 0 */
 574               	/* stack size = 0 */
 575               	.L__stack_usage = 0
 794:tmk_core/common/action.c ****     if (code == KC_NO) {
 576               		.loc 1 794 0
 577 0000 8823      		tst r24
 578 0002 01F4      		brne .+2
 579 0004 00C0      		rjmp .L44
 580 0006 682F      		mov r22,r24
 795:tmk_core/common/action.c ****         return;
 796:tmk_core/common/action.c ****     }
 797:tmk_core/common/action.c **** 
 798:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 799:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 581               		.loc 1 799 0
 582 0008 8238      		cpi r24,lo8(-126)
 583 000a 01F4      		brne .L47
 800:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 801:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 802:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 584               		.loc 1 802 0
 585 000c 0E94 0000 		call host_keyboard_leds
 586               	.LVL39:
 587 0010 81FF      		sbrs r24,1
 588 0012 00C0      		rjmp .L44
 589               	.LVL40:
 590               	.LBB66:
 591               	.LBB67:
  33:tmk_core/common/action_util.h **** }
 592               		.loc 2 33 0
 593 0014 69E3      		ldi r22,lo8(57)
 594 0016 8091 0000 		lds r24,keyboard_report
 595 001a 9091 0000 		lds r25,keyboard_report+1
 596 001e 0E94 0000 		call add_key_to_report
 597               	.LVL41:
 598               	.LBE67:
 599               	.LBE66:
 803:tmk_core/common/action.c **** #endif
 804:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 805:tmk_core/common/action.c ****         send_keyboard_report();
 600               		.loc 1 805 0
 601 0022 0E94 0000 		call send_keyboard_report
 602               	.LVL42:
 603               	.LBB68:
 604               	.LBB69:
 605               		.loc 2 37 0
 606 0026 69E3      		ldi r22,lo8(57)
 607 0028 00C0      		rjmp .L63
 608               	.LVL43:
 609               	.L47:
 610               	.LBE69:
 611               	.LBE68:
 806:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 807:tmk_core/common/action.c ****         send_keyboard_report();
 808:tmk_core/common/action.c ****     }
 809:tmk_core/common/action.c **** 
 810:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 612               		.loc 1 810 0
 613 002a 8338      		cpi r24,lo8(-125)
 614 002c 01F4      		brne .L49
 811:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 812:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 615               		.loc 1 812 0
 616 002e 0E94 0000 		call host_keyboard_leds
 617               	.LVL44:
 618 0032 80FF      		sbrs r24,0
 619 0034 00C0      		rjmp .L44
 620               	.LVL45:
 621               	.LBB70:
 622               	.LBB71:
  33:tmk_core/common/action_util.h **** }
 623               		.loc 2 33 0
 624 0036 63E5      		ldi r22,lo8(83)
 625 0038 8091 0000 		lds r24,keyboard_report
 626 003c 9091 0000 		lds r25,keyboard_report+1
 627 0040 0E94 0000 		call add_key_to_report
 628               	.LVL46:
 629               	.LBE71:
 630               	.LBE70:
 813:tmk_core/common/action.c **** #endif
 814:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 815:tmk_core/common/action.c ****         send_keyboard_report();
 631               		.loc 1 815 0
 632 0044 0E94 0000 		call send_keyboard_report
 633               	.LVL47:
 634               	.LBB72:
 635               	.LBB73:
 636               		.loc 2 37 0
 637 0048 63E5      		ldi r22,lo8(83)
 638               	.LVL48:
 639               	.L63:
 640 004a 8091 0000 		lds r24,keyboard_report
 641 004e 9091 0000 		lds r25,keyboard_report+1
 642 0052 0E94 0000 		call del_key_from_report
 643               	.LVL49:
 644               	.L64:
 645               	.LBE73:
 646               	.LBE72:
 816:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 817:tmk_core/common/action.c ****         send_keyboard_report();
 647               		.loc 1 817 0
 648 0056 0C94 0000 		jmp send_keyboard_report
 649               	.LVL50:
 650               	.L49:
 818:tmk_core/common/action.c ****     }
 819:tmk_core/common/action.c **** 
 820:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 651               		.loc 1 820 0
 652 005a 8438      		cpi r24,lo8(-124)
 653 005c 01F4      		brne .L50
 821:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 822:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 654               		.loc 1 822 0
 655 005e 0E94 0000 		call host_keyboard_leds
 656               	.LVL51:
 657 0062 82FF      		sbrs r24,2
 658 0064 00C0      		rjmp .L44
 659               	.LVL52:
 660               	.LBB74:
 661               	.LBB75:
  33:tmk_core/common/action_util.h **** }
 662               		.loc 2 33 0
 663 0066 67E4      		ldi r22,lo8(71)
 664 0068 8091 0000 		lds r24,keyboard_report
 665 006c 9091 0000 		lds r25,keyboard_report+1
 666 0070 0E94 0000 		call add_key_to_report
 667               	.LVL53:
 668               	.LBE75:
 669               	.LBE74:
 823:tmk_core/common/action.c **** #endif
 824:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 825:tmk_core/common/action.c ****         send_keyboard_report();
 670               		.loc 1 825 0
 671 0074 0E94 0000 		call send_keyboard_report
 672               	.LVL54:
 673               	.LBB76:
 674               	.LBB77:
 675               		.loc 2 37 0
 676 0078 67E4      		ldi r22,lo8(71)
 677 007a 00C0      		rjmp .L63
 678               	.LVL55:
 679               	.L50:
 680               	.LBE77:
 681               	.LBE76:
 826:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 827:tmk_core/common/action.c ****         send_keyboard_report();
 828:tmk_core/common/action.c ****     }
 829:tmk_core/common/action.c **** #endif
 830:tmk_core/common/action.c **** 
 831:tmk_core/common/action.c ****     else if IS_KEY(code) {
 682               		.loc 1 831 0
 683 007c 8CEF      		ldi r24,lo8(-4)
 684 007e 860F      		add r24,r22
 685 0080 813A      		cpi r24,lo8(-95)
 686 0082 00F0      		brlo .L63
 832:tmk_core/common/action.c ****         del_key(code);
 833:tmk_core/common/action.c ****         send_keyboard_report();
 834:tmk_core/common/action.c ****     }
 835:tmk_core/common/action.c ****     else if IS_MOD(code) {
 687               		.loc 1 835 0
 688 0084 80E2      		ldi r24,lo8(32)
 689 0086 860F      		add r24,r22
 690 0088 8830      		cpi r24,lo8(8)
 691 008a 00F4      		brsh .L52
 836:tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 692               		.loc 1 836 0
 693 008c 6770      		andi r22,lo8(7)
 694               	.LVL56:
 695 008e 81E0      		ldi r24,lo8(1)
 696 0090 00C0      		rjmp 2f
 697               		1:
 698 0092 880F      		lsl r24
 699               		2:
 700 0094 6A95      		dec r22
 701 0096 02F4      		brpl 1b
 702 0098 0E94 0000 		call del_mods
 703               	.LVL57:
 704 009c 00C0      		rjmp .L64
 705               	.LVL58:
 706               	.L52:
 837:tmk_core/common/action.c ****         send_keyboard_report();
 838:tmk_core/common/action.c ****     }
 839:tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 707               		.loc 1 839 0
 708 009e 8BE5      		ldi r24,lo8(91)
 709 00a0 860F      		add r24,r22
 710 00a2 8330      		cpi r24,lo8(3)
 711 00a4 00F4      		brsh .L53
 840:tmk_core/common/action.c ****         host_system_send(0);
 712               		.loc 1 840 0
 713 00a6 80E0      		ldi r24,0
 714 00a8 90E0      		ldi r25,0
 715 00aa 0C94 0000 		jmp host_system_send
 716               	.LVL59:
 717               	.L53:
 841:tmk_core/common/action.c ****     }
 842:tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 718               		.loc 1 842 0
 719 00ae 685A      		subi r22,lo8(-(88))
 720               	.LVL60:
 721 00b0 6731      		cpi r22,lo8(23)
 722 00b2 00F4      		brsh .L44
 843:tmk_core/common/action.c ****         host_consumer_send(0);
 723               		.loc 1 843 0
 724 00b4 80E0      		ldi r24,0
 725 00b6 90E0      		ldi r25,0
 726 00b8 0C94 0000 		jmp host_consumer_send
 727               	.LVL61:
 728               	.L44:
 729 00bc 0895      		ret
 730               		.cfi_endproc
 731               	.LFE113:
 733               		.section	.text.tap_code,"ax",@progbits
 734               	.global	tap_code
 736               	tap_code:
 737               	.LFB114:
 844:tmk_core/common/action.c ****     }
 845:tmk_core/common/action.c ****     #ifdef MOUSEKEY_ENABLE
 846:tmk_core/common/action.c ****       else if IS_MOUSEKEY(code) {
 847:tmk_core/common/action.c ****         mousekey_off(code);
 848:tmk_core/common/action.c ****         mousekey_send();
 849:tmk_core/common/action.c ****       }
 850:tmk_core/common/action.c ****     #endif
 851:tmk_core/common/action.c **** }
 852:tmk_core/common/action.c **** 
 853:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 854:tmk_core/common/action.c ****  *
 855:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 856:tmk_core/common/action.c ****  */
 857:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 738               		.loc 1 857 0
 739               		.cfi_startproc
 740               	.LVL62:
 741 0000 CF93      		push r28
 742               	.LCFI4:
 743               		.cfi_def_cfa_offset 3
 744               		.cfi_offset 28, -2
 745               	/* prologue: function */
 746               	/* frame size = 0 */
 747               	/* stack size = 1 */
 748               	.L__stack_usage = 1
 749 0002 C82F      		mov r28,r24
 858:tmk_core/common/action.c ****   register_code(code);
 750               		.loc 1 858 0
 751 0004 0E94 0000 		call register_code
 752               	.LVL63:
 859:tmk_core/common/action.c ****   if (code == KC_CAPS) {
 753               		.loc 1 859 0
 754 0008 C933      		cpi r28,lo8(57)
 755 000a 01F4      		brne .L66
 756               	.LVL64:
 757               	.LBB78:
 758               	.LBB79:
 759               		.loc 3 187 0
 760 000c 2FEF      		ldi r18,lo8(639999)
 761 000e 83EC      		ldi r24,hi8(639999)
 762 0010 99E0      		ldi r25,hlo8(639999)
 763 0012 2150      	1:	subi r18,1
 764 0014 8040      		sbci r24,0
 765 0016 9040      		sbci r25,0
 766 0018 01F4      		brne 1b
 767 001a 00C0      		rjmp .
 768 001c 0000      		nop
 769               	.LVL65:
 770               	.L66:
 771               	.LBE79:
 772               	.LBE78:
 860:tmk_core/common/action.c ****     wait_ms(TAP_HOLD_CAPS_DELAY);
 861:tmk_core/common/action.c ****   }
 862:tmk_core/common/action.c ****   #if TAP_CODE_DELAY > 0
 863:tmk_core/common/action.c ****   else {
 864:tmk_core/common/action.c ****     wait_ms(TAP_CODE_DELAY);
 865:tmk_core/common/action.c ****   }
 866:tmk_core/common/action.c ****   #endif
 867:tmk_core/common/action.c ****   unregister_code(code);
 773               		.loc 1 867 0
 774 001e 8C2F      		mov r24,r28
 775               	/* epilogue start */
 868:tmk_core/common/action.c **** }
 776               		.loc 1 868 0
 777 0020 CF91      		pop r28
 778               	.LVL66:
 867:tmk_core/common/action.c **** }
 779               		.loc 1 867 0
 780 0022 0C94 0000 		jmp unregister_code
 781               	.LVL67:
 782               		.cfi_endproc
 783               	.LFE114:
 785               		.section	.text.register_mods,"ax",@progbits
 786               	.global	register_mods
 788               	register_mods:
 789               	.LFB115:
 869:tmk_core/common/action.c **** 
 870:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 871:tmk_core/common/action.c ****  *
 872:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 873:tmk_core/common/action.c ****  */
 874:tmk_core/common/action.c **** void register_mods(uint8_t mods)
 875:tmk_core/common/action.c **** {
 790               		.loc 1 875 0
 791               		.cfi_startproc
 792               	.LVL68:
 793               	/* prologue: function */
 794               	/* frame size = 0 */
 795               	/* stack size = 0 */
 796               	.L__stack_usage = 0
 876:tmk_core/common/action.c ****     if (mods) {
 797               		.loc 1 876 0
 798 0000 8823      		tst r24
 799 0002 01F0      		breq .L67
 877:tmk_core/common/action.c ****         add_mods(mods);
 800               		.loc 1 877 0
 801 0004 0E94 0000 		call add_mods
 802               	.LVL69:
 878:tmk_core/common/action.c ****         send_keyboard_report();
 803               		.loc 1 878 0
 804 0008 0C94 0000 		jmp send_keyboard_report
 805               	.LVL70:
 806               	.L67:
 807 000c 0895      		ret
 808               		.cfi_endproc
 809               	.LFE115:
 811               		.section	.text.unregister_mods,"ax",@progbits
 812               	.global	unregister_mods
 814               	unregister_mods:
 815               	.LFB116:
 879:tmk_core/common/action.c ****     }
 880:tmk_core/common/action.c **** }
 881:tmk_core/common/action.c **** 
 882:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 883:tmk_core/common/action.c ****  *
 884:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 885:tmk_core/common/action.c ****  */
 886:tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 887:tmk_core/common/action.c **** {
 816               		.loc 1 887 0
 817               		.cfi_startproc
 818               	.LVL71:
 819               	/* prologue: function */
 820               	/* frame size = 0 */
 821               	/* stack size = 0 */
 822               	.L__stack_usage = 0
 888:tmk_core/common/action.c ****     if (mods) {
 823               		.loc 1 888 0
 824 0000 8823      		tst r24
 825 0002 01F0      		breq .L69
 889:tmk_core/common/action.c ****         del_mods(mods);
 826               		.loc 1 889 0
 827 0004 0E94 0000 		call del_mods
 828               	.LVL72:
 890:tmk_core/common/action.c ****         send_keyboard_report();
 829               		.loc 1 890 0
 830 0008 0C94 0000 		jmp send_keyboard_report
 831               	.LVL73:
 832               	.L69:
 833 000c 0895      		ret
 834               		.cfi_endproc
 835               	.LFE116:
 837               		.section	.text.process_action,"ax",@progbits
 838               	.global	process_action
 840               	process_action:
 841               	.LFB111:
 198:tmk_core/common/action.c ****     keyevent_t event = record->event;
 842               		.loc 1 198 0
 843               		.cfi_startproc
 844               	.LVL74:
 845 0000 8F92      		push r8
 846               	.LCFI5:
 847               		.cfi_def_cfa_offset 3
 848               		.cfi_offset 8, -2
 849 0002 9F92      		push r9
 850               	.LCFI6:
 851               		.cfi_def_cfa_offset 4
 852               		.cfi_offset 9, -3
 853 0004 AF92      		push r10
 854               	.LCFI7:
 855               		.cfi_def_cfa_offset 5
 856               		.cfi_offset 10, -4
 857 0006 BF92      		push r11
 858               	.LCFI8:
 859               		.cfi_def_cfa_offset 6
 860               		.cfi_offset 11, -5
 861 0008 DF92      		push r13
 862               	.LCFI9:
 863               		.cfi_def_cfa_offset 7
 864               		.cfi_offset 13, -6
 865 000a EF92      		push r14
 866               	.LCFI10:
 867               		.cfi_def_cfa_offset 8
 868               		.cfi_offset 14, -7
 869 000c FF92      		push r15
 870               	.LCFI11:
 871               		.cfi_def_cfa_offset 9
 872               		.cfi_offset 15, -8
 873 000e 0F93      		push r16
 874               	.LCFI12:
 875               		.cfi_def_cfa_offset 10
 876               		.cfi_offset 16, -9
 877 0010 1F93      		push r17
 878               	.LCFI13:
 879               		.cfi_def_cfa_offset 11
 880               		.cfi_offset 17, -10
 881 0012 CF93      		push r28
 882               	.LCFI14:
 883               		.cfi_def_cfa_offset 12
 884               		.cfi_offset 28, -11
 885 0014 DF93      		push r29
 886               	.LCFI15:
 887               		.cfi_def_cfa_offset 13
 888               		.cfi_offset 29, -12
 889               	/* prologue: function */
 890               	/* frame size = 0 */
 891               	/* stack size = 11 */
 892               	.L__stack_usage = 11
 893 0016 7C01      		movw r14,r24
 894 0018 062F      		mov r16,r22
 895 001a C72F      		mov r28,r23
 896               	.LVL75:
 201:tmk_core/common/action.c **** #endif
 897               		.loc 1 201 0
 898 001c FC01      		movw r30,r24
 899 001e 1581      		ldd r17,Z+5
 900 0020 1295      		swap r17
 901 0022 1F70      		andi r17,lo8(15)
 902               	.LVL76:
 204:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 903               		.loc 1 204 0
 904 0024 D281      		ldd r29,Z+2
 905 0026 D111      		cpse r29,__zero_reg__
 206:tmk_core/common/action.c ****     }
 906               		.loc 1 206 0
 907 0028 0E94 0000 		call clear_weak_mods
 908               	.LVL77:
 909               	.L72:
 212:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 910               		.loc 1 212 0
 911 002c 0E94 0000 		call is_oneshot_layer_active
 912               	.LVL78:
 913 0030 8823      		tst r24
 914 0032 01F0      		breq .L152
 212:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 915               		.loc 1 212 0 is_stmt 0 discriminator 1
 916 0034 DD23      		tst r29
 917 0036 01F0      		breq .L152
 212:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 918               		.loc 1 212 0 discriminator 2
 919 0038 80E2      		ldi r24,lo8(32)
 920 003a 800F      		add r24,r16
 921 003c 8830      		cpi r24,lo8(8)
 922 003e 00F0      		brlo .L152
 213:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 923               		.loc 1 213 0 is_stmt 1
 924 0040 82E0      		ldi r24,lo8(2)
 925 0042 0E94 0000 		call clear_oneshot_layer_state
 926               	.LVL79:
 214:tmk_core/common/action.c ****     }
 927               		.loc 1 214 0
 928 0046 0E94 0000 		call is_oneshot_layer_active
 929               	.LVL80:
 930 004a 91E0      		ldi r25,lo8(1)
 931 004c D82E      		mov r13,r24
 932 004e D926      		eor r13,r25
 933               	.LVL81:
 934 0050 00C0      		rjmp .L73
 935               	.LVL82:
 936               	.L152:
 210:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 937               		.loc 1 210 0
 938 0052 D12C      		mov r13,__zero_reg__
 939               	.LVL83:
 940               	.L73:
 218:tmk_core/common/action.c ****         /* Key and Mods */
 941               		.loc 1 218 0
 942 0054 BC2E      		mov r11,r28
 943 0056 B294      		swap r11
 944 0058 8FE0      		ldi r24,lo8(15)
 945 005a B822      		and r11,r24
 946 005c 8B2D      		mov r24,r11
 947 005e 90E0      		ldi r25,0
 948 0060 FC01      		movw r30,r24
 949 0062 E050      		subi r30,lo8(-(gs(.L76)))
 950 0064 F040      		sbci r31,hi8(-(gs(.L76)))
 951 0066 0C94 0000 		jmp __tablejump2__
 952               		.section	.progmem.gcc_sw_table.process_action,"a",@progbits
 953               		.p2align	1
 954               	.L76:
 955 0000 0000      		.word gs(.L75)
 956 0002 0000      		.word gs(.L75)
 957 0004 0000      		.word gs(.L77)
 958 0006 0000      		.word gs(.L77)
 959 0008 0000      		.word gs(.L78)
 960 000a 0000      		.word gs(.L74)
 961 000c 0000      		.word gs(.L74)
 962 000e 0000      		.word gs(.L74)
 963 0010 0000      		.word gs(.L79)
 964 0012 0000      		.word gs(.L74)
 965 0014 0000      		.word gs(.L80)
 966 0016 0000      		.word gs(.L80)
 967 0018 0000      		.word gs(.L81)
 968 001a 0000      		.word gs(.L74)
 969 001c 0000      		.word gs(.L74)
 970 001e 0000      		.word gs(.L82)
 971               		.section	.text.process_action
 972               	.L75:
 973               	.LBB80:
 223:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 974               		.loc 1 223 0
 975 006a 8C2F      		mov r24,r28
 976 006c 807F      		andi r24,lo8(-16)
 977 006e CF70      		andi r28,lo8(15)
 978               	.LVL84:
 979 0070 8823      		tst r24
 980 0072 01F0      		breq .L84
 223:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 981               		.loc 1 223 0 is_stmt 0 discriminator 2
 982 0074 C295      		swap r28
 983 0076 C07F      		andi r28,lo8(-16)
 984               	.L84:
 985               	.LVL85:
 225:tmk_core/common/action.c ****                     if (mods) {
 986               		.loc 1 225 0 is_stmt 1 discriminator 4
 987 0078 DD23      		tst r29
 988 007a 01F0      		breq .L85
 226:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 989               		.loc 1 226 0
 990 007c CC23      		tst r28
 991 007e 01F4      		brne .+2
 992 0080 00C0      		rjmp .L180
 227:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 993               		.loc 1 227 0
 994 0082 80E2      		ldi r24,lo8(32)
 995 0084 800F      		add r24,r16
 996 0086 8830      		cpi r24,lo8(8)
 997 0088 00F0      		brlo .L87
 227:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 998               		.loc 1 227 0 is_stmt 0 discriminator 1
 999 008a 0111      		cpse r16,__zero_reg__
 1000 008c 00C0      		rjmp .L88
 1001               	.L87:
 231:tmk_core/common/action.c ****                         } else {
 1002               		.loc 1 231 0 is_stmt 1
 1003 008e 8C2F      		mov r24,r28
 1004 0090 0E94 0000 		call add_mods
 1005               	.LVL86:
 1006 0094 00C0      		rjmp .L89
 1007               	.L88:
 233:tmk_core/common/action.c ****                         }
 1008               		.loc 1 233 0
 1009 0096 8C2F      		mov r24,r28
 1010 0098 0E94 0000 		call add_weak_mods
 1011               	.LVL87:
 1012               	.L89:
 235:tmk_core/common/action.c ****                     }
 1013               		.loc 1 235 0
 1014 009c 0E94 0000 		call send_keyboard_report
 1015               	.LVL88:
 1016 00a0 00C0      		rjmp .L180
 1017               	.L85:
 239:tmk_core/common/action.c ****                     if (mods) {
 1018               		.loc 1 239 0
 1019 00a2 802F      		mov r24,r16
 1020 00a4 0E94 0000 		call unregister_code
 1021               	.LVL89:
 240:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1022               		.loc 1 240 0
 1023 00a8 CC23      		tst r28
 1024 00aa 01F4      		brne .+2
 1025 00ac 00C0      		rjmp .L74
 241:tmk_core/common/action.c ****                             del_mods(mods);
 1026               		.loc 1 241 0
 1027 00ae 80E2      		ldi r24,lo8(32)
 1028 00b0 800F      		add r24,r16
 1029 00b2 8830      		cpi r24,lo8(8)
 1030 00b4 00F0      		brlo .L91
 241:tmk_core/common/action.c ****                             del_mods(mods);
 1031               		.loc 1 241 0 is_stmt 0 discriminator 1
 1032 00b6 0111      		cpse r16,__zero_reg__
 1033 00b8 00C0      		rjmp .L92
 1034               	.L91:
 242:tmk_core/common/action.c ****                         } else {
 1035               		.loc 1 242 0 is_stmt 1
 1036 00ba 8C2F      		mov r24,r28
 1037 00bc 0E94 0000 		call del_mods
 1038               	.LVL90:
 1039 00c0 00C0      		rjmp .L93
 1040               	.L92:
 244:tmk_core/common/action.c ****                         }
 1041               		.loc 1 244 0
 1042 00c2 8C2F      		mov r24,r28
 1043 00c4 0E94 0000 		call del_weak_mods
 1044               	.LVL91:
 1045               	.L93:
 246:tmk_core/common/action.c ****                     }
 1046               		.loc 1 246 0
 1047 00c8 0E94 0000 		call send_keyboard_report
 1048               	.LVL92:
 1049 00cc 00C0      		rjmp .L74
 1050               	.LVL93:
 1051               	.L77:
 1052               	.LBE80:
 1053               	.LBB81:
 255:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1054               		.loc 1 255 0
 1055 00ce 8C2F      		mov r24,r28
 1056 00d0 807F      		andi r24,lo8(-16)
 1057 00d2 CF70      		andi r28,lo8(15)
 1058               	.LVL94:
 1059 00d4 8032      		cpi r24,lo8(32)
 1060 00d6 01F0      		breq .L95
 255:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1061               		.loc 1 255 0 is_stmt 0 discriminator 2
 1062 00d8 C295      		swap r28
 1063 00da C07F      		andi r28,lo8(-16)
 1064               	.L95:
 1065               	.LVL95:
 257:tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 1066               		.loc 1 257 0 is_stmt 1 discriminator 4
 1067 00dc 0023      		tst r16
 1068 00de 01F0      		breq .L97
 1069 00e0 0130      		cpi r16,lo8(1)
 1070 00e2 01F0      		breq .L98
 1071 00e4 00C0      		rjmp .L186
 1072               	.L97:
 261:tmk_core/common/action.c ****                             if (tap_count == 0) {
 1073               		.loc 1 261 0
 1074 00e6 DD23      		tst r29
 1075 00e8 01F0      		breq .L99
 262:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1076               		.loc 1 262 0
 1077 00ea 1123      		tst r17
 1078 00ec 01F0      		breq .L101
 265:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1079               		.loc 1 265 0
 1080 00ee 1130      		cpi r17,lo8(1)
 1081 00f0 01F4      		brne .L101
 267:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1082               		.loc 1 267 0
 1083 00f2 0E94 0000 		call get_oneshot_mods
 1084               	.LVL96:
 1085 00f6 8C2B      		or r24,r28
 1086 00f8 0E94 0000 		call set_oneshot_mods
 1087               	.LVL97:
 1088 00fc 00C0      		rjmp .L74
 1089               	.L101:
 276:tmk_core/common/action.c ****                             }
 1090               		.loc 1 276 0
 1091 00fe 0E94 0000 		call get_oneshot_mods
 1092               	.LVL98:
 1093 0102 8C2B      		or r24,r28
 1094 0104 00C0      		rjmp .L181
 1095               	.L99:
 279:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1096               		.loc 1 279 0
 1097 0106 1123      		tst r17
 1098 0108 01F0      		breq .L185
 282:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1099               		.loc 1 282 0
 1100 010a 1130      		cpi r17,lo8(1)
 1101 010c 01F4      		brne .+2
 1102 010e 00C0      		rjmp .L74
 1103               	.L185:
 294:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1104               		.loc 1 294 0
 1105 0110 0E94 0000 		call clear_oneshot_mods
 1106               	.LVL99:
 1107 0114 00C0      		rjmp .L108
 1108               	.L98:
 301:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1109               		.loc 1 301 0
 1110 0116 DD23      		tst r29
 1111 0118 01F0      		breq .L104
 302:tmk_core/common/action.c ****                                 register_mods(mods);
 1112               		.loc 1 302 0
 1113 011a 1630      		cpi r17,lo8(6)
 1114 011c 00F0      		brlo .+2
 1115 011e 00C0      		rjmp .L74
 1116 0120 00C0      		rjmp .L106
 1117               	.L104:
 306:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1118               		.loc 1 306 0
 1119 0122 1530      		cpi r17,lo8(5)
 1120 0124 00F0      		brlo .+2
 1121 0126 00C0      		rjmp .L74
 1122 0128 00C0      		rjmp .L108
 1123               	.L186:
 312:tmk_core/common/action.c ****                             if (tap_count > 0) {
 1124               		.loc 1 312 0
 1125 012a DD23      		tst r29
 1126 012c 01F0      		breq .L105
 313:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1127               		.loc 1 313 0
 1128 012e 1123      		tst r17
 1129 0130 01F0      		breq .L106
 315:tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1130               		.loc 1 315 0
 1131 0132 F701      		movw r30,r14
 1132 0134 8581      		ldd r24,Z+5
 1133 0136 80FF      		sbrs r24,0
 1134 0138 00C0      		rjmp .L180
 318:tmk_core/common/action.c ****                                     register_mods(mods);
 1135               		.loc 1 318 0
 1136 013a 8F70      		andi r24,lo8(15)
 1137 013c 8583      		std Z+5,r24
 1138               	.L106:
 328:tmk_core/common/action.c ****                             }
 1139               		.loc 1 328 0
 1140 013e 8C2F      		mov r24,r28
 1141 0140 00C0      		rjmp .L181
 1142               	.L105:
 331:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1143               		.loc 1 331 0
 1144 0142 1111      		cpse r17,__zero_reg__
 1145 0144 00C0      		rjmp .L144
 1146               	.L108:
 336:tmk_core/common/action.c ****                             }
 1147               		.loc 1 336 0
 1148 0146 8C2F      		mov r24,r28
 1149 0148 00C0      		rjmp .L182
 1150               	.LVL100:
 1151               	.L78:
 1152               	.LBE81:
 347:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1153               		.loc 1 347 0
 1154 014a 8C2F      		mov r24,r28
 1155 014c 8695      		lsr r24
 1156 014e 8695      		lsr r24
 1157 0150 8370      		andi r24,lo8(3)
 1158 0152 01F0      		breq .L109
 1159 0154 8130      		cpi r24,lo8(1)
 1160 0156 01F0      		breq .L110
 1161 0158 00C0      		rjmp .L74
 1162               	.L109:
 349:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1163               		.loc 1 349 0
 1164 015a DD23      		tst r29
 1165 015c 01F0      		breq .L111
 350:tmk_core/common/action.c ****                     } else {
 1166               		.loc 1 350 0
 1167 015e 802F      		mov r24,r16
 1168 0160 9C2F      		mov r25,r28
 1169 0162 9370      		andi r25,lo8(3)
 1170 0164 00C0      		rjmp .L183
 1171               	.L111:
 352:tmk_core/common/action.c ****                     }
 1172               		.loc 1 352 0
 1173 0166 80E0      		ldi r24,0
 1174 0168 90E0      		ldi r25,0
 1175               	.L183:
 1176 016a 0E94 0000 		call host_system_send
 1177               	.LVL101:
 1178 016e 00C0      		rjmp .L145
 1179               	.L110:
 356:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1180               		.loc 1 356 0
 1181 0170 DD23      		tst r29
 1182 0172 01F0      		breq .L113
 357:tmk_core/common/action.c ****                     } else {
 1183               		.loc 1 357 0
 1184 0174 802F      		mov r24,r16
 1185 0176 9C2F      		mov r25,r28
 1186 0178 9370      		andi r25,lo8(3)
 1187 017a 00C0      		rjmp .L184
 1188               	.L113:
 359:tmk_core/common/action.c ****                     }
 1189               		.loc 1 359 0
 1190 017c 80E0      		ldi r24,0
 1191 017e 90E0      		ldi r25,0
 1192               	.L184:
 1193 0180 0E94 0000 		call host_consumer_send
 1194               	.LVL102:
 1195 0184 00C0      		rjmp .L145
 1196               	.L79:
 405:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1197               		.loc 1 405 0
 1198 0186 8C2F      		mov r24,r28
 1199 0188 8370      		andi r24,lo8(3)
 1200 018a 01F0      		breq .+2
 1201 018c 00C0      		rjmp .L114
 407:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1202               		.loc 1 407 0
 1203 018e D111      		cpse r29,__zero_reg__
 1204 0190 00C0      		rjmp .L146
 1205               	.LVL103:
 1206               	.LBB82:
 408:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 1207               		.loc 1 408 0
 1208 0192 202F      		mov r18,r16
 1209 0194 2295      		swap r18
 1210 0196 2695      		lsr r18
 1211 0198 2770      		andi r18,lo8(7)
 409:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1212               		.loc 1 409 0
 1213 019a 220F      		lsl r18
 1214 019c 220F      		lsl r18
 1215 019e 602F      		mov r22,r16
 1216 01a0 6F70      		andi r22,lo8(15)
 1217 01a2 862F      		mov r24,r22
 1218 01a4 90E0      		ldi r25,0
 1219 01a6 A0E0      		ldi r26,0
 1220 01a8 B0E0      		ldi r27,0
 1221 01aa 4C01      		movw r8,r24
 1222 01ac 5D01      		movw r10,r26
 1223 01ae 022E      		mov r0,r18
 1224 01b0 00C0      		rjmp 2f
 1225               		1:
 1226 01b2 880C      		lsl r8
 1227 01b4 991C      		rol r9
 1228 01b6 AA1C      		rol r10
 1229 01b8 BB1C      		rol r11
 1230               		2:
 1231 01ba 0A94      		dec r0
 1232 01bc 02F4      		brpl 1b
 1233               	.LVL104:
 410:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1234               		.loc 1 410 0
 1235 01be 04FF      		sbrs r16,4
 1236 01c0 00C0      		rjmp .L153
 410:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1237               		.loc 1 410 0 is_stmt 0 discriminator 1
 1238 01c2 8FE0      		ldi r24,lo8(15)
 1239 01c4 90E0      		ldi r25,0
 1240 01c6 A0E0      		ldi r26,0
 1241 01c8 B0E0      		ldi r27,0
 1242 01ca 00C0      		rjmp 2f
 1243               		1:
 1244 01cc 880F      		lsl r24
 1245 01ce 991F      		rol r25
 1246 01d0 AA1F      		rol r26
 1247 01d2 BB1F      		rol r27
 1248               		2:
 1249 01d4 2A95      		dec r18
 1250 01d6 02F4      		brpl 1b
 1251 01d8 8095      		com r24
 1252 01da 9095      		com r25
 1253 01dc A095      		com r26
 1254 01de B095      		com r27
 1255 01e0 00C0      		rjmp .L116
 1256               	.L153:
 410:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1257               		.loc 1 410 0
 1258 01e2 80E0      		ldi r24,0
 1259 01e4 90E0      		ldi r25,0
 1260 01e6 DC01      		movw r26,r24
 1261               	.L116:
 1262               	.LVL105:
 411:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1263               		.loc 1 411 0 is_stmt 1 discriminator 4
 1264 01e8 C695      		lsr r28
 1265 01ea C695      		lsr r28
 1266               	.LVL106:
 1267 01ec C370      		andi r28,lo8(3)
 1268 01ee BC01      		movw r22,r24
 1269 01f0 CD01      		movw r24,r26
 1270 01f2 6829      		or r22,r8
 1271 01f4 7929      		or r23,r9
 1272 01f6 8A29      		or r24,r10
 1273 01f8 9B29      		or r25,r11
 1274 01fa C230      		cpi r28,lo8(2)
 1275 01fc 01F0      		breq .L118
 1276 01fe 00F4      		brsh .L119
 1277 0200 C130      		cpi r28,lo8(1)
 1278 0202 01F0      		breq .L120
 412:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1279               		.loc 1 412 0 discriminator 4
 1280 0204 0E94 0000 		call default_layer_and
 1281               	.LVL107:
 1282 0208 00C0      		rjmp .L146
 1283               	.LVL108:
 1284               	.L120:
 413:tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 1285               		.loc 1 413 0
 1286 020a 0E94 0000 		call default_layer_or
 1287               	.LVL109:
 1288 020e 00C0      		rjmp .L146
 1289               	.LVL110:
 1290               	.L118:
 414:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_set(bits | mask); break;
 1291               		.loc 1 414 0
 1292 0210 0E94 0000 		call default_layer_xor
 1293               	.LVL111:
 1294 0214 00C0      		rjmp .L146
 1295               	.LVL112:
 1296               	.L119:
 415:tmk_core/common/action.c ****                     }
 1297               		.loc 1 415 0
 1298 0216 0E94 0000 		call default_layer_set
 1299               	.LVL113:
 1300 021a 00C0      		rjmp .L146
 1301               	.LVL114:
 1302               	.L114:
 1303               	.LBE82:
 420:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1304               		.loc 1 420 0
 1305 021c DD23      		tst r29
 1306 021e 01F0      		breq .L121
 420:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1307               		.loc 1 420 0 is_stmt 0 discriminator 1
 1308 0220 8C2F      		mov r24,r28
 1309 0222 8170      		andi r24,lo8(1)
 1310 0224 00C0      		rjmp .L122
 1311               	.L121:
 420:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1312               		.loc 1 420 0 discriminator 2
 1313 0226 8695      		lsr r24
 1314               	.L122:
 420:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1315               		.loc 1 420 0 discriminator 4
 1316 0228 8823      		tst r24
 1317 022a 01F4      		brne .+2
 1318 022c 00C0      		rjmp .L146
 1319               	.LVL115:
 1320               	.LBB83:
 422:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 1321               		.loc 1 422 0 is_stmt 1
 1322 022e 202F      		mov r18,r16
 1323 0230 2295      		swap r18
 1324 0232 2695      		lsr r18
 1325 0234 2770      		andi r18,lo8(7)
 423:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1326               		.loc 1 423 0
 1327 0236 220F      		lsl r18
 1328 0238 220F      		lsl r18
 1329 023a 602F      		mov r22,r16
 1330 023c 6F70      		andi r22,lo8(15)
 1331 023e 862F      		mov r24,r22
 1332 0240 90E0      		ldi r25,0
 1333 0242 A0E0      		ldi r26,0
 1334 0244 B0E0      		ldi r27,0
 1335 0246 4C01      		movw r8,r24
 1336 0248 5D01      		movw r10,r26
 1337 024a 022E      		mov r0,r18
 1338 024c 00C0      		rjmp 2f
 1339               		1:
 1340 024e 880C      		lsl r8
 1341 0250 991C      		rol r9
 1342 0252 AA1C      		rol r10
 1343 0254 BB1C      		rol r11
 1344               		2:
 1345 0256 0A94      		dec r0
 1346 0258 02F4      		brpl 1b
 1347               	.LVL116:
 424:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1348               		.loc 1 424 0
 1349 025a 04FF      		sbrs r16,4
 1350 025c 00C0      		rjmp .L154
 424:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1351               		.loc 1 424 0 is_stmt 0 discriminator 1
 1352 025e 8FE0      		ldi r24,lo8(15)
 1353 0260 90E0      		ldi r25,0
 1354 0262 A0E0      		ldi r26,0
 1355 0264 B0E0      		ldi r27,0
 1356 0266 00C0      		rjmp 2f
 1357               		1:
 1358 0268 880F      		lsl r24
 1359 026a 991F      		rol r25
 1360 026c AA1F      		rol r26
 1361 026e BB1F      		rol r27
 1362               		2:
 1363 0270 2A95      		dec r18
 1364 0272 02F4      		brpl 1b
 1365 0274 8095      		com r24
 1366 0276 9095      		com r25
 1367 0278 A095      		com r26
 1368 027a B095      		com r27
 1369 027c 00C0      		rjmp .L123
 1370               	.L154:
 424:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1371               		.loc 1 424 0
 1372 027e 80E0      		ldi r24,0
 1373 0280 90E0      		ldi r25,0
 1374 0282 DC01      		movw r26,r24
 1375               	.L123:
 1376               	.LVL117:
 425:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1377               		.loc 1 425 0 is_stmt 1 discriminator 4
 1378 0284 C695      		lsr r28
 1379 0286 C695      		lsr r28
 1380               	.LVL118:
 1381 0288 C370      		andi r28,lo8(3)
 1382 028a BC01      		movw r22,r24
 1383 028c CD01      		movw r24,r26
 1384 028e 6829      		or r22,r8
 1385 0290 7929      		or r23,r9
 1386 0292 8A29      		or r24,r10
 1387 0294 9B29      		or r25,r11
 1388 0296 C230      		cpi r28,lo8(2)
 1389 0298 01F0      		breq .L125
 1390 029a 00F4      		brsh .L126
 1391 029c C130      		cpi r28,lo8(1)
 1392 029e 01F0      		breq .L127
 426:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1393               		.loc 1 426 0 discriminator 4
 1394 02a0 0E94 0000 		call layer_and
 1395               	.LVL119:
 1396 02a4 00C0      		rjmp .L146
 1397               	.LVL120:
 1398               	.L127:
 427:tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 1399               		.loc 1 427 0
 1400 02a6 0E94 0000 		call layer_or
 1401               	.LVL121:
 1402 02aa 00C0      		rjmp .L146
 1403               	.LVL122:
 1404               	.L125:
 428:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_state_set(bits | mask); break;
 1405               		.loc 1 428 0
 1406 02ac 0E94 0000 		call layer_xor
 1407               	.LVL123:
 1408 02b0 00C0      		rjmp .L146
 1409               	.LVL124:
 1410               	.L126:
 429:tmk_core/common/action.c ****                     }
 1411               		.loc 1 429 0
 1412 02b2 0E94 0000 		call layer_state_set
 1413               	.LVL125:
 1414 02b6 00C0      		rjmp .L146
 1415               	.LVL126:
 1416               	.L80:
 1417               	.LBE83:
 437:tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 1418               		.loc 1 437 0
 1419 02b8 802F      		mov r24,r16
 1420 02ba 90E0      		ldi r25,0
 1421 02bc FC01      		movw r30,r24
 1422 02be E05E      		subi r30,-32
 1423 02c0 F109      		sbc r31,__zero_reg__
 1424 02c2 E531      		cpi r30,21
 1425 02c4 F105      		cpc r31,__zero_reg__
 1426 02c6 00F0      		brlo .+2
 1427 02c8 00C0      		rjmp .L128
 1428 02ca E050      		subi r30,lo8(-(gs(.L130)))
 1429 02cc F040      		sbci r31,hi8(-(gs(.L130)))
 1430 02ce 0C94 0000 		jmp __tablejump2__
 1431               		.section	.progmem.gcc_sw_table.process_action
 1432               		.p2align	1
 1433               	.L130:
 1434 0020 0000      		.word gs(.L129)
 1435 0022 0000      		.word gs(.L129)
 1436 0024 0000      		.word gs(.L129)
 1437 0026 0000      		.word gs(.L129)
 1438 0028 0000      		.word gs(.L129)
 1439 002a 0000      		.word gs(.L129)
 1440 002c 0000      		.word gs(.L129)
 1441 002e 0000      		.word gs(.L129)
 1442 0030 0000      		.word gs(.L129)
 1443 0032 0000      		.word gs(.L129)
 1444 0034 0000      		.word gs(.L129)
 1445 0036 0000      		.word gs(.L129)
 1446 0038 0000      		.word gs(.L129)
 1447 003a 0000      		.word gs(.L129)
 1448 003c 0000      		.word gs(.L129)
 1449 003e 0000      		.word gs(.L129)
 1450 0040 0000      		.word gs(.L131)
 1451 0042 0000      		.word gs(.L132)
 1452 0044 0000      		.word gs(.L133)
 1453 0046 0000      		.word gs(.L134)
 1454 0048 0000      		.word gs(.L135)
 1455               		.section	.text.process_action
 1456               	.L129:
 1457 02d2 0F70      		andi r16,lo8(15)
 1458               	.LVL127:
 1459 02d4 8C2F      		mov r24,r28
 1460 02d6 8F71      		andi r24,lo8(31)
 440:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1461               		.loc 1 440 0
 1462 02d8 DD23      		tst r29
 1463 02da 01F0      		breq .L136
 441:tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1464               		.loc 1 441 0
 1465 02dc 0E94 0000 		call layer_on
 1466               	.LVL128:
 442:tmk_core/common/action.c ****                     } else {
 1467               		.loc 1 442 0
 1468 02e0 802F      		mov r24,r16
 1469               	.LVL129:
 1470               	.L181:
 1471 02e2 0E94 0000 		call register_mods
 1472               	.LVL130:
 1473 02e6 00C0      		rjmp .L74
 1474               	.LVL131:
 1475               	.L136:
 444:tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1476               		.loc 1 444 0
 1477 02e8 0E94 0000 		call layer_off
 1478               	.LVL132:
 445:tmk_core/common/action.c ****                     }
 1479               		.loc 1 445 0
 1480 02ec 802F      		mov r24,r16
 1481               	.LVL133:
 1482               	.L182:
 1483 02ee 0E94 0000 		call unregister_mods
 1484               	.LVL134:
 1485 02f2 00C0      		rjmp .L74
 1486               	.L131:
 450:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1487               		.loc 1 450 0
 1488 02f4 DD23      		tst r29
 1489 02f6 01F0      		breq .L137
 451:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1490               		.loc 1 451 0
 1491 02f8 1530      		cpi r17,lo8(5)
 1492 02fa 00F0      		brlo .+2
 1493 02fc 00C0      		rjmp .L74
 1494               	.L138:
 452:tmk_core/common/action.c ****                         }
 1495               		.loc 1 452 0
 1496 02fe 8C2F      		mov r24,r28
 1497 0300 8F71      		andi r24,lo8(31)
 1498 0302 0E94 0000 		call layer_invert
 1499               	.LVL135:
 1500 0306 00C0      		rjmp .L74
 1501               	.L137:
 455:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1502               		.loc 1 455 0
 1503 0308 1630      		cpi r17,lo8(6)
 1504 030a 00F0      		brlo .+2
 1505 030c 00C0      		rjmp .L74
 1506 030e 00C0      		rjmp .L138
 1507               	.L132:
 461:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1508               		.loc 1 461 0
 1509 0310 DD23      		tst r29
 1510 0312 01F0      		breq .L139
 1511               	.L140:
 461:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1512               		.loc 1 461 0 is_stmt 0 discriminator 1
 1513 0314 8C2F      		mov r24,r28
 1514 0316 8F71      		andi r24,lo8(31)
 1515 0318 0E94 0000 		call layer_on
 1516               	.LVL136:
 1517 031c 00C0      		rjmp .L74
 1518               	.L133:
 465:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1519               		.loc 1 465 0 is_stmt 1
 1520 031e DD23      		tst r29
 1521 0320 01F0      		breq .L140
 1522               	.L139:
 462:tmk_core/common/action.c ****                     break;
 1523               		.loc 1 462 0
 1524 0322 8C2F      		mov r24,r28
 1525 0324 8F71      		andi r24,lo8(31)
 1526 0326 0E94 0000 		call layer_off
 1527               	.LVL137:
 1528 032a 00C0      		rjmp .L74
 1529               	.L134:
 469:tmk_core/common/action.c ****                                     layer_clear();
 1530               		.loc 1 469 0
 1531 032c DD23      		tst r29
 1532 032e 01F0      		breq .L141
 469:tmk_core/common/action.c ****                                     layer_clear();
 1533               		.loc 1 469 0 is_stmt 0 discriminator 1
 1534 0330 8C2F      		mov r24,r28
 1535 0332 8F71      		andi r24,lo8(31)
 1536 0334 0E94 0000 		call layer_move
 1537               	.LVL138:
 1538 0338 00C0      		rjmp .L74
 1539               	.L141:
 470:tmk_core/common/action.c ****                     break;
 1540               		.loc 1 470 0 is_stmt 1
 1541 033a 0E94 0000 		call layer_clear
 1542               	.LVL139:
 1543 033e 00C0      		rjmp .L74
 1544               	.L135:
 498:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1545               		.loc 1 498 0
 1546 0340 DD23      		tst r29
 1547 0342 01F0      		breq .L142
 499:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1548               		.loc 1 499 0
 1549 0344 CF71      		andi r28,lo8(31)
 1550               	.LVL140:
 1551 0346 8C2F      		mov r24,r28
 1552 0348 0E94 0000 		call layer_on
 1553               	.LVL141:
 500:tmk_core/common/action.c ****                     } else {
 1554               		.loc 1 500 0
 1555 034c 63E0      		ldi r22,lo8(3)
 1556 034e 8C2F      		mov r24,r28
 1557 0350 0E94 0000 		call set_oneshot_layer
 1558               	.LVL142:
 1559 0354 00C0      		rjmp .L74
 1560               	.LVL143:
 1561               	.L142:
 502:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1562               		.loc 1 502 0
 1563 0356 81E0      		ldi r24,lo8(1)
 1564 0358 0E94 0000 		call clear_oneshot_layer_state
 1565               	.LVL144:
 503:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1566               		.loc 1 503 0
 1567 035c 1230      		cpi r17,lo8(2)
 1568 035e 00F0      		brlo .L74
 504:tmk_core/common/action.c ****                         }
 1569               		.loc 1 504 0
 1570 0360 82E0      		ldi r24,lo8(2)
 1571 0362 0E94 0000 		call clear_oneshot_layer_state
 1572               	.LVL145:
 1573 0366 00C0      		rjmp .L74
 1574               	.L128:
 512:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1575               		.loc 1 512 0
 1576 0368 DD23      		tst r29
 1577 036a 01F0      		breq .L143
 513:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1578               		.loc 1 513 0
 1579 036c 1123      		tst r17
 1580 036e 01F0      		breq .L140
 1581               	.L180:
 515:tmk_core/common/action.c ****                         } else {
 1582               		.loc 1 515 0
 1583 0370 802F      		mov r24,r16
 1584 0372 0E94 0000 		call register_code
 1585               	.LVL146:
 1586 0376 00C0      		rjmp .L74
 1587               	.L143:
 521:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1588               		.loc 1 521 0
 1589 0378 1123      		tst r17
 1590 037a 01F0      		breq .L139
 523:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1591               		.loc 1 523 0
 1592 037c 0933      		cpi r16,lo8(57)
 1593 037e 01F4      		brne .L144
 1594               	.LVL147:
 1595               	.LBB84:
 1596               	.LBB85:
 1597               		.loc 3 187 0
 1598 0380 FFEF      		ldi r31,lo8(639999)
 1599 0382 23EC      		ldi r18,hi8(639999)
 1600 0384 89E0      		ldi r24,hlo8(639999)
 1601 0386 F150      	1:	subi r31,1
 1602 0388 2040      		sbci r18,0
 1603 038a 8040      		sbci r24,0
 1604 038c 01F4      		brne 1b
 1605 038e 00C0      		rjmp .
 1606 0390 0000      		nop
 1607               	.LVL148:
 1608               	.L144:
 1609               	.LBE85:
 1610               	.LBE84:
 526:tmk_core/common/action.c ****                         } else {
 1611               		.loc 1 526 0
 1612 0392 802F      		mov r24,r16
 1613 0394 0E94 0000 		call unregister_code
 1614               	.LVL149:
 1615 0398 00C0      		rjmp .L74
 1616               	.L81:
 540:tmk_core/common/action.c ****             break;
 1617               		.loc 1 540 0
 1618 039a 4C2F      		mov r20,r28
 1619 039c 4F70      		andi r20,lo8(15)
 1620 039e 602F      		mov r22,r16
 1621 03a0 C701      		movw r24,r14
 1622 03a2 0E94 0000 		call action_get_macro
 1623               	.LVL150:
 1624 03a6 0E94 0000 		call action_macro_play
 1625               	.LVL151:
 541:tmk_core/common/action.c **** #endif
 1626               		.loc 1 541 0
 1627 03aa 00C0      		rjmp .L145
 1628               	.L82:
 635:tmk_core/common/action.c ****             break;
 1629               		.loc 1 635 0
 1630 03ac 4C2F      		mov r20,r28
 1631 03ae 4F70      		andi r20,lo8(15)
 1632 03b0 602F      		mov r22,r16
 1633 03b2 C701      		movw r24,r14
 1634 03b4 0E94 0000 		call action_function
 1635               	.LVL152:
 636:tmk_core/common/action.c **** #endif
 1636               		.loc 1 636 0
 1637 03b8 00C0      		rjmp .L145
 1638               	.L74:
 644:tmk_core/common/action.c ****         case ACT_LAYER:
 1639               		.loc 1 644 0
 1640 03ba 98E0      		ldi r25,lo8(8)
 1641 03bc B916      		cp r11,r25
 1642 03be 01F0      		breq .L146
 1643 03c0 B916      		cp r11,r25
 1644 03c2 00F0      		brlo .L145
 1645 03c4 86EF      		ldi r24,lo8(-10)
 1646 03c6 8B0D      		add r24,r11
 1647 03c8 8230      		cpi r24,lo8(2)
 1648 03ca 00F4      		brsh .L145
 1649               	.L146:
 650:tmk_core/common/action.c ****             break;
 1650               		.loc 1 650 0
 1651 03cc 0E94 0000 		call host_keyboard_leds
 1652               	.LVL153:
 1653 03d0 0E94 0000 		call led_set
 1654               	.LVL154:
 1655               	.L145:
 687:tmk_core/common/action.c ****         record->event.pressed = false;
 1656               		.loc 1 687 0
 1657 03d4 DD20      		tst r13
 1658 03d6 01F0      		breq .L71
 687:tmk_core/common/action.c ****         record->event.pressed = false;
 1659               		.loc 1 687 0 is_stmt 0 discriminator 1
 1660 03d8 0E94 0000 		call get_oneshot_layer_state
 1661               	.LVL155:
 1662 03dc 80FD      		sbrc r24,0
 1663 03de 00C0      		rjmp .L71
 688:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1664               		.loc 1 688 0 is_stmt 1
 1665 03e0 F701      		movw r30,r14
 1666 03e2 1282      		std Z+2,__zero_reg__
 689:tmk_core/common/action.c ****         process_record(record);
 1667               		.loc 1 689 0
 1668 03e4 0E94 0000 		call get_oneshot_layer
 1669               	.LVL156:
 1670 03e8 0E94 0000 		call layer_on
 1671               	.LVL157:
 690:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1672               		.loc 1 690 0
 1673 03ec C701      		movw r24,r14
 1674 03ee 0E94 0000 		call process_record
 1675               	.LVL158:
 691:tmk_core/common/action.c ****     }
 1676               		.loc 1 691 0
 1677 03f2 0E94 0000 		call get_oneshot_layer
 1678               	.LVL159:
 1679               	/* epilogue start */
 694:tmk_core/common/action.c **** 
 1680               		.loc 1 694 0
 1681 03f6 DF91      		pop r29
 1682               	.LVL160:
 1683 03f8 CF91      		pop r28
 1684               	.LVL161:
 1685 03fa 1F91      		pop r17
 1686               	.LVL162:
 1687 03fc 0F91      		pop r16
 1688 03fe FF90      		pop r15
 1689 0400 EF90      		pop r14
 1690               	.LVL163:
 1691 0402 DF90      		pop r13
 1692               	.LVL164:
 1693 0404 BF90      		pop r11
 1694 0406 AF90      		pop r10
 1695 0408 9F90      		pop r9
 1696 040a 8F90      		pop r8
 691:tmk_core/common/action.c ****     }
 1697               		.loc 1 691 0
 1698 040c 0C94 0000 		jmp layer_off
 1699               	.LVL165:
 1700               	.L71:
 1701               	/* epilogue start */
 694:tmk_core/common/action.c **** 
 1702               		.loc 1 694 0
 1703 0410 DF91      		pop r29
 1704               	.LVL166:
 1705 0412 CF91      		pop r28
 1706               	.LVL167:
 1707 0414 1F91      		pop r17
 1708               	.LVL168:
 1709 0416 0F91      		pop r16
 1710 0418 FF90      		pop r15
 1711 041a EF90      		pop r14
 1712               	.LVL169:
 1713 041c DF90      		pop r13
 1714               	.LVL170:
 1715 041e BF90      		pop r11
 1716 0420 AF90      		pop r10
 1717 0422 9F90      		pop r9
 1718 0424 8F90      		pop r8
 1719 0426 0895      		ret
 1720               		.cfi_endproc
 1721               	.LFE111:
 1723               		.section	.text.process_record,"ax",@progbits
 1724               	.global	process_record
 1726               	process_record:
 1727               	.LFB110:
 176:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1728               		.loc 1 176 0
 1729               		.cfi_startproc
 1730               	.LVL171:
 1731 0000 0F93      		push r16
 1732               	.LCFI16:
 1733               		.cfi_def_cfa_offset 3
 1734               		.cfi_offset 16, -2
 1735 0002 1F93      		push r17
 1736               	.LCFI17:
 1737               		.cfi_def_cfa_offset 4
 1738               		.cfi_offset 17, -3
 1739 0004 CF93      		push r28
 1740               	.LCFI18:
 1741               		.cfi_def_cfa_offset 5
 1742               		.cfi_offset 28, -4
 1743 0006 DF93      		push r29
 1744               	.LCFI19:
 1745               		.cfi_def_cfa_offset 6
 1746               		.cfi_offset 29, -5
 1747               	/* prologue: function */
 1748               	/* frame size = 0 */
 1749               	/* stack size = 4 */
 1750               	.L__stack_usage = 4
 1751 0008 EC01      		movw r28,r24
 1752 000a 9881      		ld r25,Y
 1753 000c 8981      		ldd r24,Y+1
 1754               	.LVL172:
 1755               	.LBB88:
 1756               	.LBB89:
 1757               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** 
  25:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:tmk_core/common/keyboard.h **** extern "C" {
  27:tmk_core/common/keyboard.h **** #endif
  28:tmk_core/common/keyboard.h **** 
  29:tmk_core/common/keyboard.h **** /* key matrix position */
  30:tmk_core/common/keyboard.h **** typedef struct {
  31:tmk_core/common/keyboard.h ****     uint8_t col;
  32:tmk_core/common/keyboard.h ****     uint8_t row;
  33:tmk_core/common/keyboard.h **** } keypos_t;
  34:tmk_core/common/keyboard.h **** 
  35:tmk_core/common/keyboard.h **** /* key event */
  36:tmk_core/common/keyboard.h **** typedef struct {
  37:tmk_core/common/keyboard.h ****     keypos_t key;
  38:tmk_core/common/keyboard.h ****     bool     pressed;
  39:tmk_core/common/keyboard.h ****     uint16_t time;
  40:tmk_core/common/keyboard.h **** } keyevent_t;
  41:tmk_core/common/keyboard.h **** 
  42:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:tmk_core/common/keyboard.h **** 
  45:tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:tmk_core/common/keyboard.h ****  */
  49:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1758               		.loc 4 49 0
 1759 000e 2B81      		ldd r18,Y+3
 1760 0010 3C81      		ldd r19,Y+4
 1761 0012 232B      		or r18,r19
 1762 0014 01F0      		breq .L192
 1763 0016 8F3F      		cpi r24,lo8(-1)
 1764 0018 01F4      		brne .L193
 1765 001a 81E0      		ldi r24,lo8(1)
 1766 001c 9F3F      		cpi r25,lo8(-1)
 1767 001e 01F4      		brne .L193
 1768 0020 00C0      		rjmp .L188
 1769               	.L192:
 1770 0022 81E0      		ldi r24,lo8(1)
 1771 0024 00C0      		rjmp .L188
 1772               	.L193:
 1773 0026 80E0      		ldi r24,0
 1774               	.L188:
 1775               	.LBE89:
 1776               	.LBE88:
 177:tmk_core/common/action.c **** 
 1777               		.loc 1 177 0
 1778 0028 80FD      		sbrc r24,0
 1779 002a 00C0      		rjmp .L187
 179:tmk_core/common/action.c ****         return;
 1780               		.loc 1 179 0
 1781 002c CE01      		movw r24,r28
 1782 002e 0E94 0000 		call process_record_quantum
 1783               	.LVL173:
 1784 0032 8823      		tst r24
 1785 0034 01F0      		breq .L187
 182:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 1786               		.loc 1 182 0
 1787 0036 6881      		ld r22,Y
 1788 0038 7981      		ldd r23,Y+1
 1789 003a 8A81      		ldd r24,Y+2
 1790 003c 0E94 0000 		call store_or_get_action
 1791               	.LVL174:
 1792 0040 8C01      		movw r16,r24
 1793               	.LVL175:
 185:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 1794               		.loc 1 185 0
 1795 0042 0E94 0000 		call layer_debug
 1796               	.LVL176:
 186:tmk_core/common/action.c **** #endif
 1797               		.loc 1 186 0
 1798 0046 0E94 0000 		call default_layer_debug
 1799               	.LVL177:
 190:tmk_core/common/action.c **** }
 1800               		.loc 1 190 0
 1801 004a B801      		movw r22,r16
 1802 004c CE01      		movw r24,r28
 1803 004e 0E94 0000 		call process_action
 1804               	.LVL178:
 1805               	.L187:
 1806               	/* epilogue start */
 191:tmk_core/common/action.c **** 
 1807               		.loc 1 191 0
 1808 0052 DF91      		pop r29
 1809 0054 CF91      		pop r28
 1810               	.LVL179:
 1811 0056 1F91      		pop r17
 1812 0058 0F91      		pop r16
 1813               	.LVL180:
 1814 005a 0895      		ret
 1815               		.cfi_endproc
 1816               	.LFE110:
 1818               		.section	.text.process_record_nocache,"ax",@progbits
 1819               	.global	process_record_nocache
 1821               	process_record_nocache:
 1822               	.LFB107:
 130:tmk_core/common/action.c ****     disable_action_cache = true;
 1823               		.loc 1 130 0
 1824               		.cfi_startproc
 1825               	.LVL181:
 1826               	/* prologue: function */
 1827               	/* frame size = 0 */
 1828               	/* stack size = 0 */
 1829               	.L__stack_usage = 0
 131:tmk_core/common/action.c ****     process_record(record);
 1830               		.loc 1 131 0
 1831 0000 21E0      		ldi r18,lo8(1)
 1832 0002 2093 0000 		sts disable_action_cache,r18
 132:tmk_core/common/action.c ****     disable_action_cache = false;
 1833               		.loc 1 132 0
 1834 0006 0E94 0000 		call process_record
 1835               	.LVL182:
 133:tmk_core/common/action.c **** }
 1836               		.loc 1 133 0
 1837 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1838 000e 0895      		ret
 1839               		.cfi_endproc
 1840               	.LFE107:
 1842               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1843               	.global	clear_keyboard_but_mods_and_keys
 1845               	clear_keyboard_but_mods_and_keys:
 1846               	.LFB119:
 891:tmk_core/common/action.c ****     }
 892:tmk_core/common/action.c **** }
 893:tmk_core/common/action.c **** 
 894:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 895:tmk_core/common/action.c ****  *
 896:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 897:tmk_core/common/action.c ****  */
 898:tmk_core/common/action.c **** void clear_keyboard(void)
 899:tmk_core/common/action.c **** {
 900:tmk_core/common/action.c ****     clear_mods();
 901:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 902:tmk_core/common/action.c **** }
 903:tmk_core/common/action.c **** 
 904:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 905:tmk_core/common/action.c ****  *
 906:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 907:tmk_core/common/action.c ****  */
 908:tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 909:tmk_core/common/action.c **** {
 910:tmk_core/common/action.c ****     clear_keys();
 911:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 912:tmk_core/common/action.c **** }
 913:tmk_core/common/action.c **** 
 914:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 915:tmk_core/common/action.c ****  *
 916:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 917:tmk_core/common/action.c ****  */
 918:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys()
 919:tmk_core/common/action.c **** {
 1847               		.loc 1 919 0
 1848               		.cfi_startproc
 1849               	/* prologue: function */
 1850               	/* frame size = 0 */
 1851               	/* stack size = 0 */
 1852               	.L__stack_usage = 0
 920:tmk_core/common/action.c ****     clear_weak_mods();
 1853               		.loc 1 920 0
 1854 0000 0E94 0000 		call clear_weak_mods
 1855               	.LVL183:
 921:tmk_core/common/action.c ****     clear_macro_mods();
 1856               		.loc 1 921 0
 1857 0004 0E94 0000 		call clear_macro_mods
 1858               	.LVL184:
 922:tmk_core/common/action.c ****     send_keyboard_report();
 1859               		.loc 1 922 0
 1860 0008 0E94 0000 		call send_keyboard_report
 1861               	.LVL185:
 923:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 924:tmk_core/common/action.c ****     mousekey_clear();
 925:tmk_core/common/action.c ****     mousekey_send();
 926:tmk_core/common/action.c **** #endif
 927:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 928:tmk_core/common/action.c ****     host_system_send(0);
 1862               		.loc 1 928 0
 1863 000c 80E0      		ldi r24,0
 1864 000e 90E0      		ldi r25,0
 1865 0010 0E94 0000 		call host_system_send
 1866               	.LVL186:
 929:tmk_core/common/action.c ****     host_consumer_send(0);
 1867               		.loc 1 929 0
 1868 0014 80E0      		ldi r24,0
 1869 0016 90E0      		ldi r25,0
 1870 0018 0C94 0000 		jmp host_consumer_send
 1871               	.LVL187:
 1872               		.cfi_endproc
 1873               	.LFE119:
 1875               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1876               	.global	clear_keyboard_but_mods
 1878               	clear_keyboard_but_mods:
 1879               	.LFB118:
 909:tmk_core/common/action.c ****     clear_keys();
 1880               		.loc 1 909 0
 1881               		.cfi_startproc
 1882               	/* prologue: function */
 1883               	/* frame size = 0 */
 1884               	/* stack size = 0 */
 1885               	.L__stack_usage = 0
 1886               	.LBB90:
 1887               	.LBB91:
  38:tmk_core/common/action_util.h **** }
  39:tmk_core/common/action_util.h **** 
  40:tmk_core/common/action_util.h **** inline void clear_keys(void) {
  41:tmk_core/common/action_util.h ****   clear_keys_from_report(keyboard_report);
 1888               		.loc 2 41 0
 1889 0000 8091 0000 		lds r24,keyboard_report
 1890 0004 9091 0000 		lds r25,keyboard_report+1
 1891 0008 0E94 0000 		call clear_keys_from_report
 1892               	.LVL188:
 1893               	.LBE91:
 1894               	.LBE90:
 911:tmk_core/common/action.c **** }
 1895               		.loc 1 911 0
 1896 000c 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1897               	.LVL189:
 1898               		.cfi_endproc
 1899               	.LFE118:
 1901               		.section	.text.clear_keyboard,"ax",@progbits
 1902               	.global	clear_keyboard
 1904               	clear_keyboard:
 1905               	.LFB117:
 899:tmk_core/common/action.c ****     clear_mods();
 1906               		.loc 1 899 0
 1907               		.cfi_startproc
 1908               	/* prologue: function */
 1909               	/* frame size = 0 */
 1910               	/* stack size = 0 */
 1911               	.L__stack_usage = 0
 900:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1912               		.loc 1 900 0
 1913 0000 0E94 0000 		call clear_mods
 1914               	.LVL190:
 901:tmk_core/common/action.c **** }
 1915               		.loc 1 901 0
 1916 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1917               	.LVL191:
 1918               		.cfi_endproc
 1919               	.LFE117:
 1921               		.section	.text.is_tap_action,"ax",@progbits
 1922               	.global	is_tap_action
 1924               	is_tap_action:
 1925               	.LFB121:
 930:tmk_core/common/action.c **** #endif
 931:tmk_core/common/action.c **** }
 932:tmk_core/common/action.c **** 
 933:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 934:tmk_core/common/action.c ****  *
 935:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 936:tmk_core/common/action.c ****  */
 937:tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 938:tmk_core/common/action.c **** {
 939:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 940:tmk_core/common/action.c ****     return is_tap_action(action);
 941:tmk_core/common/action.c **** }
 942:tmk_core/common/action.c **** 
 943:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 944:tmk_core/common/action.c ****  *
 945:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 946:tmk_core/common/action.c ****  */
 947:tmk_core/common/action.c **** bool is_tap_action(action_t action)
 948:tmk_core/common/action.c **** {
 1926               		.loc 1 948 0
 1927               		.cfi_startproc
 1928               	.LVL192:
 1929               	/* prologue: function */
 1930               	/* frame size = 0 */
 1931               	/* stack size = 0 */
 1932               	.L__stack_usage = 0
 949:tmk_core/common/action.c ****     switch (action.kind.id) {
 1933               		.loc 1 949 0
 1934 0000 E92F      		mov r30,r25
 1935 0002 E295      		swap r30
 1936 0004 EF70      		andi r30,lo8(15)
 1937 0006 4E2F      		mov r20,r30
 1938 0008 50E0      		ldi r21,0
 1939 000a FA01      		movw r30,r20
 1940 000c 3297      		sbiw r30,2
 1941 000e EE30      		cpi r30,14
 1942 0010 F105      		cpc r31,__zero_reg__
 1943 0012 00F4      		brsh .L213
 1944 0014 E050      		subi r30,lo8(-(gs(.L207)))
 1945 0016 F040      		sbci r31,hi8(-(gs(.L207)))
 1946 0018 0C94 0000 		jmp __tablejump2__
 1947               		.section	.progmem.gcc_sw_table.is_tap_action,"a",@progbits
 1948               		.p2align	1
 1949               	.L207:
 1950 0000 0000      		.word gs(.L206)
 1951 0002 0000      		.word gs(.L206)
 1952 0004 0000      		.word gs(.L213)
 1953 0006 0000      		.word gs(.L213)
 1954 0008 0000      		.word gs(.L208)
 1955 000a 0000      		.word gs(.L213)
 1956 000c 0000      		.word gs(.L213)
 1957 000e 0000      		.word gs(.L213)
 1958 0010 0000      		.word gs(.L206)
 1959 0012 0000      		.word gs(.L206)
 1960 0014 0000      		.word gs(.L209)
 1961 0016 0000      		.word gs(.L213)
 1962 0018 0000      		.word gs(.L213)
 1963 001a 0000      		.word gs(.L209)
 1964               		.section	.text.is_tap_action
 1965               	.L206:
 950:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 951:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 952:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 953:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 954:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1966               		.loc 1 954 0
 1967 001c 803F      		cpi r24,lo8(-16)
 1968 001e 01F0      		breq .L215
 1969 0020 00F4      		brsh .L211
 1970 0022 803E      		cpi r24,lo8(-32)
 1971 0024 00F4      		brsh .L213
 1972 0026 00C0      		rjmp .L215
 1973               	.L211:
 1974 0028 843F      		cpi r24,lo8(-12)
 1975 002a 01F4      		brne .L213
 1976 002c 00C0      		rjmp .L215
 1977               	.L208:
 955:tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 956:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 957:tmk_core/common/action.c ****                 case OP_ONESHOT:
 958:tmk_core/common/action.c ****                     return true;
 959:tmk_core/common/action.c ****             }
 960:tmk_core/common/action.c ****             return false;
 961:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 962:tmk_core/common/action.c ****             switch (action.swap.code) {
 1978               		.loc 1 962 0
 1979 002e 803E      		cpi r24,lo8(-32)
 1980 0030 00F0      		brlo .L215
 1981 0032 813F      		cpi r24,lo8(-15)
 1982 0034 01F4      		brne .L213
 1983 0036 00C0      		rjmp .L215
 1984               	.L209:
 963:tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 964:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 965:tmk_core/common/action.c ****                     return true;
 966:tmk_core/common/action.c ****             }
 967:tmk_core/common/action.c ****             return false;
 968:tmk_core/common/action.c ****         case ACT_MACRO:
 969:tmk_core/common/action.c ****         case ACT_FUNCTION:
 970:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 1985               		.loc 1 970 0
 1986 0038 93FB      		bst r25,3
 1987 003a 8827      		clr r24
 1988 003c 80F9      		bld r24,0
 1989               	.LVL193:
 1990 003e 0895      		ret
 1991               	.LVL194:
 1992               	.L213:
 971:tmk_core/common/action.c ****             return false;
 972:tmk_core/common/action.c ****     }
 973:tmk_core/common/action.c ****     return false;
 1993               		.loc 1 973 0
 1994 0040 80E0      		ldi r24,0
 1995               	.LVL195:
 1996 0042 0895      		ret
 1997               	.LVL196:
 1998               	.L215:
 965:tmk_core/common/action.c ****             }
 1999               		.loc 1 965 0
 2000 0044 81E0      		ldi r24,lo8(1)
 2001               	.LVL197:
 974:tmk_core/common/action.c **** }
 2002               		.loc 1 974 0
 2003 0046 0895      		ret
 2004               		.cfi_endproc
 2005               	.LFE121:
 2007               		.section	.text.is_tap_key,"ax",@progbits
 2008               	.global	is_tap_key
 2010               	is_tap_key:
 2011               	.LFB120:
 938:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2012               		.loc 1 938 0
 2013               		.cfi_startproc
 2014               	.LVL198:
 2015               	/* prologue: function */
 2016               	/* frame size = 0 */
 2017               	/* stack size = 0 */
 2018               	.L__stack_usage = 0
 939:tmk_core/common/action.c ****     return is_tap_action(action);
 2019               		.loc 1 939 0
 2020 0000 0E94 0000 		call layer_switch_get_action
 2021               	.LVL199:
 940:tmk_core/common/action.c **** }
 2022               		.loc 1 940 0
 2023 0004 0E94 0000 		call is_tap_action
 2024               	.LVL200:
 941:tmk_core/common/action.c **** 
 2025               		.loc 1 941 0
 2026 0008 0895      		ret
 2027               		.cfi_endproc
 2028               	.LFE120:
 2030               		.section	.text.debug_event,"ax",@progbits
 2031               	.global	debug_event
 2033               	debug_event:
 2034               	.LFB122:
 975:tmk_core/common/action.c **** 
 976:tmk_core/common/action.c **** 
 977:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 978:tmk_core/common/action.c ****  *
 979:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 980:tmk_core/common/action.c ****  */
 981:tmk_core/common/action.c **** void debug_event(keyevent_t event)
 982:tmk_core/common/action.c **** {
 2035               		.loc 1 982 0
 2036               		.cfi_startproc
 2037 0000 CF93      		push r28
 2038               	.LCFI20:
 2039               		.cfi_def_cfa_offset 3
 2040               		.cfi_offset 28, -2
 2041 0002 DF93      		push r29
 2042               	.LCFI21:
 2043               		.cfi_def_cfa_offset 4
 2044               		.cfi_offset 29, -3
 2045 0004 00D0      		rcall .
 2046 0006 00D0      		rcall .
 2047 0008 1F92      		push __zero_reg__
 2048               	.LCFI22:
 2049               		.cfi_def_cfa_offset 9
 2050 000a CDB7      		in r28,__SP_L__
 2051 000c DEB7      		in r29,__SP_H__
 2052               	.LCFI23:
 2053               		.cfi_def_cfa_register 28
 2054               	/* prologue: function */
 2055               	/* frame size = 5 */
 2056               	/* stack size = 7 */
 2057               	.L__stack_usage = 7
 2058               	/* epilogue start */
 983:tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 984:tmk_core/common/action.c **** }
 2059               		.loc 1 984 0
 2060 000e 0F90      		pop __tmp_reg__
 2061 0010 0F90      		pop __tmp_reg__
 2062 0012 0F90      		pop __tmp_reg__
 2063 0014 0F90      		pop __tmp_reg__
 2064 0016 0F90      		pop __tmp_reg__
 2065 0018 DF91      		pop r29
 2066 001a CF91      		pop r28
 2067 001c 0895      		ret
 2068               		.cfi_endproc
 2069               	.LFE122:
 2071               		.section	.text.debug_record,"ax",@progbits
 2072               	.global	debug_record
 2074               	debug_record:
 2075               	.LFB123:
 985:tmk_core/common/action.c **** 
 986:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 987:tmk_core/common/action.c ****  *
 988:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 989:tmk_core/common/action.c ****  */
 990:tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 991:tmk_core/common/action.c **** {
 2076               		.loc 1 991 0
 2077               		.cfi_startproc
 2078 0000 CF93      		push r28
 2079               	.LCFI24:
 2080               		.cfi_def_cfa_offset 3
 2081               		.cfi_offset 28, -2
 2082 0002 DF93      		push r29
 2083               	.LCFI25:
 2084               		.cfi_def_cfa_offset 4
 2085               		.cfi_offset 29, -3
 2086 0004 00D0      		rcall .
 2087 0006 00D0      		rcall .
 2088 0008 00D0      		rcall .
 2089               	.LCFI26:
 2090               		.cfi_def_cfa_offset 10
 2091 000a CDB7      		in r28,__SP_L__
 2092 000c DEB7      		in r29,__SP_H__
 2093               	.LCFI27:
 2094               		.cfi_def_cfa_register 28
 2095               	/* prologue: function */
 2096               	/* frame size = 6 */
 2097               	/* stack size = 8 */
 2098               	.L__stack_usage = 8
 2099               	/* epilogue start */
 992:tmk_core/common/action.c ****     debug_event(record.event);
 993:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 994:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 995:tmk_core/common/action.c **** #endif
 996:tmk_core/common/action.c **** }
 2100               		.loc 1 996 0
 2101 000e 2696      		adiw r28,6
 2102 0010 0FB6      		in __tmp_reg__,__SREG__
 2103 0012 F894      		cli
 2104 0014 DEBF      		out __SP_H__,r29
 2105 0016 0FBE      		out __SREG__,__tmp_reg__
 2106 0018 CDBF      		out __SP_L__,r28
 2107 001a DF91      		pop r29
 2108 001c CF91      		pop r28
 2109 001e 0895      		ret
 2110               		.cfi_endproc
 2111               	.LFE123:
 2113               		.section	.text.debug_action,"ax",@progbits
 2114               	.global	debug_action
 2116               	debug_action:
 2117               	.LFB124:
 997:tmk_core/common/action.c **** 
 998:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 999:tmk_core/common/action.c ****  *
1000:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1001:tmk_core/common/action.c ****  */
1002:tmk_core/common/action.c **** void debug_action(action_t action)
1003:tmk_core/common/action.c **** {
 2118               		.loc 1 1003 0
 2119               		.cfi_startproc
 2120               	.LVL201:
 2121               	/* prologue: function */
 2122               	/* frame size = 0 */
 2123               	/* stack size = 0 */
 2124               	.L__stack_usage = 0
 2125 0000 0895      		ret
 2126               		.cfi_endproc
 2127               	.LFE124:
 2129               	.global	disable_action_cache
 2130               		.section	.bss.disable_action_cache,"aw",@nobits
 2133               	disable_action_cache:
 2134 0000 00        		.zero	1
 2135               		.comm	tp_buttons,2,1
 2136               		.text
 2137               	.Letext0:
 2138               		.file 5 "d:\\program files\\msys2\\home\\bnguy\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\stdin
 2139               		.file 6 "tmk_core/common/keycode.h"
 2140               		.file 7 "tmk_core/common/report.h"
 2141               		.file 8 "tmk_core/common/action_code.h"
 2142               		.file 9 "tmk_core/common/action.h"
 2143               		.file 10 "tmk_core/common/action_layer.h"
 2144               		.file 11 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2145               		.file 12 "tmk_core/common/action_tapping.h"
 2146               		.file 13 "tmk_core/common/host.h"
 2147               		.file 14 "tmk_core/common/action_macro.h"
 2148               		.file 15 "tmk_core/common/led.h"
DEFINED SYMBOLS
                            *ABS*:00000000 action.c
D:\Program Files\msys2\tmp\ccLA105a.s:2      *ABS*:0000003e __SP_H__
D:\Program Files\msys2\tmp\ccLA105a.s:3      *ABS*:0000003d __SP_L__
D:\Program Files\msys2\tmp\ccLA105a.s:4      *ABS*:0000003f __SREG__
D:\Program Files\msys2\tmp\ccLA105a.s:5      *ABS*:00000000 __tmp_reg__
D:\Program Files\msys2\tmp\ccLA105a.s:6      *ABS*:00000001 __zero_reg__
D:\Program Files\msys2\tmp\ccLA105a.s:13     .text.action_exec:00000000 action_exec
D:\Program Files\msys2\tmp\ccLA105a.s:93     .text.process_record_quantum:00000000 process_record_quantum
D:\Program Files\msys2\tmp\ccLA105a.s:112    .text.process_record_tap_hint:00000000 process_record_tap_hint
D:\Program Files\msys2\tmp\ccLA105a.s:135    .text.register_code:00000000 register_code
D:\Program Files\msys2\tmp\ccLA105a.s:567    .text.unregister_code:00000000 unregister_code
D:\Program Files\msys2\tmp\ccLA105a.s:736    .text.tap_code:00000000 tap_code
D:\Program Files\msys2\tmp\ccLA105a.s:788    .text.register_mods:00000000 register_mods
D:\Program Files\msys2\tmp\ccLA105a.s:814    .text.unregister_mods:00000000 unregister_mods
D:\Program Files\msys2\tmp\ccLA105a.s:840    .text.process_action:00000000 process_action
D:\Program Files\msys2\tmp\ccLA105a.s:1726   .text.process_record:00000000 process_record
D:\Program Files\msys2\tmp\ccLA105a.s:1821   .text.process_record_nocache:00000000 process_record_nocache
D:\Program Files\msys2\tmp\ccLA105a.s:2133   .bss.disable_action_cache:00000000 disable_action_cache
D:\Program Files\msys2\tmp\ccLA105a.s:1845   .text.clear_keyboard_but_mods_and_keys:00000000 clear_keyboard_but_mods_and_keys
D:\Program Files\msys2\tmp\ccLA105a.s:1878   .text.clear_keyboard_but_mods:00000000 clear_keyboard_but_mods
D:\Program Files\msys2\tmp\ccLA105a.s:1904   .text.clear_keyboard:00000000 clear_keyboard
D:\Program Files\msys2\tmp\ccLA105a.s:1924   .text.is_tap_action:00000000 is_tap_action
D:\Program Files\msys2\tmp\ccLA105a.s:2010   .text.is_tap_key:00000000 is_tap_key
D:\Program Files\msys2\tmp\ccLA105a.s:2033   .text.debug_event:00000000 debug_event
D:\Program Files\msys2\tmp\ccLA105a.s:2074   .text.debug_record:00000000 debug_record
D:\Program Files\msys2\tmp\ccLA105a.s:2116   .text.debug_action:00000000 debug_action
                            *COM*:00000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
keyboard_report
add_key_to_report
send_keyboard_report
del_key_from_report
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
layer_on
layer_off
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
led_set
get_oneshot_layer_state
get_oneshot_layer
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys_from_report
clear_mods
__do_clear_bss
