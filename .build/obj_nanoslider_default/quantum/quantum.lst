   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB111:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** 
  19:quantum/quantum.c **** #if !defined(RGBLIGHT_ENABLE) && !defined(RGB_MATRIX_ENABLE)
  20:quantum/quantum.c **** 	#include "rgb.h"
  21:quantum/quantum.c **** #endif
  22:quantum/quantum.c **** 
  23:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  24:quantum/quantum.c **** #include "outputselect.h"
  25:quantum/quantum.c **** #endif
  26:quantum/quantum.c **** 
  27:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  28:quantum/quantum.c **** #define BREATHING_PERIOD 6
  29:quantum/quantum.c **** #endif
  30:quantum/quantum.c **** 
  31:quantum/quantum.c **** #include "backlight.h"
  32:quantum/quantum.c **** extern backlight_config_t backlight_config;
  33:quantum/quantum.c **** 
  34:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  35:quantum/quantum.c **** #include "fauxclicky.h"
  36:quantum/quantum.c **** #endif
  37:quantum/quantum.c **** 
  38:quantum/quantum.c **** #ifdef API_ENABLE
  39:quantum/quantum.c **** #include "api.h"
  40:quantum/quantum.c **** #endif
  41:quantum/quantum.c **** 
  42:quantum/quantum.c **** #ifdef MIDI_ENABLE
  43:quantum/quantum.c **** #include "process_midi.h"
  44:quantum/quantum.c **** #endif
  45:quantum/quantum.c **** 
  46:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
  47:quantum/quantum.c **** #include "velocikey.h"
  48:quantum/quantum.c **** #endif
  49:quantum/quantum.c **** 
  50:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
  51:quantum/quantum.c ****     #include "haptic.h"
  52:quantum/quantum.c **** #endif
  53:quantum/quantum.c **** 
  54:quantum/quantum.c **** #ifdef ENCODER_ENABLE
  55:quantum/quantum.c **** #include "encoder.h"
  56:quantum/quantum.c **** #endif
  57:quantum/quantum.c **** 
  58:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  59:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  60:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  61:quantum/quantum.c ****   #endif
  62:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  63:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  64:quantum/quantum.c ****   #endif
  65:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  66:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  67:quantum/quantum.c ****   #endif
  68:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  69:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  70:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  71:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  72:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  73:quantum/quantum.c ****   #endif
  74:quantum/quantum.c **** #endif
  75:quantum/quantum.c **** 
  76:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 76 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  77:quantum/quantum.c ****   switch (code) {
  38               		.loc 1 77 0
  39 0008 9C01      		movw r18,r24
  40 000a 3A95      		dec r19
  41 000c 2115      		cp r18,__zero_reg__
  42 000e 3F41      		sbci r19,31
  43 0010 00F4      		brsh .L1
  44 0012 EB01      		movw r28,r22
  45 0014 8C01      		movw r16,r24
  78:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  79:quantum/quantum.c ****     break;
  80:quantum/quantum.c ****   default:
  81:quantum/quantum.c ****     return;
  82:quantum/quantum.c ****   }
  83:quantum/quantum.c **** 
  84:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 84 0
  47 0016 90FF      		sbrs r25,0
  48 0018 00C0      		rjmp .L4
  85:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 85 0
  50 001a 80EE      		ldi r24,lo8(-32)
  51               	.LVL1:
  52 001c FB01      		movw r30,r22
  53 001e 0995      		icall
  54               	.LVL2:
  55               	.L4:
  86:quantum/quantum.c ****   if (code & QK_LSFT)
  56               		.loc 1 86 0
  57 0020 11FF      		sbrs r17,1
  58 0022 00C0      		rjmp .L5
  87:quantum/quantum.c ****     f(KC_LSFT);
  59               		.loc 1 87 0
  60 0024 81EE      		ldi r24,lo8(-31)
  61 0026 FE01      		movw r30,r28
  62 0028 0995      		icall
  63               	.LVL3:
  64               	.L5:
  88:quantum/quantum.c ****   if (code & QK_LALT)
  65               		.loc 1 88 0
  66 002a 12FF      		sbrs r17,2
  67 002c 00C0      		rjmp .L6
  89:quantum/quantum.c ****     f(KC_LALT);
  68               		.loc 1 89 0
  69 002e 82EE      		ldi r24,lo8(-30)
  70 0030 FE01      		movw r30,r28
  71 0032 0995      		icall
  72               	.LVL4:
  73               	.L6:
  90:quantum/quantum.c ****   if (code & QK_LGUI)
  74               		.loc 1 90 0
  75 0034 13FF      		sbrs r17,3
  76 0036 00C0      		rjmp .L7
  91:quantum/quantum.c ****     f(KC_LGUI);
  77               		.loc 1 91 0
  78 0038 83EE      		ldi r24,lo8(-29)
  79 003a FE01      		movw r30,r28
  80 003c 0995      		icall
  81               	.LVL5:
  82               	.L7:
  92:quantum/quantum.c **** 
  93:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  83               		.loc 1 93 0
  84 003e 0115      		cp r16,__zero_reg__
  85 0040 1041      		sbci r17,16
  86 0042 00F0      		brlo .L1
  94:quantum/quantum.c **** 
  95:quantum/quantum.c ****   if (code & QK_RCTL)
  96:quantum/quantum.c ****     f(KC_RCTL);
  87               		.loc 1 96 0
  88 0044 84EE      		ldi r24,lo8(-28)
  89 0046 FE01      		movw r30,r28
  90 0048 0995      		icall
  91               	.LVL6:
  97:quantum/quantum.c ****   if (code & QK_RSFT)
  98:quantum/quantum.c ****     f(KC_RSFT);
  92               		.loc 1 98 0
  93 004a 85EE      		ldi r24,lo8(-27)
  94 004c FE01      		movw r30,r28
  95 004e 0995      		icall
  96               	.LVL7:
  99:quantum/quantum.c ****   if (code & QK_RALT)
 100:quantum/quantum.c ****     f(KC_RALT);
  97               		.loc 1 100 0
  98 0050 86EE      		ldi r24,lo8(-26)
  99 0052 FE01      		movw r30,r28
 100 0054 0995      		icall
 101               	.LVL8:
 101:quantum/quantum.c ****   if (code & QK_RGUI)
 102:quantum/quantum.c ****     f(KC_RGUI);
 102               		.loc 1 102 0
 103 0056 87EE      		ldi r24,lo8(-25)
 104 0058 FE01      		movw r30,r28
 105               	/* epilogue start */
 103:quantum/quantum.c **** }
 106               		.loc 1 103 0
 107 005a DF91      		pop r29
 108 005c CF91      		pop r28
 109               	.LVL9:
 110 005e 1F91      		pop r17
 111 0060 0F91      		pop r16
 112               	.LVL10:
 102:quantum/quantum.c **** }
 113               		.loc 1 102 0
 114 0062 0994      		ijmp
 115               	.LVL11:
 116               	.L1:
 117               	/* epilogue start */
 118               		.loc 1 103 0
 119 0064 DF91      		pop r29
 120 0066 CF91      		pop r28
 121 0068 1F91      		pop r17
 122 006a 0F91      		pop r16
 123 006c 0895      		ret
 124               		.cfi_endproc
 125               	.LFE111:
 127               		.section	.text.qk_register_mods,"ax",@progbits
 129               	qk_register_mods:
 130               	.LFB114:
 104:quantum/quantum.c **** 
 105:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 106:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 107:quantum/quantum.c ****     send_keyboard_report();
 108:quantum/quantum.c **** }
 109:quantum/quantum.c **** 
 110:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 111:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 112:quantum/quantum.c ****     send_keyboard_report();
 113:quantum/quantum.c **** }
 114:quantum/quantum.c **** 
 115:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 131               		.loc 1 115 0
 132               		.cfi_startproc
 133               	.LVL12:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 116:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 138               		.loc 1 116 0
 139 0000 8770      		andi r24,lo8(7)
 140               	.LVL13:
 141 0002 91E0      		ldi r25,lo8(1)
 142 0004 00C0      		rjmp 2f
 143               		1:
 144 0006 990F      		lsl r25
 145               		2:
 146 0008 8A95      		dec r24
 147 000a 02F4      		brpl 1b
 148 000c 892F      		mov r24,r25
 149 000e 0E94 0000 		call add_weak_mods
 150               	.LVL14:
 117:quantum/quantum.c ****     send_keyboard_report();
 151               		.loc 1 117 0
 152 0012 0C94 0000 		jmp send_keyboard_report
 153               	.LVL15:
 154               		.cfi_endproc
 155               	.LFE114:
 157               		.section	.text.qk_register_weak_mods,"ax",@progbits
 159               	qk_register_weak_mods:
 160               	.LFB163:
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 166 0000 0C94 0000 		jmp qk_register_mods
 167               		.cfi_endproc
 168               	.LFE163:
 170               		.section	.text.qk_unregister_mods,"ax",@progbits
 172               	qk_unregister_mods:
 173               	.LFB115:
 118:quantum/quantum.c **** }
 119:quantum/quantum.c **** 
 120:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 174               		.loc 1 120 0
 175               		.cfi_startproc
 176               	.LVL16:
 177               	/* prologue: function */
 178               	/* frame size = 0 */
 179               	/* stack size = 0 */
 180               	.L__stack_usage = 0
 121:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 181               		.loc 1 121 0
 182 0000 8770      		andi r24,lo8(7)
 183               	.LVL17:
 184 0002 91E0      		ldi r25,lo8(1)
 185 0004 00C0      		rjmp 2f
 186               		1:
 187 0006 990F      		lsl r25
 188               		2:
 189 0008 8A95      		dec r24
 190 000a 02F4      		brpl 1b
 191 000c 892F      		mov r24,r25
 192 000e 0E94 0000 		call del_weak_mods
 193               	.LVL18:
 122:quantum/quantum.c ****     send_keyboard_report();
 194               		.loc 1 122 0
 195 0012 0C94 0000 		jmp send_keyboard_report
 196               	.LVL19:
 197               		.cfi_endproc
 198               	.LFE115:
 200               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 202               	qk_unregister_weak_mods:
 203               	.LFB161:
 204               		.cfi_startproc
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 209 0000 0C94 0000 		jmp qk_unregister_mods
 210               		.cfi_endproc
 211               	.LFE161:
 213               		.section	.text.register_code16,"ax",@progbits
 214               	.global	register_code16
 216               	register_code16:
 217               	.LFB116:
 123:quantum/quantum.c **** }
 124:quantum/quantum.c **** 
 125:quantum/quantum.c **** void register_code16 (uint16_t code) {
 218               		.loc 1 125 0
 219               		.cfi_startproc
 220               	.LVL20:
 221               		.loc 1 125 0
 222 0000 CF93      		push r28
 223               	.LCFI4:
 224               		.cfi_def_cfa_offset 3
 225               		.cfi_offset 28, -2
 226 0002 DF93      		push r29
 227               	.LCFI5:
 228               		.cfi_def_cfa_offset 4
 229               		.cfi_offset 29, -3
 230               	/* prologue: function */
 231               	/* frame size = 0 */
 232               	/* stack size = 2 */
 233               	.L__stack_usage = 2
 234 0004 EC01      		movw r28,r24
 126:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 235               		.loc 1 126 0
 236 0006 805E      		subi r24,-32
 237 0008 9109      		sbc r25,__zero_reg__
 238               	.LVL21:
 239 000a 0897      		sbiw r24,8
 240 000c 00F0      		brlo .L28
 241               		.loc 1 126 0 is_stmt 0 discriminator 1
 242 000e 2097      		sbiw r28,0
 243 0010 01F4      		brne .L29
 244               	.L28:
 127:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 245               		.loc 1 127 0 is_stmt 1
 246 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 247 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 248 0016 00C0      		rjmp .L31
 249               	.L29:
 128:quantum/quantum.c ****   } else {
 129:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 250               		.loc 1 129 0
 251 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 252 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 253               	.L31:
 254 001c CE01      		movw r24,r28
 255 001e 0E94 0000 		call do_code16
 256               	.LVL22:
 130:quantum/quantum.c ****   }
 131:quantum/quantum.c ****   register_code (code);
 257               		.loc 1 131 0
 258 0022 8C2F      		mov r24,r28
 259               	/* epilogue start */
 132:quantum/quantum.c **** }
 260               		.loc 1 132 0
 261 0024 DF91      		pop r29
 262 0026 CF91      		pop r28
 263               	.LVL23:
 131:quantum/quantum.c **** }
 264               		.loc 1 131 0
 265 0028 0C94 0000 		jmp register_code
 266               	.LVL24:
 267               		.cfi_endproc
 268               	.LFE116:
 270               		.section	.text.unregister_code16,"ax",@progbits
 271               	.global	unregister_code16
 273               	unregister_code16:
 274               	.LFB117:
 133:quantum/quantum.c **** 
 134:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 275               		.loc 1 134 0
 276               		.cfi_startproc
 277               	.LVL25:
 278 0000 CF93      		push r28
 279               	.LCFI6:
 280               		.cfi_def_cfa_offset 3
 281               		.cfi_offset 28, -2
 282 0002 DF93      		push r29
 283               	.LCFI7:
 284               		.cfi_def_cfa_offset 4
 285               		.cfi_offset 29, -3
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 2 */
 289               	.L__stack_usage = 2
 290 0004 EC01      		movw r28,r24
 135:quantum/quantum.c ****   unregister_code (code);
 291               		.loc 1 135 0
 292 0006 0E94 0000 		call unregister_code
 293               	.LVL26:
 136:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 294               		.loc 1 136 0
 295 000a CE01      		movw r24,r28
 296 000c 805E      		subi r24,-32
 297 000e 9109      		sbc r25,__zero_reg__
 298 0010 0897      		sbiw r24,8
 299 0012 00F0      		brlo .L33
 300               		.loc 1 136 0 is_stmt 0 discriminator 1
 301 0014 2097      		sbiw r28,0
 302 0016 01F4      		brne .L34
 303               	.L33:
 137:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 304               		.loc 1 137 0 is_stmt 1
 305 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 306 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 307 001c 00C0      		rjmp .L35
 308               	.L34:
 138:quantum/quantum.c ****   } else {
 139:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 309               		.loc 1 139 0
 310 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 311 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 312               	.L35:
 313 0022 CE01      		movw r24,r28
 314               	/* epilogue start */
 140:quantum/quantum.c ****   }
 141:quantum/quantum.c **** }
 315               		.loc 1 141 0
 316 0024 DF91      		pop r29
 317 0026 CF91      		pop r28
 318               	.LVL27:
 139:quantum/quantum.c ****   }
 319               		.loc 1 139 0
 320 0028 0C94 0000 		jmp do_code16
 321               	.LVL28:
 322               		.cfi_endproc
 323               	.LFE117:
 325               		.section	.text.tap_code16,"ax",@progbits
 326               	.global	tap_code16
 328               	tap_code16:
 329               	.LFB118:
 142:quantum/quantum.c **** 
 143:quantum/quantum.c **** void tap_code16(uint16_t code) {
 330               		.loc 1 143 0
 331               		.cfi_startproc
 332               	.LVL29:
 333 0000 CF93      		push r28
 334               	.LCFI8:
 335               		.cfi_def_cfa_offset 3
 336               		.cfi_offset 28, -2
 337 0002 DF93      		push r29
 338               	.LCFI9:
 339               		.cfi_def_cfa_offset 4
 340               		.cfi_offset 29, -3
 341               	/* prologue: function */
 342               	/* frame size = 0 */
 343               	/* stack size = 2 */
 344               	.L__stack_usage = 2
 345 0004 EC01      		movw r28,r24
 144:quantum/quantum.c ****   register_code16(code);
 346               		.loc 1 144 0
 347 0006 0E94 0000 		call register_code16
 348               	.LVL30:
 145:quantum/quantum.c ****   #if TAP_CODE_DELAY > 0
 146:quantum/quantum.c ****     wait_ms(TAP_CODE_DELAY);
 147:quantum/quantum.c ****   #endif
 148:quantum/quantum.c ****   unregister_code16(code);
 349               		.loc 1 148 0
 350 000a CE01      		movw r24,r28
 351               	/* epilogue start */
 149:quantum/quantum.c **** }
 352               		.loc 1 149 0
 353 000c DF91      		pop r29
 354 000e CF91      		pop r28
 355               	.LVL31:
 148:quantum/quantum.c **** }
 356               		.loc 1 148 0
 357 0010 0C94 0000 		jmp unregister_code16
 358               	.LVL32:
 359               		.cfi_endproc
 360               	.LFE118:
 362               		.section	.text.process_action_kb,"ax",@progbits
 363               		.weak	process_action_kb
 365               	process_action_kb:
 366               	.LFB119:
 150:quantum/quantum.c **** 
 151:quantum/quantum.c **** __attribute__ ((weak))
 152:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 367               		.loc 1 152 0
 368               		.cfi_startproc
 369               	.LVL33:
 370               	/* prologue: function */
 371               	/* frame size = 0 */
 372               	/* stack size = 0 */
 373               	.L__stack_usage = 0
 153:quantum/quantum.c ****   return true;
 154:quantum/quantum.c **** }
 374               		.loc 1 154 0
 375 0000 81E0      		ldi r24,lo8(1)
 376               	.LVL34:
 377 0002 0895      		ret
 378               		.cfi_endproc
 379               	.LFE119:
 381               		.section	.text.process_record_user,"ax",@progbits
 382               		.weak	process_record_user
 384               	process_record_user:
 385               	.LFB121:
 155:quantum/quantum.c **** 
 156:quantum/quantum.c **** __attribute__ ((weak))
 157:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 158:quantum/quantum.c ****   return process_record_user(keycode, record);
 159:quantum/quantum.c **** }
 160:quantum/quantum.c **** 
 161:quantum/quantum.c **** __attribute__ ((weak))
 162:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 386               		.loc 1 162 0
 387               		.cfi_startproc
 388               	.LVL35:
 389               	/* prologue: function */
 390               	/* frame size = 0 */
 391               	/* stack size = 0 */
 392               	.L__stack_usage = 0
 163:quantum/quantum.c ****   return true;
 164:quantum/quantum.c **** }
 393               		.loc 1 164 0
 394 0000 81E0      		ldi r24,lo8(1)
 395               	.LVL36:
 396 0002 0895      		ret
 397               		.cfi_endproc
 398               	.LFE121:
 400               		.section	.text.process_record_kb,"ax",@progbits
 401               		.weak	process_record_kb
 403               	process_record_kb:
 404               	.LFB120:
 157:quantum/quantum.c ****   return process_record_user(keycode, record);
 405               		.loc 1 157 0
 406               		.cfi_startproc
 407               	.LVL37:
 408               	/* prologue: function */
 409               	/* frame size = 0 */
 410               	/* stack size = 0 */
 411               	.L__stack_usage = 0
 158:quantum/quantum.c **** }
 412               		.loc 1 158 0
 413 0000 0C94 0000 		jmp process_record_user
 414               	.LVL38:
 415               		.cfi_endproc
 416               	.LFE120:
 418               		.section	.text.get_event_keycode,"ax",@progbits
 419               	.global	get_event_keycode
 421               	get_event_keycode:
 422               	.LFB124:
 165:quantum/quantum.c **** 
 166:quantum/quantum.c **** void reset_keyboard(void) {
 167:quantum/quantum.c ****   clear_keyboard();
 168:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 169:quantum/quantum.c ****   process_midi_all_notes_off();
 170:quantum/quantum.c **** #endif
 171:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 172:quantum/quantum.c ****   #ifndef NO_MUSIC_MODE
 173:quantum/quantum.c ****     music_all_notes_off();
 174:quantum/quantum.c ****   #endif
 175:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 176:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 177:quantum/quantum.c ****   shutdown_user();
 178:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 179:quantum/quantum.c ****     wait_ms(1);
 180:quantum/quantum.c ****   stop_all_notes();
 181:quantum/quantum.c **** #else
 182:quantum/quantum.c ****   shutdown_user();
 183:quantum/quantum.c ****   wait_ms(250);
 184:quantum/quantum.c **** #endif
 185:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 186:quantum/quantum.c ****   haptic_shutdown();
 187:quantum/quantum.c **** #endif
 188:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 189:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 190:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 191:quantum/quantum.c **** #endif
 192:quantum/quantum.c ****   bootloader_jump();
 193:quantum/quantum.c **** }
 194:quantum/quantum.c **** 
 195:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 196:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 197:quantum/quantum.c ****  */
 198:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 199:quantum/quantum.c **** 
 200:quantum/quantum.c **** /* Convert record into usable keycode via the contained event. */
 201:quantum/quantum.c **** uint16_t get_record_keycode(keyrecord_t *record) {
 202:quantum/quantum.c ****   return get_event_keycode(record->event);
 203:quantum/quantum.c **** }
 204:quantum/quantum.c **** 
 205:quantum/quantum.c **** 
 206:quantum/quantum.c **** /* Convert event into usable keycode. Checks the layer cache to ensure that it
 207:quantum/quantum.c ****  * retains the correct keycode after a layer change, if the key is still pressed.
 208:quantum/quantum.c ****  */
 209:quantum/quantum.c **** uint16_t get_event_keycode(keyevent_t event) {
 423               		.loc 1 209 0
 424               		.cfi_startproc
 425 0000 1F93      		push r17
 426               	.LCFI10:
 427               		.cfi_def_cfa_offset 3
 428               		.cfi_offset 17, -2
 429 0002 CF93      		push r28
 430               	.LCFI11:
 431               		.cfi_def_cfa_offset 4
 432               		.cfi_offset 28, -3
 433 0004 DF93      		push r29
 434               	.LCFI12:
 435               		.cfi_def_cfa_offset 5
 436               		.cfi_offset 29, -4
 437 0006 00D0      		rcall .
 438 0008 00D0      		rcall .
 439 000a 1F92      		push __zero_reg__
 440               	.LCFI13:
 441               		.cfi_def_cfa_offset 10
 442 000c CDB7      		in r28,__SP_L__
 443 000e DEB7      		in r29,__SP_H__
 444               	.LCFI14:
 445               		.cfi_def_cfa_register 28
 446               	/* prologue: function */
 447               	/* frame size = 5 */
 448               	/* stack size = 8 */
 449               	.L__stack_usage = 8
 450 0010 4983      		std Y+1,r20
 451 0012 5A83      		std Y+2,r21
 452 0014 6B83      		std Y+3,r22
 210:quantum/quantum.c **** 
 211:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 212:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 213:quantum/quantum.c ****     if (!disable_action_cache) {
 453               		.loc 1 213 0
 454 0016 2091 0000 		lds r18,disable_action_cache
 455 001a 8981      		ldd r24,Y+1
 456 001c 9A81      		ldd r25,Y+2
 457 001e 2111      		cpse r18,__zero_reg__
 458 0020 00C0      		rjmp .L41
 459               	.LBB31:
 214:quantum/quantum.c ****       uint8_t layer;
 215:quantum/quantum.c **** 
 216:quantum/quantum.c ****       if (event.pressed) {
 460               		.loc 1 216 0
 461 0022 6623      		tst r22
 462 0024 01F0      		breq .L42
 217:quantum/quantum.c ****         layer = layer_switch_get_layer(event.key);
 463               		.loc 1 217 0
 464 0026 0E94 0000 		call layer_switch_get_layer
 465               	.LVL39:
 466 002a 182F      		mov r17,r24
 467               	.LVL40:
 218:quantum/quantum.c ****         update_source_layers_cache(event.key, layer);
 468               		.loc 1 218 0
 469 002c 682F      		mov r22,r24
 470 002e 8981      		ldd r24,Y+1
 471 0030 9A81      		ldd r25,Y+2
 472 0032 0E94 0000 		call update_source_layers_cache
 473               	.LVL41:
 474 0036 00C0      		rjmp .L43
 475               	.LVL42:
 476               	.L42:
 219:quantum/quantum.c ****       } else {
 220:quantum/quantum.c ****         layer = read_source_layers_cache(event.key);
 477               		.loc 1 220 0
 478 0038 0E94 0000 		call read_source_layers_cache
 479               	.LVL43:
 480 003c 182F      		mov r17,r24
 481               	.LVL44:
 482               	.L43:
 221:quantum/quantum.c ****       }
 222:quantum/quantum.c ****       return keymap_key_to_keycode(layer, event.key);
 483               		.loc 1 222 0
 484 003e 6981      		ldd r22,Y+1
 485 0040 7A81      		ldd r23,Y+2
 486 0042 812F      		mov r24,r17
 487 0044 00C0      		rjmp .L44
 488               	.LVL45:
 489               	.L41:
 490               	.LBE31:
 223:quantum/quantum.c ****     } else
 224:quantum/quantum.c ****   #endif
 225:quantum/quantum.c ****     return keymap_key_to_keycode(layer_switch_get_layer(event.key), event.key);
 491               		.loc 1 225 0
 492 0046 0E94 0000 		call layer_switch_get_layer
 493               	.LVL46:
 494 004a 6981      		ldd r22,Y+1
 495 004c 7A81      		ldd r23,Y+2
 496               	.L44:
 497               	/* epilogue start */
 226:quantum/quantum.c **** }
 498               		.loc 1 226 0
 499 004e 0F90      		pop __tmp_reg__
 500 0050 0F90      		pop __tmp_reg__
 501 0052 0F90      		pop __tmp_reg__
 502 0054 0F90      		pop __tmp_reg__
 503 0056 0F90      		pop __tmp_reg__
 504 0058 DF91      		pop r29
 505 005a CF91      		pop r28
 506 005c 1F91      		pop r17
 225:quantum/quantum.c **** }
 507               		.loc 1 225 0
 508 005e 0C94 0000 		jmp keymap_key_to_keycode
 509               	.LVL47:
 510               		.cfi_endproc
 511               	.LFE124:
 513               		.section	.text.get_record_keycode,"ax",@progbits
 514               	.global	get_record_keycode
 516               	get_record_keycode:
 517               	.LFB123:
 201:quantum/quantum.c ****   return get_event_keycode(record->event);
 518               		.loc 1 201 0
 519               		.cfi_startproc
 520               	.LVL48:
 521               	/* prologue: function */
 522               	/* frame size = 0 */
 523               	/* stack size = 0 */
 524               	.L__stack_usage = 0
 525 0000 FC01      		movw r30,r24
 202:quantum/quantum.c **** }
 526               		.loc 1 202 0
 527 0002 4081      		ld r20,Z
 528 0004 5181      		ldd r21,Z+1
 529 0006 6281      		ldd r22,Z+2
 530 0008 7381      		ldd r23,Z+3
 531 000a 8481      		ldd r24,Z+4
 532               	.LVL49:
 533 000c 0C94 0000 		jmp get_event_keycode
 534               	.LVL50:
 535               		.cfi_endproc
 536               	.LFE123:
 538               		.section	.text.send_char,"ax",@progbits
 539               	.global	send_char
 541               	send_char:
 542               	.LFB130:
 227:quantum/quantum.c **** 
 228:quantum/quantum.c **** /* Main keycode processing function. Hands off handling to other functions,
 229:quantum/quantum.c ****  * then processes internal Quantum keycodes, then processes ACTIONs.
 230:quantum/quantum.c ****  */
 231:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 232:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record);
 233:quantum/quantum.c **** 
 234:quantum/quantum.c ****     // This is how you use actions here
 235:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 236:quantum/quantum.c ****     //   action_t action;
 237:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 238:quantum/quantum.c ****     //   process_action(record, action);
 239:quantum/quantum.c ****     //   return false;
 240:quantum/quantum.c ****     // }
 241:quantum/quantum.c **** 
 242:quantum/quantum.c ****   #ifdef VELOCIKEY_ENABLE
 243:quantum/quantum.c ****     if (velocikey_enabled() && record->event.pressed) { velocikey_accelerate(); }
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c **** 
 246:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 247:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 248:quantum/quantum.c ****   #endif
 249:quantum/quantum.c **** 
 250:quantum/quantum.c ****   if (!(
 251:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 252:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 253:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 254:quantum/quantum.c ****   #endif
 255:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 256:quantum/quantum.c ****     process_clicky(keycode, record) &&
 257:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 258:quantum/quantum.c ****   #ifdef HAPTIC_ENABLE
 259:quantum/quantum.c ****     process_haptic(keycode, record) &&
 260:quantum/quantum.c ****   #endif //HAPTIC_ENABLE
 261:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE)
 262:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 263:quantum/quantum.c ****   #endif
 264:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 265:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 266:quantum/quantum.c ****     process_midi(keycode, record) &&
 267:quantum/quantum.c ****   #endif
 268:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 269:quantum/quantum.c ****     process_audio(keycode, record) &&
 270:quantum/quantum.c ****   #endif
 271:quantum/quantum.c ****   #ifdef STENO_ENABLE
 272:quantum/quantum.c ****     process_steno(keycode, record) &&
 273:quantum/quantum.c ****   #endif
 274:quantum/quantum.c ****   #if (defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSIC
 275:quantum/quantum.c ****     process_music(keycode, record) &&
 276:quantum/quantum.c ****   #endif
 277:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 278:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 279:quantum/quantum.c ****   #endif
 280:quantum/quantum.c ****   #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 281:quantum/quantum.c ****     process_unicode_common(keycode, record) &&
 282:quantum/quantum.c ****   #endif
 283:quantum/quantum.c ****   #ifdef LEADER_ENABLE
 284:quantum/quantum.c ****     process_leader(keycode, record) &&
 285:quantum/quantum.c ****   #endif
 286:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 287:quantum/quantum.c ****     process_combo(keycode, record) &&
 288:quantum/quantum.c ****   #endif
 289:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 290:quantum/quantum.c ****     process_printer(keycode, record) &&
 291:quantum/quantum.c ****   #endif
 292:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 293:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 294:quantum/quantum.c ****   #endif
 295:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 296:quantum/quantum.c ****     process_terminal(keycode, record) &&
 297:quantum/quantum.c ****   #endif
 298:quantum/quantum.c ****   #ifdef SPACE_CADET_ENABLE
 299:quantum/quantum.c ****     process_space_cadet(keycode, record) &&
 300:quantum/quantum.c ****   #endif
 301:quantum/quantum.c ****       true)) {
 302:quantum/quantum.c ****     return false;
 303:quantum/quantum.c ****   }
 304:quantum/quantum.c **** 
 305:quantum/quantum.c ****   // Shift / paren setup
 306:quantum/quantum.c **** 
 307:quantum/quantum.c ****   switch(keycode) {
 308:quantum/quantum.c ****     case RESET:
 309:quantum/quantum.c ****       if (record->event.pressed) {
 310:quantum/quantum.c ****         reset_keyboard();
 311:quantum/quantum.c ****       }
 312:quantum/quantum.c ****     return false;
 313:quantum/quantum.c ****     case DEBUG:
 314:quantum/quantum.c ****       if (record->event.pressed) {
 315:quantum/quantum.c ****         debug_enable ^= 1;
 316:quantum/quantum.c ****         if (debug_enable) {
 317:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 318:quantum/quantum.c ****         } else {
 319:quantum/quantum.c ****           print("DEBUG: disabled.\n");
 320:quantum/quantum.c ****         }
 321:quantum/quantum.c ****       }
 322:quantum/quantum.c ****     return false;
 323:quantum/quantum.c ****     case EEPROM_RESET:
 324:quantum/quantum.c ****       if (record->event.pressed) {
 325:quantum/quantum.c ****           eeconfig_init();
 326:quantum/quantum.c ****       }
 327:quantum/quantum.c ****     return false;
 328:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 329:quantum/quantum.c ****   case FC_TOG:
 330:quantum/quantum.c ****     if (record->event.pressed) {
 331:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 332:quantum/quantum.c ****     }
 333:quantum/quantum.c ****     return false;
 334:quantum/quantum.c ****   case FC_ON:
 335:quantum/quantum.c ****     if (record->event.pressed) {
 336:quantum/quantum.c ****       FAUXCLICKY_ON;
 337:quantum/quantum.c ****     }
 338:quantum/quantum.c ****     return false;
 339:quantum/quantum.c ****   case FC_OFF:
 340:quantum/quantum.c ****     if (record->event.pressed) {
 341:quantum/quantum.c ****       FAUXCLICKY_OFF;
 342:quantum/quantum.c ****     }
 343:quantum/quantum.c ****     return false;
 344:quantum/quantum.c ****   #endif
 345:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 346:quantum/quantum.c ****   case RGB_TOG:
 347:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 348:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 349:quantum/quantum.c ****     if (record->event.pressed) {
 350:quantum/quantum.c ****     #else
 351:quantum/quantum.c ****     if (!record->event.pressed) {
 352:quantum/quantum.c ****     #endif
 353:quantum/quantum.c ****       rgblight_toggle();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 359:quantum/quantum.c ****       if(shifted) {
 360:quantum/quantum.c ****         rgblight_step_reverse();
 361:quantum/quantum.c ****       }
 362:quantum/quantum.c ****       else {
 363:quantum/quantum.c ****         rgblight_step();
 364:quantum/quantum.c ****       }
 365:quantum/quantum.c ****     }
 366:quantum/quantum.c ****     return false;
 367:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 368:quantum/quantum.c ****     if (record->event.pressed) {
 369:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 370:quantum/quantum.c ****       if(shifted) {
 371:quantum/quantum.c ****         rgblight_step();
 372:quantum/quantum.c ****       }
 373:quantum/quantum.c ****       else {
 374:quantum/quantum.c ****         rgblight_step_reverse();
 375:quantum/quantum.c ****       }
 376:quantum/quantum.c ****     }
 377:quantum/quantum.c ****     return false;
 378:quantum/quantum.c ****   case RGB_HUI:
 379:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 380:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 381:quantum/quantum.c ****     if (record->event.pressed) {
 382:quantum/quantum.c ****     #else
 383:quantum/quantum.c ****     if (!record->event.pressed) {
 384:quantum/quantum.c ****     #endif
 385:quantum/quantum.c ****       rgblight_increase_hue();
 386:quantum/quantum.c ****     }
 387:quantum/quantum.c ****     return false;
 388:quantum/quantum.c ****   case RGB_HUD:
 389:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 390:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 391:quantum/quantum.c ****     if (record->event.pressed) {
 392:quantum/quantum.c ****     #else
 393:quantum/quantum.c ****     if (!record->event.pressed) {
 394:quantum/quantum.c ****     #endif
 395:quantum/quantum.c ****       rgblight_decrease_hue();
 396:quantum/quantum.c ****     }
 397:quantum/quantum.c ****     return false;
 398:quantum/quantum.c ****   case RGB_SAI:
 399:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 400:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 401:quantum/quantum.c ****     if (record->event.pressed) {
 402:quantum/quantum.c ****     #else
 403:quantum/quantum.c ****     if (!record->event.pressed) {
 404:quantum/quantum.c ****     #endif
 405:quantum/quantum.c ****       rgblight_increase_sat();
 406:quantum/quantum.c ****     }
 407:quantum/quantum.c ****     return false;
 408:quantum/quantum.c ****   case RGB_SAD:
 409:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 410:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 411:quantum/quantum.c ****     if (record->event.pressed) {
 412:quantum/quantum.c ****     #else
 413:quantum/quantum.c ****     if (!record->event.pressed) {
 414:quantum/quantum.c ****     #endif
 415:quantum/quantum.c ****       rgblight_decrease_sat();
 416:quantum/quantum.c ****     }
 417:quantum/quantum.c ****     return false;
 418:quantum/quantum.c ****   case RGB_VAI:
 419:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 420:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 421:quantum/quantum.c ****     if (record->event.pressed) {
 422:quantum/quantum.c ****     #else
 423:quantum/quantum.c ****     if (!record->event.pressed) {
 424:quantum/quantum.c ****     #endif
 425:quantum/quantum.c ****       rgblight_increase_val();
 426:quantum/quantum.c ****     }
 427:quantum/quantum.c ****     return false;
 428:quantum/quantum.c ****   case RGB_VAD:
 429:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 430:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 431:quantum/quantum.c ****     if (record->event.pressed) {
 432:quantum/quantum.c ****     #else
 433:quantum/quantum.c ****     if (!record->event.pressed) {
 434:quantum/quantum.c ****     #endif
 435:quantum/quantum.c ****       rgblight_decrease_val();
 436:quantum/quantum.c ****     }
 437:quantum/quantum.c ****     return false;
 438:quantum/quantum.c ****   case RGB_SPI:
 439:quantum/quantum.c ****     if (record->event.pressed) {
 440:quantum/quantum.c ****       rgblight_increase_speed();
 441:quantum/quantum.c ****     }
 442:quantum/quantum.c ****     return false;
 443:quantum/quantum.c ****   case RGB_SPD:
 444:quantum/quantum.c ****     if (record->event.pressed) {
 445:quantum/quantum.c ****       rgblight_decrease_speed();
 446:quantum/quantum.c ****     }
 447:quantum/quantum.c ****     return false;
 448:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 449:quantum/quantum.c ****     if (record->event.pressed) {
 450:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_STATIC_LIGHT);
 451:quantum/quantum.c ****     }
 452:quantum/quantum.c ****     return false;
 453:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 454:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_BREATHING
 455:quantum/quantum.c ****     if (record->event.pressed) {
 456:quantum/quantum.c ****       if ((RGBLIGHT_MODE_BREATHING <= rgblight_get_mode()) &&
 457:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_BREATHING_end)) {
 458:quantum/quantum.c ****         rgblight_step();
 459:quantum/quantum.c ****       } else {
 460:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_BREATHING);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****     }
 463:quantum/quantum.c ****   #endif
 464:quantum/quantum.c ****     return false;
 465:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 466:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_RAINBOW_MOOD
 467:quantum/quantum.c ****     if (record->event.pressed) {
 468:quantum/quantum.c ****       if ((RGBLIGHT_MODE_RAINBOW_MOOD <= rgblight_get_mode()) &&
 469:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_MOOD_end)) {
 470:quantum/quantum.c ****         rgblight_step();
 471:quantum/quantum.c ****       } else {
 472:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_RAINBOW_MOOD);
 473:quantum/quantum.c ****       }
 474:quantum/quantum.c ****     }
 475:quantum/quantum.c ****   #endif
 476:quantum/quantum.c ****     return false;
 477:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 478:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_RAINBOW_SWIRL
 479:quantum/quantum.c ****     if (record->event.pressed) {
 480:quantum/quantum.c ****       if ((RGBLIGHT_MODE_RAINBOW_SWIRL <= rgblight_get_mode()) &&
 481:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_SWIRL_end)) {
 482:quantum/quantum.c ****         rgblight_step();
 483:quantum/quantum.c ****       } else {
 484:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_RAINBOW_SWIRL);
 485:quantum/quantum.c ****       }
 486:quantum/quantum.c ****     }
 487:quantum/quantum.c ****   #endif
 488:quantum/quantum.c ****     return false;
 489:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 490:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_SNAKE
 491:quantum/quantum.c ****     if (record->event.pressed) {
 492:quantum/quantum.c ****       if ((RGBLIGHT_MODE_SNAKE <= rgblight_get_mode()) &&
 493:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_SNAKE_end)) {
 494:quantum/quantum.c ****         rgblight_step();
 495:quantum/quantum.c ****       } else {
 496:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_SNAKE);
 497:quantum/quantum.c ****       }
 498:quantum/quantum.c ****     }
 499:quantum/quantum.c ****   #endif
 500:quantum/quantum.c ****     return false;
 501:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 502:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_KNIGHT
 503:quantum/quantum.c ****     if (record->event.pressed) {
 504:quantum/quantum.c ****       if ((RGBLIGHT_MODE_KNIGHT <= rgblight_get_mode()) &&
 505:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_KNIGHT_end)) {
 506:quantum/quantum.c ****         rgblight_step();
 507:quantum/quantum.c ****       } else {
 508:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_KNIGHT);
 509:quantum/quantum.c ****       }
 510:quantum/quantum.c ****     }
 511:quantum/quantum.c ****   #endif
 512:quantum/quantum.c ****     return false;
 513:quantum/quantum.c ****   case RGB_MODE_XMAS:
 514:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_CHRISTMAS
 515:quantum/quantum.c ****     if (record->event.pressed) {
 516:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_CHRISTMAS);
 517:quantum/quantum.c ****     }
 518:quantum/quantum.c ****   #endif
 519:quantum/quantum.c ****     return false;
 520:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 521:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_STATIC_GRADIENT
 522:quantum/quantum.c ****     if (record->event.pressed) {
 523:quantum/quantum.c ****       if ((RGBLIGHT_MODE_STATIC_GRADIENT <= rgblight_get_mode()) &&
 524:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_STATIC_GRADIENT_end)) {
 525:quantum/quantum.c ****         rgblight_step();
 526:quantum/quantum.c ****       } else {
 527:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_STATIC_GRADIENT);
 528:quantum/quantum.c ****       }
 529:quantum/quantum.c ****     }
 530:quantum/quantum.c ****   #endif
 531:quantum/quantum.c ****     return false;
 532:quantum/quantum.c ****   case RGB_MODE_RGBTEST:
 533:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_RGB_TEST
 534:quantum/quantum.c ****     if (record->event.pressed) {
 535:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_RGB_TEST);
 536:quantum/quantum.c ****     }
 537:quantum/quantum.c ****   #endif
 538:quantum/quantum.c ****     return false;
 539:quantum/quantum.c ****   #endif // defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 540:quantum/quantum.c ****   #ifdef VELOCIKEY_ENABLE
 541:quantum/quantum.c ****     case VLK_TOG:
 542:quantum/quantum.c ****       if (record->event.pressed) {
 543:quantum/quantum.c ****         velocikey_toggle();
 544:quantum/quantum.c ****       }
 545:quantum/quantum.c ****       return false;
 546:quantum/quantum.c ****   #endif
 547:quantum/quantum.c ****   #ifdef PROTOCOL_LUFA
 548:quantum/quantum.c ****     case OUT_AUTO:
 549:quantum/quantum.c ****       if (record->event.pressed) {
 550:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 551:quantum/quantum.c ****       }
 552:quantum/quantum.c ****       return false;
 553:quantum/quantum.c ****     case OUT_USB:
 554:quantum/quantum.c ****       if (record->event.pressed) {
 555:quantum/quantum.c ****         set_output(OUTPUT_USB);
 556:quantum/quantum.c ****       }
 557:quantum/quantum.c ****       return false;
 558:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 559:quantum/quantum.c ****     case OUT_BT:
 560:quantum/quantum.c ****       if (record->event.pressed) {
 561:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 562:quantum/quantum.c ****       }
 563:quantum/quantum.c ****       return false;
 564:quantum/quantum.c ****     #endif
 565:quantum/quantum.c ****     #endif
 566:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 567:quantum/quantum.c ****       if (record->event.pressed) {
 568:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 569:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 570:quantum/quantum.c ****             eeconfig_init();
 571:quantum/quantum.c ****         }
 572:quantum/quantum.c ****         /* keymap config */
 573:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 574:quantum/quantum.c ****         switch (keycode)
 575:quantum/quantum.c ****         {
 576:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 577:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 578:quantum/quantum.c ****             break;
 579:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 580:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 581:quantum/quantum.c ****             break;
 582:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 583:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 584:quantum/quantum.c ****             break;
 585:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 586:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 587:quantum/quantum.c ****             break;
 588:quantum/quantum.c ****           case MAGIC_NO_GUI:
 589:quantum/quantum.c ****             keymap_config.no_gui = true;
 590:quantum/quantum.c ****             break;
 591:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 592:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 593:quantum/quantum.c ****             break;
 594:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 595:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 596:quantum/quantum.c ****             break;
 597:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 598:quantum/quantum.c ****             keymap_config.nkro = true;
 599:quantum/quantum.c ****             break;
 600:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 601:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 602:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 603:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 604:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 605:quantum/quantum.c ****             #endif
 606:quantum/quantum.c ****             break;
 607:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 608:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 609:quantum/quantum.c ****             break;
 610:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 611:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 612:quantum/quantum.c ****             break;
 613:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 614:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 615:quantum/quantum.c ****             break;
 616:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 617:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 618:quantum/quantum.c ****             break;
 619:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 620:quantum/quantum.c ****             keymap_config.no_gui = false;
 621:quantum/quantum.c ****             break;
 622:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 623:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 624:quantum/quantum.c ****             break;
 625:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 626:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 627:quantum/quantum.c ****             break;
 628:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 629:quantum/quantum.c ****             keymap_config.nkro = false;
 630:quantum/quantum.c ****             break;
 631:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 632:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 633:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 634:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 635:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 636:quantum/quantum.c ****             #endif
 637:quantum/quantum.c ****             break;
 638:quantum/quantum.c ****           case MAGIC_TOGGLE_ALT_GUI:
 639:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = !keymap_config.swap_lalt_lgui;
 640:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = !keymap_config.swap_ralt_rgui;
 641:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 642:quantum/quantum.c ****               if (keymap_config.swap_ralt_rgui) {
 643:quantum/quantum.c ****                 PLAY_SONG(ag_swap_song);
 644:quantum/quantum.c ****               } else {
 645:quantum/quantum.c ****                 PLAY_SONG(ag_norm_song);
 646:quantum/quantum.c ****               }
 647:quantum/quantum.c ****             #endif
 648:quantum/quantum.c ****             break;
 649:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 650:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 651:quantum/quantum.c ****             break;
 652:quantum/quantum.c ****           default:
 653:quantum/quantum.c ****             break;
 654:quantum/quantum.c ****         }
 655:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 656:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 657:quantum/quantum.c **** 
 658:quantum/quantum.c ****         return false;
 659:quantum/quantum.c ****       }
 660:quantum/quantum.c ****       break;
 661:quantum/quantum.c **** 
 662:quantum/quantum.c ****     case GRAVE_ESC: {
 663:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 664:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 665:quantum/quantum.c **** 
 666:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 667:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 668:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 669:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 670:quantum/quantum.c ****         shifted = 0;
 671:quantum/quantum.c ****       }
 672:quantum/quantum.c **** #endif
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 675:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 676:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 677:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 678:quantum/quantum.c ****         shifted = 0;
 679:quantum/quantum.c ****       }
 680:quantum/quantum.c **** #endif
 681:quantum/quantum.c **** 
 682:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 683:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 684:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 685:quantum/quantum.c ****         shifted = 0;
 686:quantum/quantum.c ****       }
 687:quantum/quantum.c **** #endif
 688:quantum/quantum.c **** 
 689:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 690:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 691:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 692:quantum/quantum.c ****         shifted = 0;
 693:quantum/quantum.c ****       }
 694:quantum/quantum.c **** #endif
 695:quantum/quantum.c **** 
 696:quantum/quantum.c ****       if (record->event.pressed) {
 697:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 698:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 699:quantum/quantum.c ****       }
 700:quantum/quantum.c ****       else {
 701:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 702:quantum/quantum.c ****       }
 703:quantum/quantum.c **** 
 704:quantum/quantum.c ****       send_keyboard_report();
 705:quantum/quantum.c ****       return false;
 706:quantum/quantum.c ****     }
 707:quantum/quantum.c **** 
 708:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 709:quantum/quantum.c ****     case BL_BRTG: {
 710:quantum/quantum.c ****       if (record->event.pressed)
 711:quantum/quantum.c ****         breathing_toggle();
 712:quantum/quantum.c ****       return false;
 713:quantum/quantum.c ****     }
 714:quantum/quantum.c **** #endif
 715:quantum/quantum.c ****   }
 716:quantum/quantum.c **** 
 717:quantum/quantum.c ****   return process_action_kb(record);
 718:quantum/quantum.c **** }
 719:quantum/quantum.c **** 
 720:quantum/quantum.c **** __attribute__ ((weak))
 721:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 722:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 723:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 724:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 725:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 726:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 727:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 728:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 729:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 730:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 731:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 732:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 733:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 734:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 735:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 736:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 737:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 738:quantum/quantum.c **** };
 739:quantum/quantum.c **** 
 740:quantum/quantum.c **** __attribute__ ((weak))
 741:quantum/quantum.c **** const bool ascii_to_altgr_lut[0x80] PROGMEM = {
 742:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 743:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 744:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 745:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 746:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 747:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 748:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 749:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 750:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 751:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 752:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 753:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 754:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 755:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 756:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 757:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0
 758:quantum/quantum.c **** };
 759:quantum/quantum.c **** 
 760:quantum/quantum.c **** __attribute__ ((weak))
 761:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 762:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 763:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 764:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 765:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 766:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 767:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 768:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 769:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 770:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 771:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 772:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 773:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 774:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 775:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 776:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 777:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 778:quantum/quantum.c **** };
 779:quantum/quantum.c **** 
 780:quantum/quantum.c **** void send_string(const char *str) {
 781:quantum/quantum.c ****   send_string_with_delay(str, 0);
 782:quantum/quantum.c **** }
 783:quantum/quantum.c **** 
 784:quantum/quantum.c **** void send_string_P(const char *str) {
 785:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 786:quantum/quantum.c **** }
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 789:quantum/quantum.c ****     while (1) {
 790:quantum/quantum.c ****         char ascii_code = *str;
 791:quantum/quantum.c ****         if (!ascii_code) break;
 792:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 793:quantum/quantum.c ****           // tap
 794:quantum/quantum.c ****           uint8_t keycode = *(++str);
 795:quantum/quantum.c ****           register_code(keycode);
 796:quantum/quantum.c ****           unregister_code(keycode);
 797:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 798:quantum/quantum.c ****           // down
 799:quantum/quantum.c ****           uint8_t keycode = *(++str);
 800:quantum/quantum.c ****           register_code(keycode);
 801:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 802:quantum/quantum.c ****           // up
 803:quantum/quantum.c ****           uint8_t keycode = *(++str);
 804:quantum/quantum.c ****           unregister_code(keycode);
 805:quantum/quantum.c ****         } else {
 806:quantum/quantum.c ****           send_char(ascii_code);
 807:quantum/quantum.c ****         }
 808:quantum/quantum.c ****         ++str;
 809:quantum/quantum.c ****         // interval
 810:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 811:quantum/quantum.c ****     }
 812:quantum/quantum.c **** }
 813:quantum/quantum.c **** 
 814:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 815:quantum/quantum.c ****     while (1) {
 816:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 817:quantum/quantum.c ****         if (!ascii_code) break;
 818:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 819:quantum/quantum.c ****           // tap
 820:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 821:quantum/quantum.c ****           register_code(keycode);
 822:quantum/quantum.c ****           unregister_code(keycode);
 823:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 824:quantum/quantum.c ****           // down
 825:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 826:quantum/quantum.c ****           register_code(keycode);
 827:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 828:quantum/quantum.c ****           // up
 829:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 830:quantum/quantum.c ****           unregister_code(keycode);
 831:quantum/quantum.c ****         } else {
 832:quantum/quantum.c ****           send_char(ascii_code);
 833:quantum/quantum.c ****         }
 834:quantum/quantum.c ****         ++str;
 835:quantum/quantum.c ****         // interval
 836:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 837:quantum/quantum.c ****     }
 838:quantum/quantum.c **** }
 839:quantum/quantum.c **** 
 840:quantum/quantum.c **** void send_char(char ascii_code) {
 543               		.loc 1 840 0
 544               		.cfi_startproc
 545               	.LVL51:
 546 0000 1F93      		push r17
 547               	.LCFI15:
 548               		.cfi_def_cfa_offset 3
 549               		.cfi_offset 17, -2
 550 0002 CF93      		push r28
 551               	.LCFI16:
 552               		.cfi_def_cfa_offset 4
 553               		.cfi_offset 28, -3
 554 0004 DF93      		push r29
 555               	.LCFI17:
 556               		.cfi_def_cfa_offset 5
 557               		.cfi_offset 29, -4
 558               	/* prologue: function */
 559               	/* frame size = 0 */
 560               	/* stack size = 3 */
 561               	.L__stack_usage = 3
 562               	.LBB32:
 841:quantum/quantum.c ****   uint8_t keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 563               		.loc 1 841 0
 564 0006 90E0      		ldi r25,0
 565               	.LVL52:
 566 0008 FC01      		movw r30,r24
 567 000a E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 568 000c F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 569               	.LVL53:
 570               	/* #APP */
 571               	 ;  841 "quantum/quantum.c" 1
 572 000e 1491      		lpm r17, Z
 573               		
 574               	 ;  0 "" 2
 575               	.LVL54:
 576               	/* #NOAPP */
 577               	.LBE32:
 578               	.LBB33:
 842:quantum/quantum.c ****   bool is_shifted = pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code]);
 579               		.loc 1 842 0
 580 0010 FC01      		movw r30,r24
 581               	.LVL55:
 582 0012 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 583 0014 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 584               	.LVL56:
 585               	/* #APP */
 586               	 ;  842 "quantum/quantum.c" 1
 587 0016 D491      		lpm r29, Z
 588               		
 589               	 ;  0 "" 2
 590               	.LVL57:
 591               	/* #NOAPP */
 592               	.LBE33:
 593               	.LBB34:
 843:quantum/quantum.c ****   bool is_altgred = pgm_read_byte(&ascii_to_altgr_lut[(uint8_t)ascii_code]);
 594               		.loc 1 843 0
 595 0018 FC01      		movw r30,r24
 596               	.LVL58:
 597 001a E050      		subi r30,lo8(-(ascii_to_altgr_lut))
 598 001c F040      		sbci r31,hi8(-(ascii_to_altgr_lut))
 599               	.LVL59:
 600               	/* #APP */
 601               	 ;  843 "quantum/quantum.c" 1
 602 001e C491      		lpm r28, Z
 603               		
 604               	 ;  0 "" 2
 605               	.LVL60:
 606               	/* #NOAPP */
 607               	.LBE34:
 844:quantum/quantum.c **** 
 845:quantum/quantum.c ****   if (is_shifted) {
 608               		.loc 1 845 0
 609 0020 DD23      		tst r29
 610 0022 01F0      		breq .L47
 846:quantum/quantum.c ****     register_code(KC_LSFT);
 611               		.loc 1 846 0
 612 0024 81EE      		ldi r24,lo8(-31)
 613               	.LVL61:
 614 0026 0E94 0000 		call register_code
 615               	.LVL62:
 616               	.L47:
 847:quantum/quantum.c ****   }
 848:quantum/quantum.c ****   if (is_altgred) {
 617               		.loc 1 848 0
 618 002a CC23      		tst r28
 619 002c 01F0      		breq .L48
 849:quantum/quantum.c ****     register_code(KC_RALT);
 620               		.loc 1 849 0
 621 002e 86EE      		ldi r24,lo8(-26)
 622 0030 0E94 0000 		call register_code
 623               	.LVL63:
 624               	.L48:
 850:quantum/quantum.c ****   }
 851:quantum/quantum.c ****   tap_code(keycode);
 625               		.loc 1 851 0
 626 0034 812F      		mov r24,r17
 627 0036 0E94 0000 		call tap_code
 628               	.LVL64:
 852:quantum/quantum.c ****   if (is_altgred) {
 629               		.loc 1 852 0
 630 003a CC23      		tst r28
 631 003c 01F0      		breq .L49
 853:quantum/quantum.c ****     unregister_code(KC_RALT);
 632               		.loc 1 853 0
 633 003e 86EE      		ldi r24,lo8(-26)
 634 0040 0E94 0000 		call unregister_code
 635               	.LVL65:
 636               	.L49:
 854:quantum/quantum.c ****   }
 855:quantum/quantum.c ****   if (is_shifted) {
 637               		.loc 1 855 0
 638 0044 DD23      		tst r29
 639 0046 01F0      		breq .L46
 856:quantum/quantum.c ****     unregister_code(KC_LSFT);
 640               		.loc 1 856 0
 641 0048 81EE      		ldi r24,lo8(-31)
 642               	/* epilogue start */
 857:quantum/quantum.c ****   }
 858:quantum/quantum.c **** }
 643               		.loc 1 858 0
 644 004a DF91      		pop r29
 645               	.LVL66:
 646 004c CF91      		pop r28
 647               	.LVL67:
 648 004e 1F91      		pop r17
 649               	.LVL68:
 856:quantum/quantum.c ****     unregister_code(KC_LSFT);
 650               		.loc 1 856 0
 651 0050 0C94 0000 		jmp unregister_code
 652               	.LVL69:
 653               	.L46:
 654               	/* epilogue start */
 655               		.loc 1 858 0
 656 0054 DF91      		pop r29
 657               	.LVL70:
 658 0056 CF91      		pop r28
 659               	.LVL71:
 660 0058 1F91      		pop r17
 661               	.LVL72:
 662 005a 0895      		ret
 663               		.cfi_endproc
 664               	.LFE130:
 666               		.section	.text.send_string_with_delay,"ax",@progbits
 667               	.global	send_string_with_delay
 669               	send_string_with_delay:
 670               	.LFB128:
 788:quantum/quantum.c ****     while (1) {
 671               		.loc 1 788 0
 672               		.cfi_startproc
 673               	.LVL73:
 674 0000 FF92      		push r15
 675               	.LCFI18:
 676               		.cfi_def_cfa_offset 3
 677               		.cfi_offset 15, -2
 678 0002 0F93      		push r16
 679               	.LCFI19:
 680               		.cfi_def_cfa_offset 4
 681               		.cfi_offset 16, -3
 682 0004 1F93      		push r17
 683               	.LCFI20:
 684               		.cfi_def_cfa_offset 5
 685               		.cfi_offset 17, -4
 686 0006 CF93      		push r28
 687               	.LCFI21:
 688               		.cfi_def_cfa_offset 6
 689               		.cfi_offset 28, -5
 690 0008 DF93      		push r29
 691               	.LCFI22:
 692               		.cfi_def_cfa_offset 7
 693               		.cfi_offset 29, -6
 694               	/* prologue: function */
 695               	/* frame size = 0 */
 696               	/* stack size = 5 */
 697               	.L__stack_usage = 5
 698 000a EC01      		movw r28,r24
 699 000c F62E      		mov r15,r22
 700               	.LVL74:
 701               	.L68:
 702               	.LBB35:
 790:quantum/quantum.c ****         if (!ascii_code) break;
 703               		.loc 1 790 0
 704 000e 8881      		ld r24,Y
 705               	.LVL75:
 791:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 706               		.loc 1 791 0
 707 0010 8823      		tst r24
 708 0012 01F0      		breq .L60
 709 0014 8E01      		movw r16,r28
 710 0016 0F5F      		subi r16,-1
 711 0018 1F4F      		sbci r17,-1
 792:quantum/quantum.c ****           // tap
 712               		.loc 1 792 0
 713 001a 8130      		cpi r24,lo8(1)
 714 001c 01F4      		brne .L62
 715               	.LVL76:
 716               	.LBB36:
 794:quantum/quantum.c ****           register_code(keycode);
 717               		.loc 1 794 0
 718 001e C981      		ldd r28,Y+1
 719               	.LVL77:
 795:quantum/quantum.c ****           unregister_code(keycode);
 720               		.loc 1 795 0
 721 0020 8C2F      		mov r24,r28
 722               	.LVL78:
 723 0022 0E94 0000 		call register_code
 724               	.LVL79:
 796:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 725               		.loc 1 796 0
 726 0026 8C2F      		mov r24,r28
 727 0028 00C0      		rjmp .L70
 728               	.LVL80:
 729               	.L62:
 730               	.LBE36:
 797:quantum/quantum.c ****           // down
 731               		.loc 1 797 0
 732 002a 8230      		cpi r24,lo8(2)
 733 002c 01F4      		brne .L64
 734               	.LVL81:
 735               	.LBB37:
 800:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 736               		.loc 1 800 0
 737 002e 8981      		ldd r24,Y+1
 738               	.LVL82:
 739 0030 0E94 0000 		call register_code
 740               	.LVL83:
 741               	.L69:
 799:quantum/quantum.c ****           register_code(keycode);
 742               		.loc 1 799 0
 743 0034 E801      		movw r28,r16
 744               	.LBE37:
 745 0036 00C0      		rjmp .L63
 746               	.LVL84:
 747               	.L64:
 801:quantum/quantum.c ****           // up
 748               		.loc 1 801 0
 749 0038 8330      		cpi r24,lo8(3)
 750 003a 01F4      		brne .L65
 751               	.LVL85:
 752               	.LBB38:
 804:quantum/quantum.c ****         } else {
 753               		.loc 1 804 0
 754 003c 8981      		ldd r24,Y+1
 755               	.LVL86:
 756               	.L70:
 757 003e 0E94 0000 		call unregister_code
 758               	.LVL87:
 759 0042 00C0      		rjmp .L69
 760               	.LVL88:
 761               	.L65:
 762               	.LBE38:
 806:quantum/quantum.c ****         }
 763               		.loc 1 806 0
 764 0044 0E94 0000 		call send_char
 765               	.LVL89:
 766               	.L63:
 808:quantum/quantum.c ****         // interval
 767               		.loc 1 808 0
 768 0048 2196      		adiw r28,1
 769               	.LVL90:
 770               	.LBB39:
 810:quantum/quantum.c ****     }
 771               		.loc 1 810 0
 772 004a 8F2D      		mov r24,r15
 773               	.LVL91:
 774               	.L66:
 810:quantum/quantum.c ****     }
 775               		.loc 1 810 0 is_stmt 0 discriminator 1
 776 004c 8823      		tst r24
 777 004e 01F0      		breq .L68
 778               	.LVL92:
 779               	.LBB40:
 780               	.LBB41:
 781               		.file 2 "d:\\program files\\msys2\\home\\bnguy\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\util\
   1:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:d:\program files\msys2\home\bnguy\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 782               		.loc 2 187 0 is_stmt 1
 783 0050 EFE9      		ldi r30,lo8(3999)
 784 0052 FFE0      		ldi r31,hi8(3999)
 785 0054 3197      	1:	sbiw r30,1
 786 0056 01F4      		brne 1b
 787 0058 00C0      		rjmp .
 788 005a 0000      		nop
 789 005c 8150      		subi r24,lo8(-(-1))
 790               	.LVL93:
 791 005e 00C0      		rjmp .L66
 792               	.LVL94:
 793               	.L60:
 794               	/* epilogue start */
 795               	.LBE41:
 796               	.LBE40:
 797               	.LBE39:
 798               	.LBE35:
 812:quantum/quantum.c **** 
 799               		.loc 1 812 0
 800 0060 DF91      		pop r29
 801 0062 CF91      		pop r28
 802               	.LVL95:
 803 0064 1F91      		pop r17
 804 0066 0F91      		pop r16
 805 0068 FF90      		pop r15
 806               	.LVL96:
 807 006a 0895      		ret
 808               		.cfi_endproc
 809               	.LFE128:
 811               		.section	.text.send_string,"ax",@progbits
 812               	.global	send_string
 814               	send_string:
 815               	.LFB126:
 780:quantum/quantum.c ****   send_string_with_delay(str, 0);
 816               		.loc 1 780 0
 817               		.cfi_startproc
 818               	.LVL97:
 819               	/* prologue: function */
 820               	/* frame size = 0 */
 821               	/* stack size = 0 */
 822               	.L__stack_usage = 0
 781:quantum/quantum.c **** }
 823               		.loc 1 781 0
 824 0000 60E0      		ldi r22,0
 825 0002 0C94 0000 		jmp send_string_with_delay
 826               	.LVL98:
 827               		.cfi_endproc
 828               	.LFE126:
 830               		.section	.text.send_string_with_delay_P,"ax",@progbits
 831               	.global	send_string_with_delay_P
 833               	send_string_with_delay_P:
 834               	.LFB129:
 814:quantum/quantum.c ****     while (1) {
 835               		.loc 1 814 0
 836               		.cfi_startproc
 837               	.LVL99:
 838 0000 0F93      		push r16
 839               	.LCFI23:
 840               		.cfi_def_cfa_offset 3
 841               		.cfi_offset 16, -2
 842 0002 1F93      		push r17
 843               	.LCFI24:
 844               		.cfi_def_cfa_offset 4
 845               		.cfi_offset 17, -3
 846 0004 CF93      		push r28
 847               	.LCFI25:
 848               		.cfi_def_cfa_offset 5
 849               		.cfi_offset 28, -4
 850 0006 DF93      		push r29
 851               	.LCFI26:
 852               		.cfi_def_cfa_offset 6
 853               		.cfi_offset 29, -5
 854               	/* prologue: function */
 855               	/* frame size = 0 */
 856               	/* stack size = 4 */
 857               	.L__stack_usage = 4
 858 0008 EC01      		movw r28,r24
 859 000a 062F      		mov r16,r22
 860               	.LVL100:
 861               	.L80:
 862               	.LBB42:
 863               	.LBB43:
 816:quantum/quantum.c ****         if (!ascii_code) break;
 864               		.loc 1 816 0
 865 000c FE01      		movw r30,r28
 866               	/* #APP */
 867               	 ;  816 "quantum/quantum.c" 1
 868 000e 8491      		lpm r24, Z
 869               		
 870               	 ;  0 "" 2
 871               	.LVL101:
 872               	/* #NOAPP */
 873               	.LBE43:
 817:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 874               		.loc 1 817 0
 875 0010 8823      		tst r24
 876 0012 01F0      		breq .L72
 877 0014 9E01      		movw r18,r28
 878 0016 2F5F      		subi r18,-1
 879 0018 3F4F      		sbci r19,-1
 818:quantum/quantum.c ****           // tap
 880               		.loc 1 818 0
 881 001a 8130      		cpi r24,lo8(1)
 882 001c 01F4      		brne .L74
 883               	.LBB44:
 884               	.LBB45:
 820:quantum/quantum.c ****           register_code(keycode);
 885               		.loc 1 820 0
 886 001e E901      		movw r28,r18
 887               	.LVL102:
 888 0020 F901      		movw r30,r18
 889               	.LVL103:
 890               	/* #APP */
 891               	 ;  820 "quantum/quantum.c" 1
 892 0022 1491      		lpm r17, Z
 893               		
 894               	 ;  0 "" 2
 895               	.LVL104:
 896               	/* #NOAPP */
 897               	.LBE45:
 821:quantum/quantum.c ****           unregister_code(keycode);
 898               		.loc 1 821 0
 899 0024 812F      		mov r24,r17
 900               	.LVL105:
 901 0026 0E94 0000 		call register_code
 902               	.LVL106:
 822:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 903               		.loc 1 822 0
 904 002a 812F      		mov r24,r17
 905 002c 00C0      		rjmp .L81
 906               	.LVL107:
 907               	.L74:
 908               	.LBE44:
 823:quantum/quantum.c ****           // down
 909               		.loc 1 823 0
 910 002e 8230      		cpi r24,lo8(2)
 911 0030 01F4      		brne .L76
 912               	.LBB46:
 913               	.LBB47:
 825:quantum/quantum.c ****           register_code(keycode);
 914               		.loc 1 825 0
 915 0032 E901      		movw r28,r18
 916               	.LVL108:
 917 0034 F901      		movw r30,r18
 918               	.LVL109:
 919               	/* #APP */
 920               	 ;  825 "quantum/quantum.c" 1
 921 0036 8491      		lpm r24, Z
 922               		
 923               	 ;  0 "" 2
 924               	.LVL110:
 925               	/* #NOAPP */
 926               	.LBE47:
 826:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 927               		.loc 1 826 0
 928 0038 0E94 0000 		call register_code
 929               	.LVL111:
 930               	.LBE46:
 931 003c 00C0      		rjmp .L75
 932               	.LVL112:
 933               	.L76:
 827:quantum/quantum.c ****           // up
 934               		.loc 1 827 0
 935 003e 8330      		cpi r24,lo8(3)
 936 0040 01F4      		brne .L77
 937               	.LBB48:
 938               	.LBB49:
 829:quantum/quantum.c ****           unregister_code(keycode);
 939               		.loc 1 829 0
 940 0042 E901      		movw r28,r18
 941               	.LVL113:
 942 0044 F901      		movw r30,r18
 943               	.LVL114:
 944               	/* #APP */
 945               	 ;  829 "quantum/quantum.c" 1
 946 0046 8491      		lpm r24, Z
 947               		
 948               	 ;  0 "" 2
 949               	.LVL115:
 950               	/* #NOAPP */
 951               	.L81:
 952               	.LBE49:
 830:quantum/quantum.c ****         } else {
 953               		.loc 1 830 0
 954 0048 0E94 0000 		call unregister_code
 955               	.LVL116:
 956               	.LBE48:
 957 004c 00C0      		rjmp .L75
 958               	.LVL117:
 959               	.L77:
 832:quantum/quantum.c ****         }
 960               		.loc 1 832 0
 961 004e 0E94 0000 		call send_char
 962               	.LVL118:
 963               	.L75:
 834:quantum/quantum.c ****         // interval
 964               		.loc 1 834 0
 965 0052 2196      		adiw r28,1
 966               	.LVL119:
 967               	.LBB50:
 836:quantum/quantum.c ****     }
 968               		.loc 1 836 0
 969 0054 802F      		mov r24,r16
 970               	.LVL120:
 971               	.L78:
 836:quantum/quantum.c ****     }
 972               		.loc 1 836 0 is_stmt 0 discriminator 1
 973 0056 8823      		tst r24
 974 0058 01F0      		breq .L80
 975               	.LVL121:
 976               	.LBB51:
 977               	.LBB52:
 978               		.loc 2 187 0 is_stmt 1
 979 005a EFE9      		ldi r30,lo8(3999)
 980 005c FFE0      		ldi r31,hi8(3999)
 981 005e 3197      	1:	sbiw r30,1
 982 0060 01F4      		brne 1b
 983 0062 00C0      		rjmp .
 984 0064 0000      		nop
 985 0066 8150      		subi r24,lo8(-(-1))
 986               	.LVL122:
 987 0068 00C0      		rjmp .L78
 988               	.LVL123:
 989               	.L72:
 990               	/* epilogue start */
 991               	.LBE52:
 992               	.LBE51:
 993               	.LBE50:
 994               	.LBE42:
 838:quantum/quantum.c **** 
 995               		.loc 1 838 0
 996 006a DF91      		pop r29
 997 006c CF91      		pop r28
 998               	.LVL124:
 999 006e 1F91      		pop r17
 1000 0070 0F91      		pop r16
 1001               	.LVL125:
 1002 0072 0895      		ret
 1003               		.cfi_endproc
 1004               	.LFE129:
 1006               		.section	.text.send_string_P,"ax",@progbits
 1007               	.global	send_string_P
 1009               	send_string_P:
 1010               	.LFB127:
 784:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1011               		.loc 1 784 0
 1012               		.cfi_startproc
 1013               	.LVL126:
 1014               	/* prologue: function */
 1015               	/* frame size = 0 */
 1016               	/* stack size = 0 */
 1017               	.L__stack_usage = 0
 785:quantum/quantum.c **** }
 1018               		.loc 1 785 0
 1019 0000 60E0      		ldi r22,0
 1020 0002 0C94 0000 		jmp send_string_with_delay_P
 1021               	.LVL127:
 1022               		.cfi_endproc
 1023               	.LFE127:
 1025               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1026               	.global	set_single_persistent_default_layer
 1028               	set_single_persistent_default_layer:
 1029               	.LFB131:
 859:quantum/quantum.c **** 
 860:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1030               		.loc 1 860 0
 1031               		.cfi_startproc
 1032               	.LVL128:
 1033 0000 CF93      		push r28
 1034               	.LCFI27:
 1035               		.cfi_def_cfa_offset 3
 1036               		.cfi_offset 28, -2
 1037 0002 DF93      		push r29
 1038               	.LCFI28:
 1039               		.cfi_def_cfa_offset 4
 1040               		.cfi_offset 29, -3
 1041               	/* prologue: function */
 1042               	/* frame size = 0 */
 1043               	/* stack size = 2 */
 1044               	.L__stack_usage = 2
 861:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 862:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 863:quantum/quantum.c ****   #endif
 864:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1045               		.loc 1 864 0
 1046 0004 61E0      		ldi r22,lo8(1)
 1047 0006 70E0      		ldi r23,0
 1048 0008 EB01      		movw r28,r22
 1049 000a 00C0      		rjmp 2f
 1050               		1:
 1051 000c CC0F      		lsl r28
 1052 000e DD1F      		rol r29
 1053               		2:
 1054 0010 8A95      		dec r24
 1055 0012 02F4      		brpl 1b
 1056 0014 8C2F      		mov r24,r28
 1057               	.LVL129:
 1058 0016 0E94 0000 		call eeconfig_update_default_layer
 1059               	.LVL130:
 865:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1060               		.loc 1 865 0
 1061 001a BE01      		movw r22,r28
 1062 001c 80E0      		ldi r24,0
 1063 001e 90E0      		ldi r25,0
 1064               	/* epilogue start */
 866:quantum/quantum.c **** }
 1065               		.loc 1 866 0
 1066 0020 DF91      		pop r29
 1067 0022 CF91      		pop r28
 865:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1068               		.loc 1 865 0
 1069 0024 0C94 0000 		jmp default_layer_set
 1070               	.LVL131:
 1071               		.cfi_endproc
 1072               	.LFE131:
 1074               		.section	.text.update_tri_layer_state,"ax",@progbits
 1075               	.global	update_tri_layer_state
 1077               	update_tri_layer_state:
 1078               	.LFB132:
 867:quantum/quantum.c **** 
 868:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1079               		.loc 1 868 0
 1080               		.cfi_startproc
 1081               	.LVL132:
 1082 0000 8F92      		push r8
 1083               	.LCFI29:
 1084               		.cfi_def_cfa_offset 3
 1085               		.cfi_offset 8, -2
 1086 0002 9F92      		push r9
 1087               	.LCFI30:
 1088               		.cfi_def_cfa_offset 4
 1089               		.cfi_offset 9, -3
 1090 0004 AF92      		push r10
 1091               	.LCFI31:
 1092               		.cfi_def_cfa_offset 5
 1093               		.cfi_offset 10, -4
 1094 0006 BF92      		push r11
 1095               	.LCFI32:
 1096               		.cfi_def_cfa_offset 6
 1097               		.cfi_offset 11, -5
 1098 0008 CF92      		push r12
 1099               	.LCFI33:
 1100               		.cfi_def_cfa_offset 7
 1101               		.cfi_offset 12, -6
 1102 000a DF92      		push r13
 1103               	.LCFI34:
 1104               		.cfi_def_cfa_offset 8
 1105               		.cfi_offset 13, -7
 1106 000c EF92      		push r14
 1107               	.LCFI35:
 1108               		.cfi_def_cfa_offset 9
 1109               		.cfi_offset 14, -8
 1110 000e FF92      		push r15
 1111               	.LCFI36:
 1112               		.cfi_def_cfa_offset 10
 1113               		.cfi_offset 15, -9
 1114 0010 0F93      		push r16
 1115               	.LCFI37:
 1116               		.cfi_def_cfa_offset 11
 1117               		.cfi_offset 16, -10
 1118 0012 1F93      		push r17
 1119               	.LCFI38:
 1120               		.cfi_def_cfa_offset 12
 1121               		.cfi_offset 17, -11
 1122               	/* prologue: function */
 1123               	/* frame size = 0 */
 1124               	/* stack size = 10 */
 1125               	.L__stack_usage = 10
 1126 0014 6B01      		movw r12,r22
 1127 0016 7C01      		movw r14,r24
 869:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1128               		.loc 1 869 0
 1129 0018 81E0      		ldi r24,lo8(1)
 1130 001a 90E0      		ldi r25,0
 1131 001c A0E0      		ldi r26,0
 1132 001e B0E0      		ldi r27,0
 1133 0020 4C01      		movw r8,r24
 1134 0022 5D01      		movw r10,r26
 1135 0024 00C0      		rjmp 2f
 1136               		1:
 1137 0026 880C      		lsl r8
 1138 0028 991C      		rol r9
 1139 002a AA1C      		rol r10
 1140 002c BB1C      		rol r11
 1141               		2:
 1142 002e 4A95      		dec r20
 1143 0030 02F4      		brpl 1b
 1144 0032 AC01      		movw r20,r24
 1145 0034 BD01      		movw r22,r26
 1146               	.LVL133:
 1147 0036 00C0      		rjmp 2f
 1148               		1:
 1149 0038 440F      		lsl r20
 1150 003a 551F      		rol r21
 1151 003c 661F      		rol r22
 1152 003e 771F      		rol r23
 1153               		2:
 1154 0040 2A95      		dec r18
 1155 0042 02F4      		brpl 1b
 1156 0044 4829      		or r20,r8
 1157 0046 5929      		or r21,r9
 1158 0048 6A29      		or r22,r10
 1159 004a 7B29      		or r23,r11
 1160               	.LVL134:
 870:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 1161               		.loc 1 870 0
 1162 004c 00C0      		rjmp 2f
 1163               		1:
 1164 004e 880F      		lsl r24
 1165 0050 991F      		rol r25
 1166 0052 AA1F      		rol r26
 1167 0054 BB1F      		rol r27
 1168               		2:
 1169 0056 0A95      		dec r16
 1170 0058 02F4      		brpl 1b
 1171               	.LVL135:
 871:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1172               		.loc 1 871 0
 1173 005a 8A01      		movw r16,r20
 1174 005c 9B01      		movw r18,r22
 1175               	.LVL136:
 1176 005e 0C21      		and r16,r12
 1177 0060 1D21      		and r17,r13
 1178 0062 2E21      		and r18,r14
 1179 0064 3F21      		and r19,r15
 1180 0066 4017      		cp r20,r16
 1181 0068 5107      		cpc r21,r17
 1182 006a 6207      		cpc r22,r18
 1183 006c 7307      		cpc r23,r19
 1184 006e 01F4      		brne .L85
 1185               		.loc 1 871 0 is_stmt 0 discriminator 1
 1186 0070 BC01      		movw r22,r24
 1187 0072 CD01      		movw r24,r26
 1188               	.LVL137:
 1189 0074 6C29      		or r22,r12
 1190 0076 7D29      		or r23,r13
 1191 0078 8E29      		or r24,r14
 1192 007a 9F29      		or r25,r15
 1193 007c 00C0      		rjmp .L86
 1194               	.L85:
 1195               		.loc 1 871 0 discriminator 2
 1196 007e 8095      		com r24
 1197 0080 9095      		com r25
 1198 0082 A095      		com r26
 1199 0084 B095      		com r27
 1200               	.LVL138:
 1201 0086 BC01      		movw r22,r24
 1202 0088 CD01      		movw r24,r26
 1203 008a 6C21      		and r22,r12
 1204 008c 7D21      		and r23,r13
 1205 008e 8E21      		and r24,r14
 1206 0090 9F21      		and r25,r15
 1207               	.LVL139:
 1208               	.L86:
 1209               	/* epilogue start */
 872:quantum/quantum.c **** }
 1210               		.loc 1 872 0 is_stmt 1 discriminator 4
 1211 0092 1F91      		pop r17
 1212               	.LVL140:
 1213 0094 0F91      		pop r16
 1214               	.LVL141:
 1215 0096 FF90      		pop r15
 1216 0098 EF90      		pop r14
 1217 009a DF90      		pop r13
 1218 009c CF90      		pop r12
 1219               	.LVL142:
 1220 009e BF90      		pop r11
 1221 00a0 AF90      		pop r10
 1222 00a2 9F90      		pop r9
 1223 00a4 8F90      		pop r8
 1224               	.LVL143:
 1225 00a6 0895      		ret
 1226               		.cfi_endproc
 1227               	.LFE132:
 1229               		.section	.text.update_tri_layer,"ax",@progbits
 1230               	.global	update_tri_layer
 1232               	update_tri_layer:
 1233               	.LFB133:
 873:quantum/quantum.c **** 
 874:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1234               		.loc 1 874 0
 1235               		.cfi_startproc
 1236               	.LVL144:
 1237 0000 0F93      		push r16
 1238               	.LCFI39:
 1239               		.cfi_def_cfa_offset 3
 1240               		.cfi_offset 16, -2
 1241               	/* prologue: function */
 1242               	/* frame size = 0 */
 1243               	/* stack size = 1 */
 1244               	.L__stack_usage = 1
 1245 0002 382F      		mov r19,r24
 1246 0004 262F      		mov r18,r22
 875:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1247               		.loc 1 875 0
 1248 0006 6091 0000 		lds r22,layer_state
 1249 000a 7091 0000 		lds r23,layer_state+1
 1250 000e 8091 0000 		lds r24,layer_state+2
 1251 0012 9091 0000 		lds r25,layer_state+3
 1252               	.LVL145:
 1253 0016 042F      		mov r16,r20
 1254 0018 432F      		mov r20,r19
 1255               	.LVL146:
 1256 001a 0E94 0000 		call update_tri_layer_state
 1257               	.LVL147:
 1258               	/* epilogue start */
 876:quantum/quantum.c **** }
 1259               		.loc 1 876 0
 1260 001e 0F91      		pop r16
 1261               	.LVL148:
 875:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1262               		.loc 1 875 0
 1263 0020 0C94 0000 		jmp layer_state_set
 1264               	.LVL149:
 1265               		.cfi_endproc
 1266               	.LFE133:
 1268               		.section	.text.tap_random_base64,"ax",@progbits
 1269               	.global	tap_random_base64
 1271               	tap_random_base64:
 1272               	.LFB134:
 877:quantum/quantum.c **** 
 878:quantum/quantum.c **** void tap_random_base64(void) {
 1273               		.loc 1 878 0
 1274               		.cfi_startproc
 1275 0000 CF93      		push r28
 1276               	.LCFI40:
 1277               		.cfi_def_cfa_offset 3
 1278               		.cfi_offset 28, -2
 1279 0002 DF93      		push r29
 1280               	.LCFI41:
 1281               		.cfi_def_cfa_offset 4
 1282               		.cfi_offset 29, -3
 1283               	/* prologue: function */
 1284               	/* frame size = 0 */
 1285               	/* stack size = 2 */
 1286               	.L__stack_usage = 2
 879:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 880:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1287               		.loc 1 880 0
 1288 0004 26B5      		in r18,0x26
 1289 0006 C091 8400 		lds r28,132
 1290 000a D091 8500 		lds r29,132+1
 1291 000e 4091 9400 		lds r20,148
 1292 0012 5091 9500 		lds r21,148+1
 1293 0016 8091 BE00 		lds r24,190
 1294 001a 9091 BF00 		lds r25,190+1
 1295 001e C40F      		add r28,r20
 1296 0020 C20F      		add r28,r18
 1297 0022 8C0F      		add r24,r28
 1298 0024 C82F      		mov r28,r24
 1299 0026 CF73      		andi r28,lo8(63)
 1300               	.LVL150:
 881:quantum/quantum.c ****   #else
 882:quantum/quantum.c ****     uint8_t key = rand() % 64;
 883:quantum/quantum.c ****   #endif
 884:quantum/quantum.c ****   switch (key) {
 1301               		.loc 1 884 0
 1302 0028 CE33      		cpi r28,lo8(62)
 1303 002a 00F4      		brsh .L90
 1304 002c C533      		cpi r28,lo8(53)
 1305 002e 00F4      		brsh .L91
 1306 0030 CA31      		cpi r28,lo8(26)
 1307 0032 00F0      		brlo .L89
 1308 0034 C433      		cpi r28,lo8(52)
 1309 0036 00F4      		brsh .L96
 885:quantum/quantum.c ****     case 0 ... 25:
 886:quantum/quantum.c ****       register_code(KC_LSFT);
 887:quantum/quantum.c ****       register_code(key + KC_A);
 888:quantum/quantum.c ****       unregister_code(key + KC_A);
 889:quantum/quantum.c ****       unregister_code(KC_LSFT);
 890:quantum/quantum.c ****       break;
 891:quantum/quantum.c ****     case 26 ... 51:
 892:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1310               		.loc 1 892 0
 1311 0038 C651      		subi r28,lo8(-(-22))
 1312               	.LVL151:
 1313 003a 00C0      		rjmp .L99
 1314               	.LVL152:
 1315               	.L90:
 884:quantum/quantum.c ****     case 0 ... 25:
 1316               		.loc 1 884 0
 1317 003c CE33      		cpi r28,lo8(62)
 1318 003e 01F0      		breq .L94
 1319 0040 CF33      		cpi r28,lo8(63)
 1320 0042 01F0      		breq .L95
 1321               	.L89:
 886:quantum/quantum.c ****       register_code(key + KC_A);
 1322               		.loc 1 886 0
 1323 0044 81EE      		ldi r24,lo8(-31)
 1324 0046 0E94 0000 		call register_code
 1325               	.LVL153:
 887:quantum/quantum.c ****       unregister_code(key + KC_A);
 1326               		.loc 1 887 0
 1327 004a CC5F      		subi r28,lo8(-(4))
 1328               	.LVL154:
 1329 004c 8C2F      		mov r24,r28
 1330 004e 0E94 0000 		call register_code
 1331               	.LVL155:
 888:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1332               		.loc 1 888 0
 1333 0052 8C2F      		mov r24,r28
 1334 0054 00C0      		rjmp .L98
 1335               	.LVL156:
 1336               	.L96:
 893:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 894:quantum/quantum.c ****       break;
 895:quantum/quantum.c ****     case 52:
 896:quantum/quantum.c ****       register_code(KC_0);
 1337               		.loc 1 896 0
 1338 0056 87E2      		ldi r24,lo8(39)
 1339 0058 0E94 0000 		call register_code
 1340               	.LVL157:
 897:quantum/quantum.c ****       unregister_code(KC_0);
 1341               		.loc 1 897 0
 1342 005c 87E2      		ldi r24,lo8(39)
 1343 005e 00C0      		rjmp .L97
 1344               	.L91:
 898:quantum/quantum.c ****       break;
 899:quantum/quantum.c ****     case 53 ... 61:
 900:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1345               		.loc 1 900 0
 1346 0060 C751      		subi r28,lo8(-(-23))
 1347               	.LVL158:
 1348               	.L99:
 1349 0062 8C2F      		mov r24,r28
 1350               	.LVL159:
 1351 0064 0E94 0000 		call register_code
 1352               	.LVL160:
 901:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1353               		.loc 1 901 0
 1354 0068 8C2F      		mov r24,r28
 1355 006a 00C0      		rjmp .L97
 1356               	.LVL161:
 1357               	.L94:
 902:quantum/quantum.c ****       break;
 903:quantum/quantum.c ****     case 62:
 904:quantum/quantum.c ****       register_code(KC_LSFT);
 1358               		.loc 1 904 0
 1359 006c 81EE      		ldi r24,lo8(-31)
 1360 006e 0E94 0000 		call register_code
 1361               	.LVL162:
 905:quantum/quantum.c ****       register_code(KC_EQL);
 1362               		.loc 1 905 0
 1363 0072 8EE2      		ldi r24,lo8(46)
 1364 0074 0E94 0000 		call register_code
 1365               	.LVL163:
 906:quantum/quantum.c ****       unregister_code(KC_EQL);
 1366               		.loc 1 906 0
 1367 0078 8EE2      		ldi r24,lo8(46)
 1368               	.LVL164:
 1369               	.L98:
 1370 007a 0E94 0000 		call unregister_code
 1371               	.LVL165:
 907:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1372               		.loc 1 907 0
 1373 007e 81EE      		ldi r24,lo8(-31)
 1374 0080 00C0      		rjmp .L97
 1375               	.LVL166:
 1376               	.L95:
 908:quantum/quantum.c ****       break;
 909:quantum/quantum.c ****     case 63:
 910:quantum/quantum.c ****       register_code(KC_SLSH);
 1377               		.loc 1 910 0
 1378 0082 88E3      		ldi r24,lo8(56)
 1379 0084 0E94 0000 		call register_code
 1380               	.LVL167:
 911:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1381               		.loc 1 911 0
 1382 0088 88E3      		ldi r24,lo8(56)
 1383               	.LVL168:
 1384               	.L97:
 1385               	/* epilogue start */
 912:quantum/quantum.c ****       break;
 913:quantum/quantum.c ****   }
 914:quantum/quantum.c **** }
 1386               		.loc 1 914 0
 1387 008a DF91      		pop r29
 1388 008c CF91      		pop r28
 911:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1389               		.loc 1 911 0
 1390 008e 0C94 0000 		jmp unregister_code
 1391               	.LVL169:
 1392               		.cfi_endproc
 1393               	.LFE134:
 1395               		.section	.text.bootmagic_lite,"ax",@progbits
 1396               		.weak	bootmagic_lite
 1398               	bootmagic_lite:
 1399               	.LFB135:
 915:quantum/quantum.c **** 
 916:quantum/quantum.c **** __attribute__((weak))
 917:quantum/quantum.c **** void bootmagic_lite(void) {
 1400               		.loc 1 917 0
 1401               		.cfi_startproc
 1402               	/* prologue: function */
 1403               	/* frame size = 0 */
 1404               	/* stack size = 0 */
 1405               	.L__stack_usage = 0
 918:quantum/quantum.c ****   // The lite version of TMK's bootmagic based on Wilba.
 919:quantum/quantum.c ****   // 100% less potential for accidentally making the
 920:quantum/quantum.c ****   // keyboard do stupid things.
 921:quantum/quantum.c **** 
 922:quantum/quantum.c ****   // We need multiple scans because debouncing can't be turned off.
 923:quantum/quantum.c ****   matrix_scan();
 1406               		.loc 1 923 0
 1407 0000 0E94 0000 		call matrix_scan
 1408               	.LVL170:
 1409               	.LBB53:
 1410               	.LBB54:
 1411               		.loc 2 187 0
 1412 0004 8FE3      		ldi r24,lo8(-25537)
 1413 0006 9CE9      		ldi r25,hi8(-25537)
 1414 0008 0197      	1:	sbiw r24,1
 1415 000a 01F4      		brne 1b
 1416 000c 00C0      		rjmp .
 1417 000e 0000      		nop
 1418               	.LVL171:
 1419               	.LBE54:
 1420               	.LBE53:
 924:quantum/quantum.c ****   #if defined(DEBOUNCING_DELAY) && DEBOUNCING_DELAY > 0
 925:quantum/quantum.c ****     wait_ms(DEBOUNCING_DELAY * 2);
 926:quantum/quantum.c ****   #elif defined(DEBOUNCE) && DEBOUNCE > 0
 927:quantum/quantum.c ****     wait_ms(DEBOUNCE * 2);
 928:quantum/quantum.c ****   #else
 929:quantum/quantum.c ****     wait_ms(30);
 930:quantum/quantum.c ****   #endif
 931:quantum/quantum.c ****   matrix_scan();
 1421               		.loc 1 931 0
 1422 0010 0E94 0000 		call matrix_scan
 1423               	.LVL172:
 932:quantum/quantum.c **** 
 933:quantum/quantum.c ****   // If the Esc and space bar are held down on power up,
 934:quantum/quantum.c ****   // reset the EEPROM valid state and jump to bootloader.
 935:quantum/quantum.c ****   // Assumes Esc is at [0,0].
 936:quantum/quantum.c ****   // This isn't very generalized, but we need something that doesn't
 937:quantum/quantum.c ****   // rely on user's keymaps in firmware or EEPROM.
 938:quantum/quantum.c ****   if (matrix_get_row(BOOTMAGIC_LITE_ROW) & (1 << BOOTMAGIC_LITE_COLUMN)) {
 1424               		.loc 1 938 0
 1425 0014 80E0      		ldi r24,0
 1426 0016 0E94 0000 		call matrix_get_row
 1427               	.LVL173:
 1428 001a 80FF      		sbrs r24,0
 1429 001c 00C0      		rjmp .L100
 939:quantum/quantum.c ****     eeconfig_disable();
 1430               		.loc 1 939 0
 1431 001e 0E94 0000 		call eeconfig_disable
 1432               	.LVL174:
 940:quantum/quantum.c ****     // Jump to bootloader.
 941:quantum/quantum.c ****     bootloader_jump();
 1433               		.loc 1 941 0
 1434 0022 0C94 0000 		jmp bootloader_jump
 1435               	.LVL175:
 1436               	.L100:
 1437 0026 0895      		ret
 1438               		.cfi_endproc
 1439               	.LFE135:
 1441               		.section	.text.matrix_init_quantum,"ax",@progbits
 1442               	.global	matrix_init_quantum
 1444               	matrix_init_quantum:
 1445               	.LFB136:
 942:quantum/quantum.c ****   }
 943:quantum/quantum.c **** }
 944:quantum/quantum.c **** 
 945:quantum/quantum.c **** void matrix_init_quantum() {
 1446               		.loc 1 945 0
 1447               		.cfi_startproc
 1448               	/* prologue: function */
 1449               	/* frame size = 0 */
 1450               	/* stack size = 0 */
 1451               	.L__stack_usage = 0
 946:quantum/quantum.c ****   #ifdef BOOTMAGIC_LITE
 947:quantum/quantum.c ****     bootmagic_lite();
 948:quantum/quantum.c ****   #endif
 949:quantum/quantum.c ****   if (!eeconfig_is_enabled()) {
 1452               		.loc 1 949 0
 1453 0000 0E94 0000 		call eeconfig_is_enabled
 1454               	.LVL176:
 1455 0004 8111      		cpse r24,__zero_reg__
 1456 0006 00C0      		rjmp .L103
 950:quantum/quantum.c ****     eeconfig_init();
 1457               		.loc 1 950 0
 1458 0008 0E94 0000 		call eeconfig_init
 1459               	.LVL177:
 1460               	.L103:
 951:quantum/quantum.c ****   }
 952:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 953:quantum/quantum.c ****     #ifdef LED_MATRIX_ENABLE
 954:quantum/quantum.c ****         led_matrix_init();
 955:quantum/quantum.c ****     #else
 956:quantum/quantum.c ****         backlight_init_ports();
 957:quantum/quantum.c ****     #endif
 958:quantum/quantum.c ****   #endif
 959:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 960:quantum/quantum.c ****     audio_init();
 961:quantum/quantum.c ****   #endif
 962:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 963:quantum/quantum.c ****     rgb_matrix_init();
 964:quantum/quantum.c ****   #endif
 965:quantum/quantum.c ****   #ifdef ENCODER_ENABLE
 966:quantum/quantum.c ****     encoder_init();
 967:quantum/quantum.c ****   #endif
 968:quantum/quantum.c ****   #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 969:quantum/quantum.c ****     unicode_input_mode_init();
 970:quantum/quantum.c ****   #endif
 971:quantum/quantum.c ****   #ifdef HAPTIC_ENABLE
 972:quantum/quantum.c ****     haptic_init();
 973:quantum/quantum.c ****   #endif
 974:quantum/quantum.c ****   #ifdef OUTPUT_AUTO_ENABLE
 975:quantum/quantum.c ****     set_output(OUTPUT_AUTO);
 976:quantum/quantum.c ****   #endif
 977:quantum/quantum.c ****   matrix_init_kb();
 1461               		.loc 1 977 0
 1462 000c 0C94 0000 		jmp matrix_init_kb
 1463               	.LVL178:
 1464               		.cfi_endproc
 1465               	.LFE136:
 1467               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1468               	.global	matrix_scan_quantum
 1470               	matrix_scan_quantum:
 1471               	.LFB137:
 978:quantum/quantum.c **** }
 979:quantum/quantum.c **** 
 980:quantum/quantum.c **** void matrix_scan_quantum() {
 1472               		.loc 1 980 0
 1473               		.cfi_startproc
 1474               	/* prologue: function */
 1475               	/* frame size = 0 */
 1476               	/* stack size = 0 */
 1477               	.L__stack_usage = 0
 981:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 982:quantum/quantum.c ****     matrix_scan_music();
 983:quantum/quantum.c ****   #endif
 984:quantum/quantum.c **** 
 985:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 986:quantum/quantum.c ****     matrix_scan_tap_dance();
 987:quantum/quantum.c ****   #endif
 988:quantum/quantum.c **** 
 989:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 990:quantum/quantum.c ****     matrix_scan_combo();
 991:quantum/quantum.c ****   #endif
 992:quantum/quantum.c **** 
 993:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE)
 994:quantum/quantum.c ****     #if defined(LED_MATRIX_ENABLE)
 995:quantum/quantum.c ****         led_matrix_task();
 996:quantum/quantum.c ****     #elif defined(BACKLIGHT_PIN)
 997:quantum/quantum.c ****         backlight_task();
 998:quantum/quantum.c ****     #endif
 999:quantum/quantum.c ****   #endif
1000:quantum/quantum.c **** 
1001:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
1002:quantum/quantum.c ****     rgb_matrix_task();
1003:quantum/quantum.c ****   #endif
1004:quantum/quantum.c **** 
1005:quantum/quantum.c ****   #ifdef ENCODER_ENABLE
1006:quantum/quantum.c ****     encoder_read();
1007:quantum/quantum.c ****   #endif
1008:quantum/quantum.c **** 
1009:quantum/quantum.c ****   #ifdef HAPTIC_ENABLE
1010:quantum/quantum.c ****     haptic_task();
1011:quantum/quantum.c ****   #endif
1012:quantum/quantum.c **** 
1013:quantum/quantum.c ****   matrix_scan_kb();
 1478               		.loc 1 1013 0
 1479 0000 0C94 0000 		jmp matrix_scan_kb
 1480               	.LVL179:
 1481               		.cfi_endproc
 1482               	.LFE137:
 1484               		.section	.text.send_nibble,"ax",@progbits
 1485               	.global	send_nibble
 1487               	send_nibble:
 1488               	.LFB143:
1014:quantum/quantum.c **** }
1015:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && (defined(BACKLIGHT_PIN) || defined(BACKLIGHT_PINS))
1016:quantum/quantum.c **** 
1017:quantum/quantum.c **** // The logic is a bit complex, we support 3 setups:
1018:quantum/quantum.c **** // 1. hardware PWM when backlight is wired to a PWM pin
1019:quantum/quantum.c **** // depending on this pin, we use a different output compare unit
1020:quantum/quantum.c **** // 2. software PWM with hardware timers, but the used timer depends
1021:quantum/quantum.c **** // on the audio setup (audio wins other backlight)
1022:quantum/quantum.c **** // 3. full software PWM
1023:quantum/quantum.c **** 
1024:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
1025:quantum/quantum.c **** #  define HARDWARE_PWM
1026:quantum/quantum.c **** #  define TCCRxA TCCR1A
1027:quantum/quantum.c **** #  define TCCRxB TCCR1B
1028:quantum/quantum.c **** #  define COMxx1 COM1C1
1029:quantum/quantum.c **** #  define OCRxx  OCR1C
1030:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER1_OVF_vect
1031:quantum/quantum.c **** #  define TOIEx  TOIE1
1032:quantum/quantum.c **** #  define ICRx   ICR1
1033:quantum/quantum.c **** #  define TIMSKx TIMSK1
1034:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
1035:quantum/quantum.c **** #  define HARDWARE_PWM
1036:quantum/quantum.c **** #  define TCCRxA TCCR1A
1037:quantum/quantum.c **** #  define TCCRxB TCCR1B
1038:quantum/quantum.c **** #  define COMxx1 COM1B1
1039:quantum/quantum.c **** #  define OCRxx  OCR1B
1040:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER1_OVF_vect
1041:quantum/quantum.c **** #  define TOIEx  TOIE1
1042:quantum/quantum.c **** #  define ICRx   ICR1
1043:quantum/quantum.c **** #  define TIMSKx TIMSK1
1044:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
1045:quantum/quantum.c **** #  define HARDWARE_PWM
1046:quantum/quantum.c **** #  define TCCRxA TCCR1A
1047:quantum/quantum.c **** #  define TCCRxB TCCR1B
1048:quantum/quantum.c **** #  define COMxx1 COM1A1
1049:quantum/quantum.c **** #  define OCRxx  OCR1A
1050:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER1_OVF_vect
1051:quantum/quantum.c **** #  define TOIEx  TOIE1
1052:quantum/quantum.c **** #  define ICRx   ICR1
1053:quantum/quantum.c **** #  define TIMSKx TIMSK1
1054:quantum/quantum.c **** #elif BACKLIGHT_PIN == C6
1055:quantum/quantum.c **** #  define HARDWARE_PWM
1056:quantum/quantum.c **** #  define TCCRxA TCCR3A
1057:quantum/quantum.c **** #  define TCCRxB TCCR3B
1058:quantum/quantum.c **** #  define COMxx1 COM3A1
1059:quantum/quantum.c **** #  define OCRxx  OCR3A
1060:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER3_OVF_vect
1061:quantum/quantum.c **** #  define TOIEx  TOIE3
1062:quantum/quantum.c **** #  define ICRx   ICR3
1063:quantum/quantum.c **** #  define TIMSKx TIMSK3
1064:quantum/quantum.c **** #elif defined(__AVR_ATmega32A__) && BACKLIGHT_PIN == D4
1065:quantum/quantum.c **** #  define TCCRxA TCCR1A
1066:quantum/quantum.c **** #  define TCCRxB TCCR1B
1067:quantum/quantum.c **** #  define COMxx1 COM1B1
1068:quantum/quantum.c **** #  define OCRxx  OCR1B
1069:quantum/quantum.c **** #  define TIMERx_OVF_vect TIMER1_OVF_vect
1070:quantum/quantum.c **** #  define TOIEx  TOIE1
1071:quantum/quantum.c **** #  define ICRx   ICR1
1072:quantum/quantum.c **** #  define TIMSKx TIMSK1
1073:quantum/quantum.c **** #else
1074:quantum/quantum.c **** #  if !defined(BACKLIGHT_CUSTOM_DRIVER)
1075:quantum/quantum.c **** #    if !defined(B5_AUDIO) && !defined(B6_AUDIO) && !defined(B7_AUDIO)
1076:quantum/quantum.c ****      // timer 1 is not used by audio , backlight can use it
1077:quantum/quantum.c **** #pragma message "Using hardware timer 1 with software PWM"
1078:quantum/quantum.c **** #      define HARDWARE_PWM
1079:quantum/quantum.c **** #      define BACKLIGHT_PWM_TIMER
1080:quantum/quantum.c **** #      define TCCRxA TCCR1A
1081:quantum/quantum.c **** #      define TCCRxB TCCR1B
1082:quantum/quantum.c **** #      define OCRxx  OCR1A
1083:quantum/quantum.c **** #      define TIMERx_COMPA_vect TIMER1_COMPA_vect
1084:quantum/quantum.c **** #      define TIMERx_OVF_vect TIMER1_OVF_vect
1085:quantum/quantum.c **** #      define OCIExA OCIE1A
1086:quantum/quantum.c **** #      define TOIEx  TOIE1
1087:quantum/quantum.c **** #      define ICRx   ICR1
1088:quantum/quantum.c **** #      if defined(__AVR_ATmega32A__) // This MCU has only one TIMSK register
1089:quantum/quantum.c **** #        define TIMSKx TIMSK
1090:quantum/quantum.c **** #      else
1091:quantum/quantum.c **** #        define TIMSKx TIMSK1
1092:quantum/quantum.c **** #      endif
1093:quantum/quantum.c **** #    elif !defined(C6_AUDIO) && !defined(C5_AUDIO) && !defined(C4_AUDIO)
1094:quantum/quantum.c **** #pragma message "Using hardware timer 3 with software PWM"
1095:quantum/quantum.c **** // timer 3 is not used by audio, backlight can use it
1096:quantum/quantum.c **** #      define HARDWARE_PWM
1097:quantum/quantum.c **** #      define BACKLIGHT_PWM_TIMER
1098:quantum/quantum.c **** #      define TCCRxA TCCR3A
1099:quantum/quantum.c **** #      define TCCRxB TCCR3B
1100:quantum/quantum.c **** #      define OCRxx OCR3A
1101:quantum/quantum.c **** #      define TIMERx_COMPA_vect TIMER3_COMPA_vect
1102:quantum/quantum.c **** #      define TIMERx_OVF_vect TIMER3_OVF_vect
1103:quantum/quantum.c **** #      define OCIExA OCIE3A
1104:quantum/quantum.c **** #      define TOIEx  TOIE3
1105:quantum/quantum.c **** #      define ICRx   ICR1
1106:quantum/quantum.c **** #      define TIMSKx TIMSK3
1107:quantum/quantum.c **** #    else
1108:quantum/quantum.c **** #pragma message "Audio in use - using pure software PWM"
1109:quantum/quantum.c **** #define NO_HARDWARE_PWM
1110:quantum/quantum.c **** #    endif
1111:quantum/quantum.c **** #  else
1112:quantum/quantum.c **** #pragma message "Custom driver defined - using pure software PWM"
1113:quantum/quantum.c **** #define NO_HARDWARE_PWM
1114:quantum/quantum.c **** #  endif
1115:quantum/quantum.c **** #endif
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
1118:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
1119:quantum/quantum.c **** #endif
1120:quantum/quantum.c **** 
1121:quantum/quantum.c **** void backlight_on(uint8_t backlight_pin) {
1122:quantum/quantum.c **** #if BACKLIGHT_ON_STATE == 0
1123:quantum/quantum.c ****   writePinLow(backlight_pin);
1124:quantum/quantum.c **** #else
1125:quantum/quantum.c ****   writePinHigh(backlight_pin);
1126:quantum/quantum.c **** #endif
1127:quantum/quantum.c **** }
1128:quantum/quantum.c **** 
1129:quantum/quantum.c **** void backlight_off(uint8_t backlight_pin) {
1130:quantum/quantum.c **** #if BACKLIGHT_ON_STATE == 0
1131:quantum/quantum.c ****   writePinHigh(backlight_pin);
1132:quantum/quantum.c **** #else
1133:quantum/quantum.c ****   writePinLow(backlight_pin);
1134:quantum/quantum.c **** #endif
1135:quantum/quantum.c **** }
1136:quantum/quantum.c **** 
1137:quantum/quantum.c **** 
1138:quantum/quantum.c **** #if defined(NO_HARDWARE_PWM) || defined(BACKLIGHT_PWM_TIMER)  // pwm through software
1139:quantum/quantum.c **** 
1140:quantum/quantum.c **** // we support multiple backlight pins
1141:quantum/quantum.c **** #ifndef BACKLIGHT_LED_COUNT
1142:quantum/quantum.c **** #define BACKLIGHT_LED_COUNT 1
1143:quantum/quantum.c **** #endif
1144:quantum/quantum.c **** 
1145:quantum/quantum.c **** #if BACKLIGHT_LED_COUNT == 1
1146:quantum/quantum.c **** #define BACKLIGHT_PIN_INIT { BACKLIGHT_PIN }
1147:quantum/quantum.c **** #else
1148:quantum/quantum.c **** #define BACKLIGHT_PIN_INIT BACKLIGHT_PINS
1149:quantum/quantum.c **** #endif
1150:quantum/quantum.c **** 
1151:quantum/quantum.c **** #define FOR_EACH_LED(x)                             \
1152:quantum/quantum.c ****   for (uint8_t i = 0; i < BACKLIGHT_LED_COUNT; i++) \
1153:quantum/quantum.c ****   {                                                 \
1154:quantum/quantum.c ****     uint8_t backlight_pin = backlight_pins[i];      \
1155:quantum/quantum.c ****     { \
1156:quantum/quantum.c ****       x                         \
1157:quantum/quantum.c ****     }                                             \
1158:quantum/quantum.c ****   }
1159:quantum/quantum.c **** 
1160:quantum/quantum.c **** static const uint8_t backlight_pins[BACKLIGHT_LED_COUNT] = BACKLIGHT_PIN_INIT;
1161:quantum/quantum.c **** 
1162:quantum/quantum.c **** #else // full hardware PWM
1163:quantum/quantum.c **** 
1164:quantum/quantum.c **** // we support only one backlight pin
1165:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
1166:quantum/quantum.c **** #define FOR_EACH_LED(x) x
1167:quantum/quantum.c **** 
1168:quantum/quantum.c **** #endif
1169:quantum/quantum.c **** 
1170:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM
1171:quantum/quantum.c **** __attribute__((weak))
1172:quantum/quantum.c **** void backlight_init_ports(void)
1173:quantum/quantum.c **** {
1174:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1175:quantum/quantum.c ****   FOR_EACH_LED(
1176:quantum/quantum.c ****     setPinOutput(backlight_pin);
1177:quantum/quantum.c ****     backlight_on(backlight_pin);
1178:quantum/quantum.c ****   )
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** __attribute__ ((weak))
1182:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1183:quantum/quantum.c **** 
1184:quantum/quantum.c **** uint8_t backlight_tick = 0;
1185:quantum/quantum.c **** 
1186:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
1187:quantum/quantum.c **** void backlight_task(void) {
1188:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
1189:quantum/quantum.c ****     FOR_EACH_LED(
1190:quantum/quantum.c ****       backlight_on(backlight_pin);
1191:quantum/quantum.c ****     )
1192:quantum/quantum.c ****   }
1193:quantum/quantum.c ****   else {
1194:quantum/quantum.c ****     FOR_EACH_LED(
1195:quantum/quantum.c ****       backlight_off(backlight_pin);
1196:quantum/quantum.c ****     )
1197:quantum/quantum.c ****   }
1198:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
1199:quantum/quantum.c **** }
1200:quantum/quantum.c **** #endif
1201:quantum/quantum.c **** 
1202:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1203:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
1204:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
1205:quantum/quantum.c ****   #endif
1206:quantum/quantum.c **** #endif
1207:quantum/quantum.c **** 
1208:quantum/quantum.c **** #else // hardware pwm through timer
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** #ifdef BACKLIGHT_PWM_TIMER
1211:quantum/quantum.c **** 
1212:quantum/quantum.c **** // The idea of software PWM assisted by hardware timers is the following
1213:quantum/quantum.c **** // we use the hardware timer in fast PWM mode like for hardware PWM, but
1214:quantum/quantum.c **** // instead of letting the Output Match Comparator control the led pin
1215:quantum/quantum.c **** // (which is not possible since the backlight is not wired to PWM pins on the
1216:quantum/quantum.c **** // CPU), we do the LED on/off by oursleves.
1217:quantum/quantum.c **** // The timer is setup to count up to 0xFFFF, and we set the Output Compare
1218:quantum/quantum.c **** // register to the current 16bits backlight level (after CIE correction).
1219:quantum/quantum.c **** // This means the CPU will trigger a compare match interrupt when the counter
1220:quantum/quantum.c **** // reaches the backlight level, where we turn off the LEDs,
1221:quantum/quantum.c **** // but also an overflow interrupt when the counter rolls back to 0,
1222:quantum/quantum.c **** // in which we're going to turn on the LEDs.
1223:quantum/quantum.c **** // The LED will then be on for OCRxx/0xFFFF time, adjusted every 244Hz.
1224:quantum/quantum.c **** 
1225:quantum/quantum.c **** // Triggered when the counter reaches the OCRx value
1226:quantum/quantum.c **** ISR(TIMERx_COMPA_vect) {
1227:quantum/quantum.c ****   FOR_EACH_LED(
1228:quantum/quantum.c ****     backlight_off(backlight_pin);
1229:quantum/quantum.c ****   )
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** // Triggered when the counter reaches the TOP value
1233:quantum/quantum.c **** // this one triggers at F_CPU/65536 =~ 244 Hz
1234:quantum/quantum.c **** ISR(TIMERx_OVF_vect) {
1235:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1236:quantum/quantum.c ****   breathing_task();
1237:quantum/quantum.c **** #endif
1238:quantum/quantum.c ****   // for very small values of OCRxx (or backlight level)
1239:quantum/quantum.c ****   // we can't guarantee this whole code won't execute
1240:quantum/quantum.c ****   // at the same time as the compare match interrupt
1241:quantum/quantum.c ****   // which means that we might turn on the leds while
1242:quantum/quantum.c ****   // trying to turn them off, leading to flickering
1243:quantum/quantum.c ****   // artifacts (especially while breathing, because breathing_task
1244:quantum/quantum.c ****   // takes many computation cycles).
1245:quantum/quantum.c ****   // so better not turn them on while the counter TOP is very low.
1246:quantum/quantum.c ****   if (OCRxx > 256) {
1247:quantum/quantum.c ****     FOR_EACH_LED(
1248:quantum/quantum.c ****       backlight_on(backlight_pin);
1249:quantum/quantum.c ****     )
1250:quantum/quantum.c ****   }
1251:quantum/quantum.c **** }
1252:quantum/quantum.c **** 
1253:quantum/quantum.c **** #endif
1254:quantum/quantum.c **** 
1255:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
1256:quantum/quantum.c **** 
1257:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
1258:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
1259:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
1260:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
1261:quantum/quantum.c ****   else {
1262:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
1263:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
1264:quantum/quantum.c ****     // and revert what we've done again after squaring.
1265:quantum/quantum.c ****     y = y * y * y >> 8;
1266:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
1267:quantum/quantum.c ****       return 0xFFFFU;
1268:quantum/quantum.c ****     else
1269:quantum/quantum.c ****       return (uint16_t) y;
1270:quantum/quantum.c ****   }
1271:quantum/quantum.c **** }
1272:quantum/quantum.c **** 
1273:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
1274:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
1275:quantum/quantum.c **** 	OCRxx = val;
1276:quantum/quantum.c **** }
1277:quantum/quantum.c **** 
1278:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void backlight_set(uint8_t level) {
1281:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
1282:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
1283:quantum/quantum.c **** 
1284:quantum/quantum.c ****   if (level == 0) {
1285:quantum/quantum.c ****     #ifdef BACKLIGHT_PWM_TIMER
1286:quantum/quantum.c ****       if (OCRxx) {
1287:quantum/quantum.c ****         TIMSKx &= ~(_BV(OCIExA));
1288:quantum/quantum.c ****         TIMSKx &= ~(_BV(TOIEx));
1289:quantum/quantum.c ****         FOR_EACH_LED(
1290:quantum/quantum.c ****           backlight_off(backlight_pin);
1291:quantum/quantum.c ****         )
1292:quantum/quantum.c ****       }
1293:quantum/quantum.c ****     #else
1294:quantum/quantum.c ****     // Turn off PWM control on backlight pin
1295:quantum/quantum.c ****     TCCRxA &= ~(_BV(COMxx1));
1296:quantum/quantum.c ****     #endif
1297:quantum/quantum.c ****   } else {
1298:quantum/quantum.c ****     #ifdef BACKLIGHT_PWM_TIMER
1299:quantum/quantum.c ****       if (!OCRxx) {
1300:quantum/quantum.c ****         TIMSKx |= _BV(OCIExA);
1301:quantum/quantum.c ****         TIMSKx |= _BV(TOIEx);
1302:quantum/quantum.c ****       }
1303:quantum/quantum.c ****     #else
1304:quantum/quantum.c ****     // Turn on PWM control of backlight pin
1305:quantum/quantum.c ****     TCCRxA |= _BV(COMxx1);
1306:quantum/quantum.c ****     #endif
1307:quantum/quantum.c ****   }
1308:quantum/quantum.c ****   // Set the brightness
1309:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1310:quantum/quantum.c **** }
1311:quantum/quantum.c **** 
1312:quantum/quantum.c **** void backlight_task(void) {}
1313:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1314:quantum/quantum.c **** 
1315:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1316:quantum/quantum.c **** 
1317:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1318:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1319:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1320:quantum/quantum.c **** #define BREATHING_STEPS 128
1321:quantum/quantum.c **** 
1322:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1323:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1324:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1325:quantum/quantum.c **** 
1326:quantum/quantum.c **** #ifdef BACKLIGHT_PWM_TIMER
1327:quantum/quantum.c **** static bool breathing = false;
1328:quantum/quantum.c **** 
1329:quantum/quantum.c **** bool is_breathing(void) {
1330:quantum/quantum.c ****   return breathing;
1331:quantum/quantum.c **** }
1332:quantum/quantum.c **** 
1333:quantum/quantum.c **** #define breathing_interrupt_enable() do { breathing = true; } while (0)
1334:quantum/quantum.c **** #define breathing_interrupt_disable() do { breathing = false; } while (0)
1335:quantum/quantum.c **** #else
1336:quantum/quantum.c **** 
1337:quantum/quantum.c **** bool is_breathing(void) {
1338:quantum/quantum.c ****     return !!(TIMSKx & _BV(TOIEx));
1339:quantum/quantum.c **** }
1340:quantum/quantum.c **** 
1341:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSKx |= _BV(TOIEx);} while (0)
1342:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSKx &= ~_BV(TOIEx);} while (0)
1343:quantum/quantum.c **** #endif
1344:quantum/quantum.c **** 
1345:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1346:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1347:quantum/quantum.c **** 
1348:quantum/quantum.c **** void breathing_enable(void)
1349:quantum/quantum.c **** {
1350:quantum/quantum.c ****   breathing_counter = 0;
1351:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1352:quantum/quantum.c ****   breathing_interrupt_enable();
1353:quantum/quantum.c **** }
1354:quantum/quantum.c **** 
1355:quantum/quantum.c **** void breathing_pulse(void)
1356:quantum/quantum.c **** {
1357:quantum/quantum.c ****     if (get_backlight_level() == 0)
1358:quantum/quantum.c ****       breathing_min();
1359:quantum/quantum.c ****     else
1360:quantum/quantum.c ****       breathing_max();
1361:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1362:quantum/quantum.c ****     breathing_interrupt_enable();
1363:quantum/quantum.c **** }
1364:quantum/quantum.c **** 
1365:quantum/quantum.c **** void breathing_disable(void)
1366:quantum/quantum.c **** {
1367:quantum/quantum.c ****     breathing_interrupt_disable();
1368:quantum/quantum.c ****     // Restore backlight level
1369:quantum/quantum.c ****     backlight_set(get_backlight_level());
1370:quantum/quantum.c **** }
1371:quantum/quantum.c **** 
1372:quantum/quantum.c **** void breathing_self_disable(void)
1373:quantum/quantum.c **** {
1374:quantum/quantum.c ****   if (get_backlight_level() == 0)
1375:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1376:quantum/quantum.c ****   else
1377:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1378:quantum/quantum.c **** }
1379:quantum/quantum.c **** 
1380:quantum/quantum.c **** void breathing_toggle(void) {
1381:quantum/quantum.c ****   if (is_breathing())
1382:quantum/quantum.c ****     breathing_disable();
1383:quantum/quantum.c ****   else
1384:quantum/quantum.c ****     breathing_enable();
1385:quantum/quantum.c **** }
1386:quantum/quantum.c **** 
1387:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1388:quantum/quantum.c **** {
1389:quantum/quantum.c ****   if (!value)
1390:quantum/quantum.c ****     value = 1;
1391:quantum/quantum.c ****   breathing_period = value;
1392:quantum/quantum.c **** }
1393:quantum/quantum.c **** 
1394:quantum/quantum.c **** void breathing_period_default(void) {
1395:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1396:quantum/quantum.c **** }
1397:quantum/quantum.c **** 
1398:quantum/quantum.c **** void breathing_period_inc(void)
1399:quantum/quantum.c **** {
1400:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1401:quantum/quantum.c **** }
1402:quantum/quantum.c **** 
1403:quantum/quantum.c **** void breathing_period_dec(void)
1404:quantum/quantum.c **** {
1405:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1406:quantum/quantum.c **** }
1407:quantum/quantum.c **** 
1408:quantum/quantum.c **** /* To generate breathing curve in python:
1409:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1410:quantum/quantum.c ****  */
1411:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1412:quantum/quantum.c **** 
1413:quantum/quantum.c **** // Use this before the cie_lightness function.
1414:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1415:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1416:quantum/quantum.c **** }
1417:quantum/quantum.c **** 
1418:quantum/quantum.c **** #ifdef BACKLIGHT_PWM_TIMER
1419:quantum/quantum.c **** void breathing_task(void)
1420:quantum/quantum.c **** #else
1421:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1422:quantum/quantum.c ****  * about 244 times per second.
1423:quantum/quantum.c ****  */
1424:quantum/quantum.c **** ISR(TIMERx_OVF_vect)
1425:quantum/quantum.c **** #endif
1426:quantum/quantum.c **** {
1427:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1428:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1429:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1430:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1431:quantum/quantum.c **** 
1432:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1433:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1434:quantum/quantum.c ****   {
1435:quantum/quantum.c ****       breathing_interrupt_disable();
1436:quantum/quantum.c ****   }
1437:quantum/quantum.c **** 
1438:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1439:quantum/quantum.c **** }
1440:quantum/quantum.c **** 
1441:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1442:quantum/quantum.c **** 
1443:quantum/quantum.c **** __attribute__ ((weak))
1444:quantum/quantum.c **** void backlight_init_ports(void)
1445:quantum/quantum.c **** {
1446:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1447:quantum/quantum.c ****   FOR_EACH_LED(
1448:quantum/quantum.c ****     setPinOutput(backlight_pin);
1449:quantum/quantum.c ****     backlight_on(backlight_pin);
1450:quantum/quantum.c ****   )
1451:quantum/quantum.c **** 
1452:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1453:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1454:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1455:quantum/quantum.c **** 
1456:quantum/quantum.c **** #ifdef BACKLIGHT_PWM_TIMER
1457:quantum/quantum.c ****   // TimerX setup, Fast PWM mode count to TOP set in ICRx
1458:quantum/quantum.c ****   TCCRxA = _BV(WGM11); // = 0b00000010;
1459:quantum/quantum.c ****   // clock select clk/1
1460:quantum/quantum.c ****   TCCRxB = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1461:quantum/quantum.c **** #else // hardware PWM
1462:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1463:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1464:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1465:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1466:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1467:quantum/quantum.c **** 
1468:quantum/quantum.c ****   /*
1469:quantum/quantum.c ****   14.8.3:
1470:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1471:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1472:quantum/quantum.c ****   */
1473:quantum/quantum.c ****   TCCRxA = _BV(COMxx1) | _BV(WGM11);            // = 0b00001010;
1474:quantum/quantum.c ****   TCCRxB = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1475:quantum/quantum.c **** #endif
1476:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1477:quantum/quantum.c ****   ICRx = TIMER_TOP;
1478:quantum/quantum.c **** 
1479:quantum/quantum.c ****   backlight_init();
1480:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1481:quantum/quantum.c ****     breathing_enable();
1482:quantum/quantum.c ****   #endif
1483:quantum/quantum.c **** }
1484:quantum/quantum.c **** 
1485:quantum/quantum.c **** #endif // hardware backlight
1486:quantum/quantum.c **** 
1487:quantum/quantum.c **** #else // no backlight
1488:quantum/quantum.c **** 
1489:quantum/quantum.c **** __attribute__ ((weak))
1490:quantum/quantum.c **** void backlight_init_ports(void) {}
1491:quantum/quantum.c **** 
1492:quantum/quantum.c **** __attribute__ ((weak))
1493:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1494:quantum/quantum.c **** 
1495:quantum/quantum.c **** #endif // backlight
1496:quantum/quantum.c **** 
1497:quantum/quantum.c **** #ifdef HD44780_ENABLED
1498:quantum/quantum.c **** #include "hd44780.h"
1499:quantum/quantum.c **** #endif
1500:quantum/quantum.c **** 
1501:quantum/quantum.c **** 
1502:quantum/quantum.c **** // Functions for spitting out values
1503:quantum/quantum.c **** //
1504:quantum/quantum.c **** 
1505:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1506:quantum/quantum.c ****     uint16_t word = (number >> 16);
1507:quantum/quantum.c ****     send_word(word);
1508:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1509:quantum/quantum.c **** }
1510:quantum/quantum.c **** 
1511:quantum/quantum.c **** void send_word(uint16_t number) {
1512:quantum/quantum.c ****     uint8_t byte = number >> 8;
1513:quantum/quantum.c ****     send_byte(byte);
1514:quantum/quantum.c ****     send_byte(number & 0xFF);
1515:quantum/quantum.c **** }
1516:quantum/quantum.c **** 
1517:quantum/quantum.c **** void send_byte(uint8_t number) {
1518:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1519:quantum/quantum.c ****     send_nibble(nibble);
1520:quantum/quantum.c ****     send_nibble(number & 0xF);
1521:quantum/quantum.c **** }
1522:quantum/quantum.c **** 
1523:quantum/quantum.c **** void send_nibble(uint8_t number) {
 1489               		.loc 1 1523 0
 1490               		.cfi_startproc
 1491               	.LVL180:
 1492 0000 CF93      		push r28
 1493               	.LCFI42:
 1494               		.cfi_def_cfa_offset 3
 1495               		.cfi_offset 28, -2
 1496               	/* prologue: function */
 1497               	/* frame size = 0 */
 1498               	/* stack size = 1 */
 1499               	.L__stack_usage = 1
1524:quantum/quantum.c ****     switch (number) {
 1500               		.loc 1 1524 0
 1501 0002 8A30      		cpi r24,lo8(10)
 1502 0004 00F4      		brsh .L107
 1503 0006 8130      		cpi r24,lo8(1)
 1504 0008 00F4      		brsh .L115
1525:quantum/quantum.c ****         case 0:
1526:quantum/quantum.c ****             register_code(KC_0);
 1505               		.loc 1 1526 0
 1506 000a 87E2      		ldi r24,lo8(39)
 1507               	.LVL181:
 1508 000c 0E94 0000 		call register_code
 1509               	.LVL182:
1527:quantum/quantum.c ****             unregister_code(KC_0);
 1510               		.loc 1 1527 0
 1511 0010 87E2      		ldi r24,lo8(39)
 1512 0012 00C0      		rjmp .L113
 1513               	.LVL183:
 1514               	.L107:
1524:quantum/quantum.c ****     switch (number) {
 1515               		.loc 1 1524 0
 1516 0014 8031      		cpi r24,lo8(16)
 1517 0016 00F4      		brsh .L116
1528:quantum/quantum.c ****             break;
1529:quantum/quantum.c ****         case 1 ... 9:
1530:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1531:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1532:quantum/quantum.c ****             break;
1533:quantum/quantum.c ****         case 0xA ... 0xF:
1534:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 1518               		.loc 1 1534 0
 1519 0018 CAEF      		ldi r28,lo8(-6)
 1520 001a 00C0      		rjmp .L114
 1521               	.L115:
1530:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 1522               		.loc 1 1530 0
 1523 001c CDE1      		ldi r28,lo8(29)
 1524               	.L114:
 1525               		.loc 1 1534 0
 1526 001e C80F      		add r28,r24
 1527 0020 8C2F      		mov r24,r28
 1528               	.LVL184:
 1529 0022 0E94 0000 		call register_code
 1530               	.LVL185:
1535:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1531               		.loc 1 1535 0
 1532 0026 8C2F      		mov r24,r28
 1533               	.L113:
 1534               	/* epilogue start */
1536:quantum/quantum.c ****             break;
1537:quantum/quantum.c ****     }
1538:quantum/quantum.c **** }
 1535               		.loc 1 1538 0
 1536 0028 CF91      		pop r28
1535:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1537               		.loc 1 1535 0
 1538 002a 0C94 0000 		jmp unregister_code
 1539               	.LVL186:
 1540               	.L116:
 1541               	/* epilogue start */
 1542               		.loc 1 1538 0
 1543 002e CF91      		pop r28
 1544 0030 0895      		ret
 1545               		.cfi_endproc
 1546               	.LFE143:
 1548               		.section	.text.send_byte,"ax",@progbits
 1549               	.global	send_byte
 1551               	send_byte:
 1552               	.LFB142:
1517:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 1553               		.loc 1 1517 0
 1554               		.cfi_startproc
 1555               	.LVL187:
 1556 0000 CF93      		push r28
 1557               	.LCFI43:
 1558               		.cfi_def_cfa_offset 3
 1559               		.cfi_offset 28, -2
 1560               	/* prologue: function */
 1561               	/* frame size = 0 */
 1562               	/* stack size = 1 */
 1563               	.L__stack_usage = 1
 1564 0002 C82F      		mov r28,r24
 1565               	.LVL188:
1519:quantum/quantum.c ****     send_nibble(number & 0xF);
 1566               		.loc 1 1519 0
 1567 0004 8295      		swap r24
 1568               	.LVL189:
 1569 0006 8F70      		andi r24,lo8(15)
 1570 0008 0E94 0000 		call send_nibble
 1571               	.LVL190:
1520:quantum/quantum.c **** }
 1572               		.loc 1 1520 0
 1573 000c 8C2F      		mov r24,r28
 1574 000e 8F70      		andi r24,lo8(15)
 1575               	/* epilogue start */
1521:quantum/quantum.c **** 
 1576               		.loc 1 1521 0
 1577 0010 CF91      		pop r28
 1578               	.LVL191:
1520:quantum/quantum.c **** }
 1579               		.loc 1 1520 0
 1580 0012 0C94 0000 		jmp send_nibble
 1581               	.LVL192:
 1582               		.cfi_endproc
 1583               	.LFE142:
 1585               		.section	.text.send_word,"ax",@progbits
 1586               	.global	send_word
 1588               	send_word:
 1589               	.LFB141:
1511:quantum/quantum.c ****     uint8_t byte = number >> 8;
 1590               		.loc 1 1511 0
 1591               		.cfi_startproc
 1592               	.LVL193:
 1593 0000 CF93      		push r28
 1594               	.LCFI44:
 1595               		.cfi_def_cfa_offset 3
 1596               		.cfi_offset 28, -2
 1597               	/* prologue: function */
 1598               	/* frame size = 0 */
 1599               	/* stack size = 1 */
 1600               	.L__stack_usage = 1
 1601 0002 C82F      		mov r28,r24
 1602               	.LVL194:
1513:quantum/quantum.c ****     send_byte(number & 0xFF);
 1603               		.loc 1 1513 0
 1604 0004 892F      		mov r24,r25
 1605               	.LVL195:
 1606 0006 0E94 0000 		call send_byte
 1607               	.LVL196:
1514:quantum/quantum.c **** }
 1608               		.loc 1 1514 0
 1609 000a 8C2F      		mov r24,r28
 1610               	/* epilogue start */
1515:quantum/quantum.c **** 
 1611               		.loc 1 1515 0
 1612 000c CF91      		pop r28
1514:quantum/quantum.c **** }
 1613               		.loc 1 1514 0
 1614 000e 0C94 0000 		jmp send_byte
 1615               	.LVL197:
 1616               		.cfi_endproc
 1617               	.LFE141:
 1619               		.section	.text.send_dword,"ax",@progbits
 1620               	.global	send_dword
 1622               	send_dword:
 1623               	.LFB140:
1505:quantum/quantum.c ****     uint16_t word = (number >> 16);
 1624               		.loc 1 1505 0
 1625               		.cfi_startproc
 1626               	.LVL198:
 1627 0000 CF92      		push r12
 1628               	.LCFI45:
 1629               		.cfi_def_cfa_offset 3
 1630               		.cfi_offset 12, -2
 1631 0002 DF92      		push r13
 1632               	.LCFI46:
 1633               		.cfi_def_cfa_offset 4
 1634               		.cfi_offset 13, -3
 1635 0004 EF92      		push r14
 1636               	.LCFI47:
 1637               		.cfi_def_cfa_offset 5
 1638               		.cfi_offset 14, -4
 1639 0006 FF92      		push r15
 1640               	.LCFI48:
 1641               		.cfi_def_cfa_offset 6
 1642               		.cfi_offset 15, -5
 1643               	/* prologue: function */
 1644               	/* frame size = 0 */
 1645               	/* stack size = 4 */
 1646               	.L__stack_usage = 4
 1647 0008 6B01      		movw r12,r22
 1648 000a 7C01      		movw r14,r24
 1649               	.LVL199:
1507:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 1650               		.loc 1 1507 0
 1651 000c C701      		movw r24,r14
 1652 000e 0E94 0000 		call send_word
 1653               	.LVL200:
1508:quantum/quantum.c **** }
 1654               		.loc 1 1508 0
 1655 0012 C601      		movw r24,r12
 1656               	/* epilogue start */
1509:quantum/quantum.c **** 
 1657               		.loc 1 1509 0
 1658 0014 FF90      		pop r15
 1659 0016 EF90      		pop r14
 1660 0018 DF90      		pop r13
 1661 001a CF90      		pop r12
 1662               	.LVL201:
1508:quantum/quantum.c **** }
 1663               		.loc 1 1508 0
 1664 001c 0C94 0000 		jmp send_word
 1665               	.LVL202:
 1666               		.cfi_endproc
 1667               	.LFE140:
 1669               		.section	.text.hex_to_keycode,"ax",@progbits
 1670               		.weak	hex_to_keycode
 1672               	hex_to_keycode:
 1673               	.LFB144:
1539:quantum/quantum.c **** 
1540:quantum/quantum.c **** 
1541:quantum/quantum.c **** __attribute__((weak))
1542:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1543:quantum/quantum.c **** {
 1674               		.loc 1 1543 0
 1675               		.cfi_startproc
 1676               	.LVL203:
 1677               	/* prologue: function */
 1678               	/* frame size = 0 */
 1679               	/* stack size = 0 */
 1680               	.L__stack_usage = 0
1544:quantum/quantum.c ****   hex = hex & 0xF;
 1681               		.loc 1 1544 0
 1682 0000 282F      		mov r18,r24
 1683 0002 2F70      		andi r18,lo8(15)
 1684               	.LVL204:
1545:quantum/quantum.c ****   if (hex == 0x0) {
 1685               		.loc 1 1545 0
 1686 0004 01F0      		breq .L123
 1687 0006 822F      		mov r24,r18
 1688 0008 90E0      		ldi r25,0
1546:quantum/quantum.c ****     return KC_0;
1547:quantum/quantum.c ****   } else if (hex < 0xA) {
 1689               		.loc 1 1547 0
 1690 000a 2A30      		cpi r18,lo8(10)
 1691 000c 00F4      		brsh .L122
1548:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 1692               		.loc 1 1548 0
 1693 000e 4D96      		adiw r24,29
 1694 0010 0895      		ret
 1695               	.L122:
1549:quantum/quantum.c ****   } else {
1550:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 1696               		.loc 1 1550 0
 1697 0012 0697      		sbiw r24,6
 1698 0014 0895      		ret
 1699               	.L123:
1546:quantum/quantum.c ****   } else if (hex < 0xA) {
 1700               		.loc 1 1546 0
 1701 0016 87E2      		ldi r24,lo8(39)
 1702 0018 90E0      		ldi r25,0
1551:quantum/quantum.c ****   }
1552:quantum/quantum.c **** }
 1703               		.loc 1 1552 0
 1704 001a 0895      		ret
 1705               		.cfi_endproc
 1706               	.LFE144:
 1708               		.section	.text.api_send_unicode,"ax",@progbits
 1709               	.global	api_send_unicode
 1711               	api_send_unicode:
 1712               	.LFB145:
1553:quantum/quantum.c **** 
1554:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1713               		.loc 1 1554 0
 1714               		.cfi_startproc
 1715               	.LVL205:
 1716               	/* prologue: function */
 1717               	/* frame size = 0 */
 1718               	/* stack size = 0 */
 1719               	.L__stack_usage = 0
 1720 0000 0895      		ret
 1721               		.cfi_endproc
 1722               	.LFE145:
 1724               		.section	.text.led_set_user,"ax",@progbits
 1725               		.weak	led_set_user
 1727               	led_set_user:
 1728               	.LFB146:
1555:quantum/quantum.c **** #ifdef API_ENABLE
1556:quantum/quantum.c ****     uint8_t chunk[4];
1557:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1558:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1559:quantum/quantum.c **** #endif
1560:quantum/quantum.c **** }
1561:quantum/quantum.c **** 
1562:quantum/quantum.c **** __attribute__ ((weak))
1563:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 1729               		.loc 1 1563 0
 1730               		.cfi_startproc
 1731               	.LVL206:
 1732               	/* prologue: function */
 1733               	/* frame size = 0 */
 1734               	/* stack size = 0 */
 1735               	.L__stack_usage = 0
 1736 0000 0895      		ret
 1737               		.cfi_endproc
 1738               	.LFE146:
 1740               		.set	led_set_user.localalias.1,led_set_user
 1741               		.section	.text.backlight_set,"ax",@progbits
 1742               		.weak	backlight_set
 1744               	backlight_set:
 1745               	.LFB159:
 1746               		.cfi_startproc
 1747               	/* prologue: function */
 1748               	/* frame size = 0 */
 1749               	/* stack size = 0 */
 1750               	.L__stack_usage = 0
 1751 0000 0C94 0000 		jmp led_set_user.localalias.1
 1752               		.cfi_endproc
 1753               	.LFE159:
 1755               		.section	.text.led_set_kb,"ax",@progbits
 1756               		.weak	led_set_kb
 1758               	led_set_kb:
 1759               	.LFB147:
1564:quantum/quantum.c **** 
1565:quantum/quantum.c **** }
1566:quantum/quantum.c **** 
1567:quantum/quantum.c **** __attribute__ ((weak))
1568:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 1760               		.loc 1 1568 0
 1761               		.cfi_startproc
 1762               	.LVL207:
 1763               	/* prologue: function */
 1764               	/* frame size = 0 */
 1765               	/* stack size = 0 */
 1766               	.L__stack_usage = 0
1569:quantum/quantum.c ****     led_set_user(usb_led);
 1767               		.loc 1 1569 0
 1768 0000 0C94 0000 		jmp led_set_user
 1769               	.LVL208:
 1770               		.cfi_endproc
 1771               	.LFE147:
 1773               		.section	.text.led_set,"ax",@progbits
 1774               		.weak	led_set
 1776               	led_set:
 1777               	.LFB149:
1570:quantum/quantum.c **** }
1571:quantum/quantum.c **** 
1572:quantum/quantum.c **** __attribute__ ((weak))
1573:quantum/quantum.c **** void led_init_ports(void)
1574:quantum/quantum.c **** {
1575:quantum/quantum.c **** 
1576:quantum/quantum.c **** }
1577:quantum/quantum.c **** 
1578:quantum/quantum.c **** __attribute__ ((weak))
1579:quantum/quantum.c **** void led_set(uint8_t usb_led)
1580:quantum/quantum.c **** {
 1778               		.loc 1 1580 0
 1779               		.cfi_startproc
 1780               	.LVL209:
 1781               	/* prologue: function */
 1782               	/* frame size = 0 */
 1783               	/* stack size = 0 */
 1784               	.L__stack_usage = 0
1581:quantum/quantum.c **** 
1582:quantum/quantum.c ****   // Example LED Code
1583:quantum/quantum.c ****   //
1584:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1585:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1586:quantum/quantum.c ****     // {
1587:quantum/quantum.c ****     //     // Output high.
1588:quantum/quantum.c ****     //     DDRE |= (1<<6);
1589:quantum/quantum.c ****     //     PORTE |= (1<<6);
1590:quantum/quantum.c ****     // }
1591:quantum/quantum.c ****     // else
1592:quantum/quantum.c ****     // {
1593:quantum/quantum.c ****     //     // Output low.
1594:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1595:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1596:quantum/quantum.c ****     // }
1597:quantum/quantum.c **** 
1598:quantum/quantum.c **** #if defined(BACKLIGHT_CAPS_LOCK) && defined(BACKLIGHT_ENABLE)
1599:quantum/quantum.c ****   // Use backlight as Caps Lock indicator
1600:quantum/quantum.c ****   uint8_t bl_toggle_lvl = 0;
1601:quantum/quantum.c **** 
1602:quantum/quantum.c ****   if (IS_LED_ON(usb_led, USB_LED_CAPS_LOCK) && !backlight_config.enable) {
1603:quantum/quantum.c ****     // Turning Caps Lock ON and backlight is disabled in config
1604:quantum/quantum.c ****     // Toggling backlight to the brightest level
1605:quantum/quantum.c ****     bl_toggle_lvl = BACKLIGHT_LEVELS;
1606:quantum/quantum.c ****   } else if (IS_LED_OFF(usb_led, USB_LED_CAPS_LOCK) && backlight_config.enable) {
1607:quantum/quantum.c ****     // Turning Caps Lock OFF and backlight is enabled in config
1608:quantum/quantum.c ****     // Toggling backlight and restoring config level
1609:quantum/quantum.c ****     bl_toggle_lvl = backlight_config.level;
1610:quantum/quantum.c ****   }
1611:quantum/quantum.c **** 
1612:quantum/quantum.c ****   // Set level without modify backlight_config to keep ability to restore state
1613:quantum/quantum.c ****   backlight_set(bl_toggle_lvl);
1614:quantum/quantum.c **** #endif
1615:quantum/quantum.c **** 
1616:quantum/quantum.c ****   led_set_kb(usb_led);
 1785               		.loc 1 1616 0
 1786 0000 0C94 0000 		jmp led_set_kb
 1787               	.LVL210:
 1788               		.cfi_endproc
 1789               	.LFE149:
 1791               		.section	.text.shutdown_user,"ax",@progbits
 1792               		.weak	shutdown_user
 1794               	shutdown_user:
 1795               	.LFB151:
1617:quantum/quantum.c **** }
1618:quantum/quantum.c **** 
1619:quantum/quantum.c **** 
1620:quantum/quantum.c **** //------------------------------------------------------------------------------
1621:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1622:quantum/quantum.c **** // different events such as startup and bootloader jump
1623:quantum/quantum.c **** 
1624:quantum/quantum.c **** __attribute__ ((weak))
1625:quantum/quantum.c **** void startup_user() {}
1626:quantum/quantum.c **** 
1627:quantum/quantum.c **** __attribute__ ((weak))
1628:quantum/quantum.c **** void shutdown_user() {}
 1796               		.loc 1 1628 0
 1797               		.cfi_startproc
 1798               	/* prologue: function */
 1799               	/* frame size = 0 */
 1800               	/* stack size = 0 */
 1801               	.L__stack_usage = 0
 1802 0000 0895      		ret
 1803               		.cfi_endproc
 1804               	.LFE151:
 1806               		.set	shutdown_user.localalias.0,shutdown_user
 1807               		.section	.text.startup_user,"ax",@progbits
 1808               		.weak	startup_user
 1810               	startup_user:
 1811               	.LFB153:
 1812               		.cfi_startproc
 1813               	/* prologue: function */
 1814               	/* frame size = 0 */
 1815               	/* stack size = 0 */
 1816               	.L__stack_usage = 0
 1817 0000 0C94 0000 		jmp shutdown_user.localalias.0
 1818               		.cfi_endproc
 1819               	.LFE153:
 1821               		.section	.text.led_init_ports,"ax",@progbits
 1822               		.weak	led_init_ports
 1824               	led_init_ports:
 1825               	.LFB155:
 1826               		.cfi_startproc
 1827               	/* prologue: function */
 1828               	/* frame size = 0 */
 1829               	/* stack size = 0 */
 1830               	.L__stack_usage = 0
 1831 0000 0C94 0000 		jmp shutdown_user.localalias.0
 1832               		.cfi_endproc
 1833               	.LFE155:
 1835               		.section	.text.backlight_init_ports,"ax",@progbits
 1836               		.weak	backlight_init_ports
 1838               	backlight_init_ports:
 1839               	.LFB157:
 1840               		.cfi_startproc
 1841               	/* prologue: function */
 1842               	/* frame size = 0 */
 1843               	/* stack size = 0 */
 1844               	.L__stack_usage = 0
 1845 0000 0C94 0000 		jmp shutdown_user.localalias.0
 1846               		.cfi_endproc
 1847               	.LFE157:
 1849               		.section	.text.reset_keyboard,"ax",@progbits
 1850               	.global	reset_keyboard
 1852               	reset_keyboard:
 1853               	.LFB122:
 166:quantum/quantum.c ****   clear_keyboard();
 1854               		.loc 1 166 0
 1855               		.cfi_startproc
 1856               	/* prologue: function */
 1857               	/* frame size = 0 */
 1858               	/* stack size = 0 */
 1859               	.L__stack_usage = 0
 167:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 1860               		.loc 1 167 0
 1861 0000 0E94 0000 		call clear_keyboard
 1862               	.LVL211:
 182:quantum/quantum.c ****   wait_ms(250);
 1863               		.loc 1 182 0
 1864 0004 0E94 0000 		call shutdown_user
 1865               	.LVL212:
 1866               	.LBB55:
 1867               	.LBB56:
 1868               		.loc 2 187 0
 1869 0008 2FEF      		ldi r18,lo8(799999)
 1870 000a 84E3      		ldi r24,hi8(799999)
 1871 000c 9CE0      		ldi r25,hlo8(799999)
 1872 000e 2150      	1:	subi r18,1
 1873 0010 8040      		sbci r24,0
 1874 0012 9040      		sbci r25,0
 1875 0014 01F4      		brne 1b
 1876 0016 00C0      		rjmp .
 1877 0018 0000      		nop
 1878               	.LVL213:
 1879               	.LBE56:
 1880               	.LBE55:
 192:quantum/quantum.c **** }
 1881               		.loc 1 192 0
 1882 001a 0C94 0000 		jmp bootloader_jump
 1883               	.LVL214:
 1884               		.cfi_endproc
 1885               	.LFE122:
 1887               		.section	.text.process_record_quantum,"ax",@progbits
 1888               	.global	process_record_quantum
 1890               	process_record_quantum:
 1891               	.LFB125:
 231:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record);
 1892               		.loc 1 231 0
 1893               		.cfi_startproc
 1894               	.LVL215:
 1895 0000 0F93      		push r16
 1896               	.LCFI49:
 1897               		.cfi_def_cfa_offset 3
 1898               		.cfi_offset 16, -2
 1899 0002 1F93      		push r17
 1900               	.LCFI50:
 1901               		.cfi_def_cfa_offset 4
 1902               		.cfi_offset 17, -3
 1903 0004 CF93      		push r28
 1904               	.LCFI51:
 1905               		.cfi_def_cfa_offset 5
 1906               		.cfi_offset 28, -4
 1907 0006 DF93      		push r29
 1908               	.LCFI52:
 1909               		.cfi_def_cfa_offset 6
 1910               		.cfi_offset 29, -5
 1911               	/* prologue: function */
 1912               	/* frame size = 0 */
 1913               	/* stack size = 4 */
 1914               	.L__stack_usage = 4
 1915 0008 8C01      		movw r16,r24
 232:quantum/quantum.c **** 
 1916               		.loc 1 232 0
 1917 000a 0E94 0000 		call get_record_keycode
 1918               	.LVL216:
 1919 000e EC01      		movw r28,r24
 1920               	.LVL217:
 264:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 1921               		.loc 1 264 0
 1922 0010 B801      		movw r22,r16
 1923 0012 0E94 0000 		call process_record_kb
 1924               	.LVL218:
 1925 0016 8823      		tst r24
 1926 0018 01F4      		brne .+2
 1927 001a 00C0      		rjmp .L267
 299:quantum/quantum.c ****   #endif
 1928               		.loc 1 299 0 discriminator 2
 1929 001c B801      		movw r22,r16
 1930 001e CE01      		movw r24,r28
 1931 0020 0E94 0000 		call process_space_cadet
 1932               	.LVL219:
 264:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 1933               		.loc 1 264 0 discriminator 2
 1934 0024 8823      		tst r24
 1935 0026 01F4      		brne .+2
 1936 0028 00C0      		rjmp .L267
 307:quantum/quantum.c ****     case RESET:
 1937               		.loc 1 307 0
 1938 002a CA3C      		cpi r28,-54
 1939 002c FCE5      		ldi r31,92
 1940 002e DF07      		cpc r29,r31
 1941 0030 01F4      		brne .L304
 431:quantum/quantum.c ****     #else
 1942               		.loc 1 431 0
 1943 0032 F801      		movw r30,r16
 1944 0034 8281      		ldd r24,Z+2
 1945 0036 8823      		tst r24
 1946 0038 01F4      		brne .+2
 1947 003a 00C0      		rjmp .L267
 435:quantum/quantum.c ****     }
 1948               		.loc 1 435 0
 1949 003c 0E94 0000 		call rgblight_decrease_val
 1950               	.LVL220:
 1951 0040 00C0      		rjmp .L267
 1952               	.L304:
 307:quantum/quantum.c ****     case RESET:
 1953               		.loc 1 307 0
 1954 0042 CB3C      		cpi r28,-53
 1955 0044 8CE5      		ldi r24,92
 1956 0046 D807      		cpc r29,r24
 1957 0048 00F0      		brlo .+2
 1958 004a 00C0      		rjmp .L202
 1959 004c C33C      		cpi r28,-61
 1960 004e 9CE5      		ldi r25,92
 1961 0050 D907      		cpc r29,r25
 1962 0052 01F4      		brne .L305
 357:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 1963               		.loc 1 357 0
 1964 0054 F801      		movw r30,r16
 1965 0056 8281      		ldd r24,Z+2
 1966 0058 8823      		tst r24
 1967 005a 01F4      		brne .+2
 1968 005c 00C0      		rjmp .L267
 1969               	.LBB57:
 358:quantum/quantum.c ****       if(shifted) {
 1970               		.loc 1 358 0
 1971 005e 0E94 0000 		call get_mods
 1972               	.LVL221:
 359:quantum/quantum.c ****         rgblight_step_reverse();
 1973               		.loc 1 359 0
 1974 0062 8272      		andi r24,lo8(34)
 1975               	.LVL222:
 1976 0064 01F0      		breq .L144
 1977               	.LVL223:
 1978               	.L146:
 360:quantum/quantum.c ****       }
 1979               		.loc 1 360 0
 1980 0066 0E94 0000 		call rgblight_step_reverse
 1981               	.LVL224:
 1982 006a 00C0      		rjmp .L267
 1983               	.L305:
 1984               	.LBE57:
 307:quantum/quantum.c ****     case RESET:
 1985               		.loc 1 307 0
 1986 006c C43C      		cpi r28,-60
 1987 006e ECE5      		ldi r30,92
 1988 0070 DE07      		cpc r29,r30
 1989 0072 00F0      		brlo .L306
 1990 0074 C63C      		cpi r28,-58
 1991 0076 9CE5      		ldi r25,92
 1992 0078 D907      		cpc r29,r25
 1993 007a 01F4      		brne .+2
 1994 007c 00C0      		rjmp .L148
 1995 007e 00F0      		brlo .+2
 1996 0080 00C0      		rjmp .L205
 1997 0082 C43C      		cpi r28,-60
 1998 0084 FCE5      		ldi r31,92
 1999 0086 DF07      		cpc r29,r31
 2000 0088 01F0      		breq .+2
 2001 008a 00C0      		rjmp .L307
 368:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 2002               		.loc 1 368 0
 2003 008c F801      		movw r30,r16
 2004 008e 8281      		ldd r24,Z+2
 2005 0090 8823      		tst r24
 2006 0092 01F4      		brne .+2
 2007 0094 00C0      		rjmp .L267
 2008               	.LBB58:
 369:quantum/quantum.c ****       if(shifted) {
 2009               		.loc 1 369 0
 2010 0096 0E94 0000 		call get_mods
 2011               	.LVL225:
 370:quantum/quantum.c ****         rgblight_step();
 2012               		.loc 1 370 0
 2013 009a 8272      		andi r24,lo8(34)
 2014               	.LVL226:
 2015 009c 01F0      		breq .L146
 2016               	.LVL227:
 2017               	.L144:
 2018               	.LBE58:
 2019               	.LBB59:
 363:quantum/quantum.c ****       }
 2020               		.loc 1 363 0
 2021 009e 0E94 0000 		call rgblight_step
 2022               	.LVL228:
 2023 00a2 00C0      		rjmp .L267
 2024               	.L306:
 2025               	.LBE59:
 307:quantum/quantum.c ****     case RESET:
 2026               		.loc 1 307 0
 2027 00a4 C531      		cpi r28,21
 2028 00a6 FCE5      		ldi r31,92
 2029 00a8 DF07      		cpc r29,r31
 2030 00aa 00F0      		brlo .+2
 2031 00ac 00C0      		rjmp .L204
 2032 00ae C230      		cpi r28,2
 2033 00b0 8CE5      		ldi r24,92
 2034 00b2 D807      		cpc r29,r24
 2035 00b4 00F4      		brsh .+2
 2036 00b6 00C0      		rjmp .L308
 567:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 2037               		.loc 1 567 0
 2038 00b8 F801      		movw r30,r16
 2039 00ba 8281      		ldd r24,Z+2
 2040 00bc 8823      		tst r24
 2041 00be 01F4      		brne .+2
 2042 00c0 00C0      		rjmp .L173
 569:quantum/quantum.c ****             eeconfig_init();
 2043               		.loc 1 569 0
 2044 00c2 0E94 0000 		call eeconfig_is_enabled
 2045               	.LVL229:
 2046 00c6 8111      		cpse r24,__zero_reg__
 2047 00c8 00C0      		rjmp .L174
 570:quantum/quantum.c ****         }
 2048               		.loc 1 570 0
 2049 00ca 0E94 0000 		call eeconfig_init
 2050               	.LVL230:
 2051               	.L174:
 573:quantum/quantum.c ****         switch (keycode)
 2052               		.loc 1 573 0
 2053 00ce 0E94 0000 		call eeconfig_read_keymap
 2054               	.LVL231:
 2055 00d2 90E0      		ldi r25,0
 2056 00d4 9093 0000 		sts keymap_config+1,r25
 2057 00d8 8093 0000 		sts keymap_config,r24
 574:quantum/quantum.c ****         {
 2058               		.loc 1 574 0
 2059 00dc FE01      		movw r30,r28
 2060 00de E350      		subi r30,3
 2061 00e0 FC45      		sbci r31,92
 2062 00e2 E231      		cpi r30,18
 2063 00e4 F105      		cpc r31,__zero_reg__
 2064 00e6 00F4      		brsh .L175
 2065 00e8 E050      		subi r30,lo8(-(gs(.L177)))
 2066 00ea F040      		sbci r31,hi8(-(gs(.L177)))
 650:quantum/quantum.c ****             break;
 2067               		.loc 1 650 0
 2068 00ec 8091 0000 		lds r24,keymap_config
 574:quantum/quantum.c ****         {
 2069               		.loc 1 574 0
 2070 00f0 0C94 0000 		jmp __tablejump2__
 2071               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 2072               		.p2align	1
 2073               	.L177:
 2074 0000 0000      		.word gs(.L176)
 2075 0002 0000      		.word gs(.L178)
 2076 0004 0000      		.word gs(.L303)
 2077 0006 0000      		.word gs(.L180)
 2078 0008 0000      		.word gs(.L181)
 2079 000a 0000      		.word gs(.L182)
 2080 000c 0000      		.word gs(.L183)
 2081 000e 0000      		.word gs(.L184)
 2082 0010 0000      		.word gs(.L185)
 2083 0012 0000      		.word gs(.L186)
 2084 0014 0000      		.word gs(.L187)
 2085 0016 0000      		.word gs(.L302)
 2086 0018 0000      		.word gs(.L189)
 2087 001a 0000      		.word gs(.L190)
 2088 001c 0000      		.word gs(.L191)
 2089 001e 0000      		.word gs(.L192)
 2090 0020 0000      		.word gs(.L193)
 2091 0022 0000      		.word gs(.L194)
 2092               		.section	.text.process_record_quantum
 2093               	.L175:
 577:quantum/quantum.c ****             break;
 2094               		.loc 1 577 0
 2095 00f4 8091 0000 		lds r24,keymap_config
 2096 00f8 8160      		ori r24,lo8(1<<0)
 2097 00fa 00C0      		rjmp .L299
 2098               	.L176:
 580:quantum/quantum.c ****             break;
 2099               		.loc 1 580 0
 2100 00fc 8260      		ori r24,lo8(1<<1)
 2101 00fe 00C0      		rjmp .L299
 2102               	.L178:
 583:quantum/quantum.c ****             break;
 2103               		.loc 1 583 0
 2104 0100 8460      		ori r24,lo8(1<<2)
 2105 0102 00C0      		rjmp .L299
 2106               	.L180:
 589:quantum/quantum.c ****             break;
 2107               		.loc 1 589 0
 2108 0104 8061      		ori r24,lo8(1<<4)
 2109 0106 00C0      		rjmp .L299
 2110               	.L181:
 592:quantum/quantum.c ****             break;
 2111               		.loc 1 592 0
 2112 0108 8062      		ori r24,lo8(1<<5)
 2113 010a 00C0      		rjmp .L299
 2114               	.L182:
 595:quantum/quantum.c ****             break;
 2115               		.loc 1 595 0
 2116 010c 8064      		ori r24,lo8(1<<6)
 2117 010e 00C0      		rjmp .L299
 2118               	.L183:
 598:quantum/quantum.c ****             break;
 2119               		.loc 1 598 0
 2120 0110 8068      		ori r24,lo8(1<<7)
 2121 0112 00C0      		rjmp .L299
 2122               	.L184:
 602:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2123               		.loc 1 602 0
 2124 0114 8460      		ori r24,lo8(4)
 2125               	.L303:
 2126 0116 8860      		ori r24,lo8(1<<3)
 2127 0118 00C0      		rjmp .L299
 2128               	.L185:
 608:quantum/quantum.c ****             break;
 2129               		.loc 1 608 0
 2130 011a 8E7F      		andi r24,lo8(~(1<<0))
 2131 011c 00C0      		rjmp .L299
 2132               	.L186:
 611:quantum/quantum.c ****             break;
 2133               		.loc 1 611 0
 2134 011e 8D7F      		andi r24,lo8(~(1<<1))
 2135 0120 00C0      		rjmp .L299
 2136               	.L187:
 614:quantum/quantum.c ****             break;
 2137               		.loc 1 614 0
 2138 0122 8B7F      		andi r24,lo8(~(1<<2))
 2139 0124 00C0      		rjmp .L299
 2140               	.L189:
 620:quantum/quantum.c ****             break;
 2141               		.loc 1 620 0
 2142 0126 8F7E      		andi r24,lo8(~(1<<4))
 2143 0128 00C0      		rjmp .L299
 2144               	.L190:
 623:quantum/quantum.c ****             break;
 2145               		.loc 1 623 0
 2146 012a 8F7D      		andi r24,lo8(~(1<<5))
 2147 012c 00C0      		rjmp .L299
 2148               	.L191:
 626:quantum/quantum.c ****             break;
 2149               		.loc 1 626 0
 2150 012e 8F7B      		andi r24,lo8(~(1<<6))
 2151 0130 00C0      		rjmp .L299
 2152               	.L192:
 629:quantum/quantum.c ****             break;
 2153               		.loc 1 629 0
 2154 0132 8F77      		andi r24,lo8(~(1<<7))
 2155 0134 00C0      		rjmp .L299
 2156               	.L193:
 633:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2157               		.loc 1 633 0
 2158 0136 8B7F      		andi r24,lo8(-5)
 2159               	.L302:
 2160 0138 877F      		andi r24,lo8(~(1<<3))
 2161 013a 00C0      		rjmp .L299
 2162               	.L194:
 650:quantum/quantum.c ****             break;
 2163               		.loc 1 650 0
 2164 013c 87FB      		bst r24,7
 2165 013e 2227      		clr r18
 2166 0140 20F9      		bld r18,0
 2167 0142 91E0      		ldi r25,lo8(1)
 2168 0144 9227      		eor r25,r18
 2169 0146 90FB      		bst r25,0
 2170 0148 87F9      		bld r24,7
 2171               	.L299:
 2172 014a 8093 0000 		sts keymap_config,r24
 655:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 2173               		.loc 1 655 0
 2174 014e 8091 0000 		lds r24,keymap_config
 2175 0152 0E94 0000 		call eeconfig_update_keymap
 2176               	.LVL232:
 656:quantum/quantum.c **** 
 2177               		.loc 1 656 0
 2178 0156 0E94 0000 		call clear_keyboard
 2179               	.LVL233:
 658:quantum/quantum.c ****       }
 2180               		.loc 1 658 0
 2181 015a 00C0      		rjmp .L267
 2182               	.L308:
 307:quantum/quantum.c ****     case RESET:
 2183               		.loc 1 307 0
 2184 015c C115      		cp r28,__zero_reg__
 2185 015e 9CE5      		ldi r25,92
 2186 0160 D907      		cpc r29,r25
 2187 0162 01F0      		breq .L137
 2188 0164 C130      		cpi r28,1
 2189 0166 DC45      		sbci r29,92
 2190 0168 01F0      		breq .L140
 2191               	.L173:
 717:quantum/quantum.c **** }
 2192               		.loc 1 717 0
 2193 016a C801      		movw r24,r16
 2194               	/* epilogue start */
 718:quantum/quantum.c **** 
 2195               		.loc 1 718 0
 2196 016c DF91      		pop r29
 2197 016e CF91      		pop r28
 2198               	.LVL234:
 2199 0170 1F91      		pop r17
 2200 0172 0F91      		pop r16
 2201               	.LVL235:
 717:quantum/quantum.c **** }
 2202               		.loc 1 717 0
 2203 0174 0C94 0000 		jmp process_action_kb
 2204               	.LVL236:
 2205               	.L137:
 309:quantum/quantum.c ****         reset_keyboard();
 2206               		.loc 1 309 0
 2207 0178 F801      		movw r30,r16
 2208 017a 8281      		ldd r24,Z+2
 2209 017c 8823      		tst r24
 2210 017e 01F4      		brne .+2
 2211 0180 00C0      		rjmp .L267
 310:quantum/quantum.c ****       }
 2212               		.loc 1 310 0
 2213 0182 0E94 0000 		call reset_keyboard
 2214               	.LVL237:
 2215 0186 00C0      		rjmp .L267
 2216               	.L140:
 314:quantum/quantum.c ****         debug_enable ^= 1;
 2217               		.loc 1 314 0
 2218 0188 F801      		movw r30,r16
 2219 018a 8281      		ldd r24,Z+2
 2220 018c 8823      		tst r24
 2221 018e 01F4      		brne .+2
 2222 0190 00C0      		rjmp .L267
 315:quantum/quantum.c ****         if (debug_enable) {
 2223               		.loc 1 315 0
 2224 0192 8091 0000 		lds r24,debug_config
 2225 0196 982F      		mov r25,r24
 2226 0198 9095      		com r25
 2227 019a 90FB      		bst r25,0
 2228 019c 80F9      		bld r24,0
 2229 019e 8093 0000 		sts debug_config,r24
 2230 01a2 00C0      		rjmp .L267
 2231               	.L204:
 307:quantum/quantum.c ****     case RESET:
 2232               		.loc 1 307 0
 2233 01a4 C631      		cpi r28,22
 2234 01a6 FCE5      		ldi r31,92
 2235 01a8 DF07      		cpc r29,r31
 2236 01aa 01F4      		brne .L309
 2237               	.LBB60:
 663:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 2238               		.loc 1 663 0
 2239 01ac 0E94 0000 		call get_mods
 2240               	.LVL238:
 2241 01b0 982F      		mov r25,r24
 2242               	.LVL239:
 696:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 2243               		.loc 1 696 0
 2244 01b2 F801      		movw r30,r16
 2245 01b4 8281      		ldd r24,Z+2
 2246               	.LVL240:
 2247 01b6 2091 0000 		lds r18,keyboard_report
 2248 01ba 3091 0000 		lds r19,keyboard_report+1
 2249 01be 8823      		tst r24
 2250 01c0 01F0      		breq .L197
 663:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 2251               		.loc 1 663 0
 2252 01c2 9A7A      		andi r25,lo8(-86)
 2253               	.LVL241:
 697:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 2254               		.loc 1 697 0
 2255 01c4 81E0      		ldi r24,lo8(1)
 2256 01c6 01F4      		brne .L198
 2257 01c8 80E0      		ldi r24,0
 2258               	.L198:
 2259 01ca 8093 0000 		sts grave_esc_was_shifted,r24
 698:quantum/quantum.c ****       }
 2260               		.loc 1 698 0
 2261 01ce 9111      		cpse r25,__zero_reg__
 2262 01d0 00C0      		rjmp .L209
 2263 01d2 69E2      		ldi r22,lo8(41)
 2264 01d4 00C0      		rjmp .L199
 2265               	.L209:
 2266 01d6 65E3      		ldi r22,lo8(53)
 2267               	.L199:
 2268               	.LVL242:
 2269               	.LBB61:
 2270               	.LBB62:
 2271               		.file 3 "tmk_core/common/action_util.h"
   1:tmk_core/common/action_util.h **** /*
   2:tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action_util.h **** 
   4:tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action_util.h **** (at your option) any later version.
   8:tmk_core/common/action_util.h **** 
   9:tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:tmk_core/common/action_util.h **** 
  14:tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action_util.h **** */
  17:tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:tmk_core/common/action_util.h **** 
  20:tmk_core/common/action_util.h **** #include <stdint.h>
  21:tmk_core/common/action_util.h **** #include "report.h"
  22:tmk_core/common/action_util.h **** 
  23:tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:tmk_core/common/action_util.h **** extern "C" {
  25:tmk_core/common/action_util.h **** #endif
  26:tmk_core/common/action_util.h **** 
  27:tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:tmk_core/common/action_util.h **** 
  29:tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:tmk_core/common/action_util.h **** 
  31:tmk_core/common/action_util.h **** /* key */
  32:tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 2272               		.loc 3 33 0 discriminator 4
 2273 01d8 C901      		movw r24,r18
 2274 01da 0E94 0000 		call add_key_to_report
 2275               	.LVL243:
 2276 01de 00C0      		rjmp .L200
 2277               	.LVL244:
 2278               	.L197:
 2279               	.LBE62:
 2280               	.LBE61:
 701:quantum/quantum.c ****       }
 2281               		.loc 1 701 0
 2282 01e0 8091 0000 		lds r24,grave_esc_was_shifted
 2283 01e4 8111      		cpse r24,__zero_reg__
 2284 01e6 00C0      		rjmp .L210
 2285 01e8 69E2      		ldi r22,lo8(41)
 2286 01ea 00C0      		rjmp .L201
 2287               	.L210:
 2288 01ec 65E3      		ldi r22,lo8(53)
 2289               	.L201:
 2290               	.LVL245:
 2291               	.LBB63:
 2292               	.LBB64:
  34:tmk_core/common/action_util.h **** }
  35:tmk_core/common/action_util.h **** 
  36:tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 2293               		.loc 3 37 0 discriminator 4
 2294 01ee C901      		movw r24,r18
 2295 01f0 0E94 0000 		call del_key_from_report
 2296               	.LVL246:
 2297               	.L200:
 2298               	.LBE64:
 2299               	.LBE63:
 704:quantum/quantum.c ****       return false;
 2300               		.loc 1 704 0
 2301 01f4 0E94 0000 		call send_keyboard_report
 2302               	.LVL247:
 705:quantum/quantum.c ****     }
 2303               		.loc 1 705 0
 2304 01f8 00C0      		rjmp .L267
 2305               	.L309:
 2306               	.LBE60:
 307:quantum/quantum.c ****     case RESET:
 2307               		.loc 1 307 0
 2308 01fa C23C      		cpi r28,-62
 2309 01fc DC45      		sbci r29,92
 2310 01fe 01F0      		breq .+2
 2311 0200 00C0      		rjmp .L173
 349:quantum/quantum.c ****     #else
 2312               		.loc 1 349 0
 2313 0202 F801      		movw r30,r16
 2314 0204 8281      		ldd r24,Z+2
 2315 0206 8823      		tst r24
 2316 0208 01F4      		brne .+2
 2317 020a 00C0      		rjmp .L267
 353:quantum/quantum.c ****     }
 2318               		.loc 1 353 0
 2319 020c 0E94 0000 		call rgblight_toggle
 2320               	.LVL248:
 2321 0210 00C0      		rjmp .L267
 2322               	.L148:
 391:quantum/quantum.c ****     #else
 2323               		.loc 1 391 0
 2324 0212 F801      		movw r30,r16
 2325 0214 8281      		ldd r24,Z+2
 2326 0216 8823      		tst r24
 2327 0218 01F4      		brne .+2
 2328 021a 00C0      		rjmp .L267
 395:quantum/quantum.c ****     }
 2329               		.loc 1 395 0
 2330 021c 0E94 0000 		call rgblight_decrease_hue
 2331               	.LVL249:
 2332 0220 00C0      		rjmp .L267
 2333               	.L307:
 307:quantum/quantum.c ****     case RESET:
 2334               		.loc 1 307 0
 2335 0222 C53C      		cpi r28,-59
 2336 0224 DC45      		sbci r29,92
 2337 0226 01F0      		breq .+2
 2338 0228 00C0      		rjmp .L173
 381:quantum/quantum.c ****     #else
 2339               		.loc 1 381 0
 2340 022a F801      		movw r30,r16
 2341 022c 8281      		ldd r24,Z+2
 2342 022e 8823      		tst r24
 2343 0230 01F4      		brne .+2
 2344 0232 00C0      		rjmp .L267
 385:quantum/quantum.c ****     }
 2345               		.loc 1 385 0
 2346 0234 0E94 0000 		call rgblight_increase_hue
 2347               	.LVL250:
 2348 0238 00C0      		rjmp .L267
 2349               	.L205:
 2350 023a F801      		movw r30,r16
 2351 023c 8281      		ldd r24,Z+2
 307:quantum/quantum.c ****     case RESET:
 2352               		.loc 1 307 0
 2353 023e C83C      		cpi r28,-56
 2354 0240 FCE5      		ldi r31,92
 2355 0242 DF07      		cpc r29,r31
 2356 0244 01F4      		brne .L310
 411:quantum/quantum.c ****     #else
 2357               		.loc 1 411 0
 2358 0246 8823      		tst r24
 2359 0248 01F4      		brne .+2
 2360 024a 00C0      		rjmp .L267
 415:quantum/quantum.c ****     }
 2361               		.loc 1 415 0
 2362 024c 0E94 0000 		call rgblight_decrease_sat
 2363               	.LVL251:
 2364 0250 00C0      		rjmp .L267
 2365               	.L310:
 307:quantum/quantum.c ****     case RESET:
 2366               		.loc 1 307 0
 2367 0252 C93C      		cpi r28,-55
 2368 0254 DC45      		sbci r29,92
 2369 0256 00F4      		brsh .L311
 401:quantum/quantum.c ****     #else
 2370               		.loc 1 401 0
 2371 0258 8823      		tst r24
 2372 025a 01F4      		brne .+2
 2373 025c 00C0      		rjmp .L267
 405:quantum/quantum.c ****     }
 2374               		.loc 1 405 0
 2375 025e 0E94 0000 		call rgblight_increase_sat
 2376               	.LVL252:
 2377 0262 00C0      		rjmp .L267
 2378               	.L311:
 421:quantum/quantum.c ****     #else
 2379               		.loc 1 421 0
 2380 0264 8823      		tst r24
 2381 0266 01F4      		brne .+2
 2382 0268 00C0      		rjmp .L267
 425:quantum/quantum.c ****     }
 2383               		.loc 1 425 0
 2384 026a 0E94 0000 		call rgblight_increase_val
 2385               	.LVL253:
 2386 026e 00C0      		rjmp .L267
 2387               	.L202:
 307:quantum/quantum.c ****     case RESET:
 2388               		.loc 1 307 0
 2389 0270 C13D      		cpi r28,-47
 2390 0272 ECE5      		ldi r30,92
 2391 0274 DE07      		cpc r29,r30
 2392 0276 01F4      		brne .L312
 491:quantum/quantum.c ****       if ((RGBLIGHT_MODE_SNAKE <= rgblight_get_mode()) &&
 2393               		.loc 1 491 0
 2394 0278 F801      		movw r30,r16
 2395 027a 8281      		ldd r24,Z+2
 2396 027c 8823      		tst r24
 2397 027e 01F4      		brne .+2
 2398 0280 00C0      		rjmp .L267
 492:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_SNAKE_end)) {
 2399               		.loc 1 492 0
 2400 0282 0E94 0000 		call rgblight_get_mode
 2401               	.LVL254:
 2402 0286 8F30      		cpi r24,lo8(15)
 2403 0288 00F0      		brlo .L163
 493:quantum/quantum.c ****         rgblight_step();
 2404               		.loc 1 493 0 discriminator 1
 2405 028a 0E94 0000 		call rgblight_get_mode
 2406               	.LVL255:
 492:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_SNAKE_end)) {
 2407               		.loc 1 492 0 discriminator 1
 2408 028e 8431      		cpi r24,lo8(20)
 2409 0290 00F4      		brsh .+2
 2410 0292 00C0      		rjmp .L144
 2411               	.L163:
 496:quantum/quantum.c ****       }
 2412               		.loc 1 496 0
 2413 0294 8FE0      		ldi r24,lo8(15)
 2414               	.L300:
 460:quantum/quantum.c ****       }
 2415               		.loc 1 460 0
 2416 0296 0E94 0000 		call rgblight_mode
 2417               	.LVL256:
 2418 029a 00C0      		rjmp .L267
 2419               	.L312:
 307:quantum/quantum.c ****     case RESET:
 2420               		.loc 1 307 0
 2421 029c C23D      		cpi r28,-46
 2422 029e FCE5      		ldi r31,92
 2423 02a0 DF07      		cpc r29,r31
 2424 02a2 00F0      		brlo .+2
 2425 02a4 00C0      		rjmp .L206
 2426 02a6 CD3C      		cpi r28,-51
 2427 02a8 8CE5      		ldi r24,92
 2428 02aa D807      		cpc r29,r24
 2429 02ac 01F4      		brne .L313
 449:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_STATIC_LIGHT);
 2430               		.loc 1 449 0
 2431 02ae F801      		movw r30,r16
 2432 02b0 8281      		ldd r24,Z+2
 2433 02b2 8823      		tst r24
 2434 02b4 01F4      		brne .+2
 2435 02b6 00C0      		rjmp .L267
 450:quantum/quantum.c ****     }
 2436               		.loc 1 450 0
 2437 02b8 81E0      		ldi r24,lo8(1)
 2438 02ba 00C0      		rjmp .L300
 2439               	.L313:
 307:quantum/quantum.c ****     case RESET:
 2440               		.loc 1 307 0
 2441 02bc CE3C      		cpi r28,-50
 2442 02be 9CE5      		ldi r25,92
 2443 02c0 D907      		cpc r29,r25
 2444 02c2 00F4      		brsh .L207
 2445 02c4 CB3C      		cpi r28,-53
 2446 02c6 ECE5      		ldi r30,92
 2447 02c8 DE07      		cpc r29,r30
 2448 02ca 01F4      		brne .L314
 439:quantum/quantum.c ****       rgblight_increase_speed();
 2449               		.loc 1 439 0
 2450 02cc F801      		movw r30,r16
 2451 02ce 8281      		ldd r24,Z+2
 2452 02d0 8823      		tst r24
 2453 02d2 01F4      		brne .+2
 2454 02d4 00C0      		rjmp .L267
 440:quantum/quantum.c ****     }
 2455               		.loc 1 440 0
 2456 02d6 0E94 0000 		call rgblight_increase_speed
 2457               	.LVL257:
 2458 02da 00C0      		rjmp .L267
 2459               	.L314:
 307:quantum/quantum.c ****     case RESET:
 2460               		.loc 1 307 0
 2461 02dc CC3C      		cpi r28,-52
 2462 02de DC45      		sbci r29,92
 2463 02e0 01F0      		breq .+2
 2464 02e2 00C0      		rjmp .L173
 444:quantum/quantum.c ****       rgblight_decrease_speed();
 2465               		.loc 1 444 0
 2466 02e4 F801      		movw r30,r16
 2467 02e6 8281      		ldd r24,Z+2
 2468 02e8 8823      		tst r24
 2469 02ea 01F4      		brne .+2
 2470 02ec 00C0      		rjmp .L267
 445:quantum/quantum.c ****     }
 2471               		.loc 1 445 0
 2472 02ee 0E94 0000 		call rgblight_decrease_speed
 2473               	.LVL258:
 2474 02f2 00C0      		rjmp .L267
 2475               	.L207:
 2476 02f4 F801      		movw r30,r16
 2477 02f6 8281      		ldd r24,Z+2
 307:quantum/quantum.c ****     case RESET:
 2478               		.loc 1 307 0
 2479 02f8 CF3C      		cpi r28,-49
 2480 02fa FCE5      		ldi r31,92
 2481 02fc DF07      		cpc r29,r31
 2482 02fe 01F4      		brne .L315
 467:quantum/quantum.c ****       if ((RGBLIGHT_MODE_RAINBOW_MOOD <= rgblight_get_mode()) &&
 2483               		.loc 1 467 0
 2484 0300 8823      		tst r24
 2485 0302 01F4      		brne .+2
 2486 0304 00C0      		rjmp .L267
 468:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_MOOD_end)) {
 2487               		.loc 1 468 0
 2488 0306 0E94 0000 		call rgblight_get_mode
 2489               	.LVL259:
 2490 030a 8630      		cpi r24,lo8(6)
 2491 030c 00F0      		brlo .L159
 469:quantum/quantum.c ****         rgblight_step();
 2492               		.loc 1 469 0 discriminator 1
 2493 030e 0E94 0000 		call rgblight_get_mode
 2494               	.LVL260:
 468:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_MOOD_end)) {
 2495               		.loc 1 468 0 discriminator 1
 2496 0312 8830      		cpi r24,lo8(8)
 2497 0314 00F4      		brsh .+2
 2498 0316 00C0      		rjmp .L144
 2499               	.L159:
 472:quantum/quantum.c ****       }
 2500               		.loc 1 472 0
 2501 0318 86E0      		ldi r24,lo8(6)
 2502 031a 00C0      		rjmp .L300
 2503               	.L315:
 307:quantum/quantum.c ****     case RESET:
 2504               		.loc 1 307 0
 2505 031c C03D      		cpi r28,-48
 2506 031e DC45      		sbci r29,92
 2507 0320 00F4      		brsh .L316
 455:quantum/quantum.c ****       if ((RGBLIGHT_MODE_BREATHING <= rgblight_get_mode()) &&
 2508               		.loc 1 455 0
 2509 0322 8823      		tst r24
 2510 0324 01F4      		brne .+2
 2511 0326 00C0      		rjmp .L267
 456:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_BREATHING_end)) {
 2512               		.loc 1 456 0
 2513 0328 0E94 0000 		call rgblight_get_mode
 2514               	.LVL261:
 2515 032c 8230      		cpi r24,lo8(2)
 2516 032e 00F0      		brlo .L157
 457:quantum/quantum.c ****         rgblight_step();
 2517               		.loc 1 457 0 discriminator 1
 2518 0330 0E94 0000 		call rgblight_get_mode
 2519               	.LVL262:
 456:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_BREATHING_end)) {
 2520               		.loc 1 456 0 discriminator 1
 2521 0334 8530      		cpi r24,lo8(5)
 2522 0336 00F4      		brsh .+2
 2523 0338 00C0      		rjmp .L144
 2524               	.L157:
 460:quantum/quantum.c ****       }
 2525               		.loc 1 460 0
 2526 033a 82E0      		ldi r24,lo8(2)
 2527 033c 00C0      		rjmp .L300
 2528               	.L316:
 479:quantum/quantum.c ****       if ((RGBLIGHT_MODE_RAINBOW_SWIRL <= rgblight_get_mode()) &&
 2529               		.loc 1 479 0
 2530 033e 8823      		tst r24
 2531 0340 01F4      		brne .+2
 2532 0342 00C0      		rjmp .L267
 480:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_SWIRL_end)) {
 2533               		.loc 1 480 0
 2534 0344 0E94 0000 		call rgblight_get_mode
 2535               	.LVL263:
 2536 0348 8930      		cpi r24,lo8(9)
 2537 034a 00F0      		brlo .L161
 481:quantum/quantum.c ****         rgblight_step();
 2538               		.loc 1 481 0 discriminator 1
 2539 034c 0E94 0000 		call rgblight_get_mode
 2540               	.LVL264:
 480:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_SWIRL_end)) {
 2541               		.loc 1 480 0 discriminator 1
 2542 0350 8E30      		cpi r24,lo8(14)
 2543 0352 00F4      		brsh .+2
 2544 0354 00C0      		rjmp .L144
 2545               	.L161:
 484:quantum/quantum.c ****       }
 2546               		.loc 1 484 0
 2547 0356 89E0      		ldi r24,lo8(9)
 2548 0358 00C0      		rjmp .L300
 2549               	.L206:
 307:quantum/quantum.c ****     case RESET:
 2550               		.loc 1 307 0
 2551 035a C53D      		cpi r28,-43
 2552 035c ECE5      		ldi r30,92
 2553 035e DE07      		cpc r29,r30
 2554 0360 01F4      		brne .L317
 534:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_RGB_TEST);
 2555               		.loc 1 534 0
 2556 0362 F801      		movw r30,r16
 2557 0364 8281      		ldd r24,Z+2
 2558 0366 8823      		tst r24
 2559 0368 01F4      		brne .+2
 2560 036a 00C0      		rjmp .L267
 535:quantum/quantum.c ****     }
 2561               		.loc 1 535 0
 2562 036c 83E2      		ldi r24,lo8(35)
 2563 036e 00C0      		rjmp .L300
 2564               	.L317:
 307:quantum/quantum.c ****     case RESET:
 2565               		.loc 1 307 0
 2566 0370 C63D      		cpi r28,-42
 2567 0372 FCE5      		ldi r31,92
 2568 0374 DF07      		cpc r29,r31
 2569 0376 00F4      		brsh .L208
 2570 0378 F801      		movw r30,r16
 2571 037a 8281      		ldd r24,Z+2
 2572 037c C33D      		cpi r28,-45
 2573 037e FCE5      		ldi r31,92
 2574 0380 DF07      		cpc r29,r31
 2575 0382 01F4      		brne .L318
 515:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_CHRISTMAS);
 2576               		.loc 1 515 0
 2577 0384 8823      		tst r24
 2578 0386 01F4      		brne .+2
 2579 0388 00C0      		rjmp .L267
 516:quantum/quantum.c ****     }
 2580               		.loc 1 516 0
 2581 038a 88E1      		ldi r24,lo8(24)
 2582 038c 00C0      		rjmp .L300
 2583               	.L318:
 307:quantum/quantum.c ****     case RESET:
 2584               		.loc 1 307 0
 2585 038e C43D      		cpi r28,-44
 2586 0390 DC45      		sbci r29,92
 2587 0392 00F4      		brsh .L319
 503:quantum/quantum.c ****       if ((RGBLIGHT_MODE_KNIGHT <= rgblight_get_mode()) &&
 2588               		.loc 1 503 0
 2589 0394 8823      		tst r24
 2590 0396 01F0      		breq .L267
 504:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_KNIGHT_end)) {
 2591               		.loc 1 504 0
 2592 0398 0E94 0000 		call rgblight_get_mode
 2593               	.LVL265:
 2594 039c 8531      		cpi r24,lo8(21)
 2595 039e 00F0      		brlo .L165
 505:quantum/quantum.c ****         rgblight_step();
 2596               		.loc 1 505 0 discriminator 1
 2597 03a0 0E94 0000 		call rgblight_get_mode
 2598               	.LVL266:
 504:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_KNIGHT_end)) {
 2599               		.loc 1 504 0 discriminator 1
 2600 03a4 8731      		cpi r24,lo8(23)
 2601 03a6 00F4      		brsh .+2
 2602 03a8 00C0      		rjmp .L144
 2603               	.L165:
 508:quantum/quantum.c ****       }
 2604               		.loc 1 508 0
 2605 03aa 85E1      		ldi r24,lo8(21)
 2606 03ac 00C0      		rjmp .L300
 2607               	.L319:
 522:quantum/quantum.c ****       if ((RGBLIGHT_MODE_STATIC_GRADIENT <= rgblight_get_mode()) &&
 2608               		.loc 1 522 0
 2609 03ae 8823      		tst r24
 2610 03b0 01F0      		breq .L267
 523:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_STATIC_GRADIENT_end)) {
 2611               		.loc 1 523 0
 2612 03b2 0E94 0000 		call rgblight_get_mode
 2613               	.LVL267:
 2614 03b6 8931      		cpi r24,lo8(25)
 2615 03b8 00F0      		brlo .L168
 524:quantum/quantum.c ****         rgblight_step();
 2616               		.loc 1 524 0 discriminator 1
 2617 03ba 0E94 0000 		call rgblight_get_mode
 2618               	.LVL268:
 523:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_STATIC_GRADIENT_end)) {
 2619               		.loc 1 523 0 discriminator 1
 2620 03be 8232      		cpi r24,lo8(34)
 2621 03c0 00F4      		brsh .+2
 2622 03c2 00C0      		rjmp .L144
 2623               	.L168:
 527:quantum/quantum.c ****       }
 2624               		.loc 1 527 0
 2625 03c4 89E1      		ldi r24,lo8(25)
 2626 03c6 00C0      		rjmp .L300
 2627               	.L208:
 307:quantum/quantum.c ****     case RESET:
 2628               		.loc 1 307 0
 2629 03c8 CD3D      		cpi r28,-35
 2630 03ca ECE5      		ldi r30,92
 2631 03cc DE07      		cpc r29,r30
 2632 03ce 01F4      		brne .L320
 554:quantum/quantum.c ****         set_output(OUTPUT_USB);
 2633               		.loc 1 554 0
 2634 03d0 F801      		movw r30,r16
 2635 03d2 8281      		ldd r24,Z+2
 2636 03d4 8823      		tst r24
 2637 03d6 01F0      		breq .L267
 555:quantum/quantum.c ****       }
 2638               		.loc 1 555 0
 2639 03d8 82E0      		ldi r24,lo8(2)
 2640               	.L301:
 2641 03da 0E94 0000 		call set_output
 2642               	.LVL269:
 2643 03de 00C0      		rjmp .L267
 2644               	.L320:
 307:quantum/quantum.c ****     case RESET:
 2645               		.loc 1 307 0
 2646 03e0 CE3D      		cpi r28,-34
 2647 03e2 FCE5      		ldi r31,92
 2648 03e4 DF07      		cpc r29,r31
 2649 03e6 01F4      		brne .L321
 324:quantum/quantum.c ****           eeconfig_init();
 2650               		.loc 1 324 0
 2651 03e8 F801      		movw r30,r16
 2652 03ea 8281      		ldd r24,Z+2
 2653 03ec 8823      		tst r24
 2654 03ee 01F0      		breq .L267
 325:quantum/quantum.c ****       }
 2655               		.loc 1 325 0
 2656 03f0 0E94 0000 		call eeconfig_init
 2657               	.LVL270:
 2658 03f4 00C0      		rjmp .L267
 2659               	.L321:
 307:quantum/quantum.c ****     case RESET:
 2660               		.loc 1 307 0
 2661 03f6 CC3D      		cpi r28,-36
 2662 03f8 DC45      		sbci r29,92
 2663 03fa 01F0      		breq .+2
 2664 03fc 00C0      		rjmp .L173
 549:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 2665               		.loc 1 549 0
 2666 03fe F801      		movw r30,r16
 2667 0400 8281      		ldd r24,Z+2
 2668 0402 8823      		tst r24
 2669 0404 01F0      		breq .L267
 550:quantum/quantum.c ****       }
 2670               		.loc 1 550 0
 2671 0406 80E0      		ldi r24,0
 2672 0408 00C0      		rjmp .L301
 2673               	.L267:
 718:quantum/quantum.c **** 
 2674               		.loc 1 718 0
 2675 040a 80E0      		ldi r24,0
 2676               	/* epilogue start */
 2677 040c DF91      		pop r29
 2678 040e CF91      		pop r28
 2679               	.LVL271:
 2680 0410 1F91      		pop r17
 2681 0412 0F91      		pop r16
 2682               	.LVL272:
 2683 0414 0895      		ret
 2684               		.cfi_endproc
 2685               	.LFE125:
 2687               		.weak	ascii_to_keycode_lut
 2688               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2691               	ascii_to_keycode_lut:
 2692 0000 00        		.byte	0
 2693 0001 00        		.byte	0
 2694 0002 00        		.byte	0
 2695 0003 00        		.byte	0
 2696 0004 00        		.byte	0
 2697 0005 00        		.byte	0
 2698 0006 00        		.byte	0
 2699 0007 00        		.byte	0
 2700 0008 2A        		.byte	42
 2701 0009 2B        		.byte	43
 2702 000a 28        		.byte	40
 2703 000b 00        		.byte	0
 2704 000c 00        		.byte	0
 2705 000d 00        		.byte	0
 2706 000e 00        		.byte	0
 2707 000f 00        		.byte	0
 2708 0010 00        		.byte	0
 2709 0011 00        		.byte	0
 2710 0012 00        		.byte	0
 2711 0013 00        		.byte	0
 2712 0014 00        		.byte	0
 2713 0015 00        		.byte	0
 2714 0016 00        		.byte	0
 2715 0017 00        		.byte	0
 2716 0018 00        		.byte	0
 2717 0019 00        		.byte	0
 2718 001a 00        		.byte	0
 2719 001b 29        		.byte	41
 2720 001c 00        		.byte	0
 2721 001d 00        		.byte	0
 2722 001e 00        		.byte	0
 2723 001f 00        		.byte	0
 2724 0020 2C        		.byte	44
 2725 0021 1E        		.byte	30
 2726 0022 34        		.byte	52
 2727 0023 20        		.byte	32
 2728 0024 21        		.byte	33
 2729 0025 22        		.byte	34
 2730 0026 24        		.byte	36
 2731 0027 34        		.byte	52
 2732 0028 26        		.byte	38
 2733 0029 27        		.byte	39
 2734 002a 25        		.byte	37
 2735 002b 2E        		.byte	46
 2736 002c 36        		.byte	54
 2737 002d 2D        		.byte	45
 2738 002e 37        		.byte	55
 2739 002f 38        		.byte	56
 2740 0030 27        		.byte	39
 2741 0031 1E        		.byte	30
 2742 0032 1F        		.byte	31
 2743 0033 20        		.byte	32
 2744 0034 21        		.byte	33
 2745 0035 22        		.byte	34
 2746 0036 23        		.byte	35
 2747 0037 24        		.byte	36
 2748 0038 25        		.byte	37
 2749 0039 26        		.byte	38
 2750 003a 33        		.byte	51
 2751 003b 33        		.byte	51
 2752 003c 36        		.byte	54
 2753 003d 2E        		.byte	46
 2754 003e 37        		.byte	55
 2755 003f 38        		.byte	56
 2756 0040 1F        		.byte	31
 2757 0041 04        		.byte	4
 2758 0042 05        		.byte	5
 2759 0043 06        		.byte	6
 2760 0044 07        		.byte	7
 2761 0045 08        		.byte	8
 2762 0046 09        		.byte	9
 2763 0047 0A        		.byte	10
 2764 0048 0B        		.byte	11
 2765 0049 0C        		.byte	12
 2766 004a 0D        		.byte	13
 2767 004b 0E        		.byte	14
 2768 004c 0F        		.byte	15
 2769 004d 10        		.byte	16
 2770 004e 11        		.byte	17
 2771 004f 12        		.byte	18
 2772 0050 13        		.byte	19
 2773 0051 14        		.byte	20
 2774 0052 15        		.byte	21
 2775 0053 16        		.byte	22
 2776 0054 17        		.byte	23
 2777 0055 18        		.byte	24
 2778 0056 19        		.byte	25
 2779 0057 1A        		.byte	26
 2780 0058 1B        		.byte	27
 2781 0059 1C        		.byte	28
 2782 005a 1D        		.byte	29
 2783 005b 2F        		.byte	47
 2784 005c 31        		.byte	49
 2785 005d 30        		.byte	48
 2786 005e 23        		.byte	35
 2787 005f 2D        		.byte	45
 2788 0060 35        		.byte	53
 2789 0061 04        		.byte	4
 2790 0062 05        		.byte	5
 2791 0063 06        		.byte	6
 2792 0064 07        		.byte	7
 2793 0065 08        		.byte	8
 2794 0066 09        		.byte	9
 2795 0067 0A        		.byte	10
 2796 0068 0B        		.byte	11
 2797 0069 0C        		.byte	12
 2798 006a 0D        		.byte	13
 2799 006b 0E        		.byte	14
 2800 006c 0F        		.byte	15
 2801 006d 10        		.byte	16
 2802 006e 11        		.byte	17
 2803 006f 12        		.byte	18
 2804 0070 13        		.byte	19
 2805 0071 14        		.byte	20
 2806 0072 15        		.byte	21
 2807 0073 16        		.byte	22
 2808 0074 17        		.byte	23
 2809 0075 18        		.byte	24
 2810 0076 19        		.byte	25
 2811 0077 1A        		.byte	26
 2812 0078 1B        		.byte	27
 2813 0079 1C        		.byte	28
 2814 007a 1D        		.byte	29
 2815 007b 2F        		.byte	47
 2816 007c 31        		.byte	49
 2817 007d 30        		.byte	48
 2818 007e 35        		.byte	53
 2819 007f 4C        		.byte	76
 2820               		.weak	ascii_to_altgr_lut
 2821               		.section	.progmem.data.ascii_to_altgr_lut,"a",@progbits
 2824               	ascii_to_altgr_lut:
 2825 0000 0000 0000 		.zero	128
 2825      0000 0000 
 2825      0000 0000 
 2825      0000 0000 
 2825      0000 0000 
 2826               		.weak	ascii_to_shift_lut
 2827               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2830               	ascii_to_shift_lut:
 2831 0000 00        		.byte	0
 2832 0001 00        		.byte	0
 2833 0002 00        		.byte	0
 2834 0003 00        		.byte	0
 2835 0004 00        		.byte	0
 2836 0005 00        		.byte	0
 2837 0006 00        		.byte	0
 2838 0007 00        		.byte	0
 2839 0008 00        		.byte	0
 2840 0009 00        		.byte	0
 2841 000a 00        		.byte	0
 2842 000b 00        		.byte	0
 2843 000c 00        		.byte	0
 2844 000d 00        		.byte	0
 2845 000e 00        		.byte	0
 2846 000f 00        		.byte	0
 2847 0010 00        		.byte	0
 2848 0011 00        		.byte	0
 2849 0012 00        		.byte	0
 2850 0013 00        		.byte	0
 2851 0014 00        		.byte	0
 2852 0015 00        		.byte	0
 2853 0016 00        		.byte	0
 2854 0017 00        		.byte	0
 2855 0018 00        		.byte	0
 2856 0019 00        		.byte	0
 2857 001a 00        		.byte	0
 2858 001b 00        		.byte	0
 2859 001c 00        		.byte	0
 2860 001d 00        		.byte	0
 2861 001e 00        		.byte	0
 2862 001f 00        		.byte	0
 2863 0020 00        		.byte	0
 2864 0021 01        		.byte	1
 2865 0022 01        		.byte	1
 2866 0023 01        		.byte	1
 2867 0024 01        		.byte	1
 2868 0025 01        		.byte	1
 2869 0026 01        		.byte	1
 2870 0027 00        		.byte	0
 2871 0028 01        		.byte	1
 2872 0029 01        		.byte	1
 2873 002a 01        		.byte	1
 2874 002b 01        		.byte	1
 2875 002c 00        		.byte	0
 2876 002d 00        		.byte	0
 2877 002e 00        		.byte	0
 2878 002f 00        		.byte	0
 2879 0030 00        		.byte	0
 2880 0031 00        		.byte	0
 2881 0032 00        		.byte	0
 2882 0033 00        		.byte	0
 2883 0034 00        		.byte	0
 2884 0035 00        		.byte	0
 2885 0036 00        		.byte	0
 2886 0037 00        		.byte	0
 2887 0038 00        		.byte	0
 2888 0039 00        		.byte	0
 2889 003a 01        		.byte	1
 2890 003b 00        		.byte	0
 2891 003c 01        		.byte	1
 2892 003d 00        		.byte	0
 2893 003e 01        		.byte	1
 2894 003f 01        		.byte	1
 2895 0040 01        		.byte	1
 2896 0041 01        		.byte	1
 2897 0042 01        		.byte	1
 2898 0043 01        		.byte	1
 2899 0044 01        		.byte	1
 2900 0045 01        		.byte	1
 2901 0046 01        		.byte	1
 2902 0047 01        		.byte	1
 2903 0048 01        		.byte	1
 2904 0049 01        		.byte	1
 2905 004a 01        		.byte	1
 2906 004b 01        		.byte	1
 2907 004c 01        		.byte	1
 2908 004d 01        		.byte	1
 2909 004e 01        		.byte	1
 2910 004f 01        		.byte	1
 2911 0050 01        		.byte	1
 2912 0051 01        		.byte	1
 2913 0052 01        		.byte	1
 2914 0053 01        		.byte	1
 2915 0054 01        		.byte	1
 2916 0055 01        		.byte	1
 2917 0056 01        		.byte	1
 2918 0057 01        		.byte	1
 2919 0058 01        		.byte	1
 2920 0059 01        		.byte	1
 2921 005a 01        		.byte	1
 2922 005b 00        		.byte	0
 2923 005c 00        		.byte	0
 2924 005d 00        		.byte	0
 2925 005e 01        		.byte	1
 2926 005f 01        		.byte	1
 2927 0060 00        		.byte	0
 2928 0061 00        		.byte	0
 2929 0062 00        		.byte	0
 2930 0063 00        		.byte	0
 2931 0064 00        		.byte	0
 2932 0065 00        		.byte	0
 2933 0066 00        		.byte	0
 2934 0067 00        		.byte	0
 2935 0068 00        		.byte	0
 2936 0069 00        		.byte	0
 2937 006a 00        		.byte	0
 2938 006b 00        		.byte	0
 2939 006c 00        		.byte	0
 2940 006d 00        		.byte	0
 2941 006e 00        		.byte	0
 2942 006f 00        		.byte	0
 2943 0070 00        		.byte	0
 2944 0071 00        		.byte	0
 2945 0072 00        		.byte	0
 2946 0073 00        		.byte	0
 2947 0074 00        		.byte	0
 2948 0075 00        		.byte	0
 2949 0076 00        		.byte	0
 2950 0077 00        		.byte	0
 2951 0078 00        		.byte	0
 2952 0079 00        		.byte	0
 2953 007a 00        		.byte	0
 2954 007b 01        		.byte	1
 2955 007c 01        		.byte	1
 2956 007d 01        		.byte	1
 2957 007e 01        		.byte	1
 2958 007f 00        		.byte	0
 2959               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2962               	grave_esc_was_shifted:
 2963 0000 00        		.zero	1
 2964               		.text
 2965               	.Letext0:
 2966               		.file 4 "d:\\program files\\msys2\\home\\bnguy\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\stdin
 2967               		.file 5 "tmk_core/common/keyboard.h"
 2968               		.file 6 "tmk_core/common/action.h"
 2969               		.file 7 "tmk_core/common/report.h"
 2970               		.file 8 "tmk_core/common/debug.h"
 2971               		.file 9 "quantum/keycode_config.h"
 2972               		.file 10 "tmk_core/common/keycode.h"
 2973               		.file 11 "quantum/quantum_keycodes.h"
 2974               		.file 12 "quantum/rgblight.h"
 2975               		.file 13 "tmk_core/common/action_layer.h"
 2976               		.file 14 "tmk_core/protocol/lufa/outputselect.h"
 2977               		.file 15 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2978               		.file 16 "quantum/quantum.h"
 2979               		.file 17 "quantum/keymap.h"
 2980               		.file 18 "tmk_core/common/eeconfig.h"
 2981               		.file 19 "tmk_core/common/matrix.h"
 2982               		.file 20 "tmk_core/common/bootloader.h"
 2983               		.file 21 "quantum/process_keycode/process_space_cadet.h"
DEFINED SYMBOLS
                            *ABS*:00000000 quantum.c
D:\Program Files\msys2\tmp\ccWA55vR.s:2      *ABS*:0000003e __SP_H__
D:\Program Files\msys2\tmp\ccWA55vR.s:3      *ABS*:0000003d __SP_L__
D:\Program Files\msys2\tmp\ccWA55vR.s:4      *ABS*:0000003f __SREG__
D:\Program Files\msys2\tmp\ccWA55vR.s:5      *ABS*:00000000 __tmp_reg__
D:\Program Files\msys2\tmp\ccWA55vR.s:6      *ABS*:00000001 __zero_reg__
D:\Program Files\msys2\tmp\ccWA55vR.s:12     .text.do_code16:00000000 do_code16
D:\Program Files\msys2\tmp\ccWA55vR.s:129    .text.qk_register_mods:00000000 qk_register_mods
D:\Program Files\msys2\tmp\ccWA55vR.s:159    .text.qk_register_weak_mods:00000000 qk_register_weak_mods
D:\Program Files\msys2\tmp\ccWA55vR.s:172    .text.qk_unregister_mods:00000000 qk_unregister_mods
D:\Program Files\msys2\tmp\ccWA55vR.s:202    .text.qk_unregister_weak_mods:00000000 qk_unregister_weak_mods
D:\Program Files\msys2\tmp\ccWA55vR.s:216    .text.register_code16:00000000 register_code16
D:\Program Files\msys2\tmp\ccWA55vR.s:273    .text.unregister_code16:00000000 unregister_code16
D:\Program Files\msys2\tmp\ccWA55vR.s:328    .text.tap_code16:00000000 tap_code16
D:\Program Files\msys2\tmp\ccWA55vR.s:365    .text.process_action_kb:00000000 process_action_kb
D:\Program Files\msys2\tmp\ccWA55vR.s:384    .text.process_record_user:00000000 process_record_user
D:\Program Files\msys2\tmp\ccWA55vR.s:403    .text.process_record_kb:00000000 process_record_kb
D:\Program Files\msys2\tmp\ccWA55vR.s:421    .text.get_event_keycode:00000000 get_event_keycode
D:\Program Files\msys2\tmp\ccWA55vR.s:516    .text.get_record_keycode:00000000 get_record_keycode
D:\Program Files\msys2\tmp\ccWA55vR.s:541    .text.send_char:00000000 send_char
D:\Program Files\msys2\tmp\ccWA55vR.s:2691   .progmem.data.ascii_to_keycode_lut:00000000 ascii_to_keycode_lut
D:\Program Files\msys2\tmp\ccWA55vR.s:2830   .progmem.data.ascii_to_shift_lut:00000000 ascii_to_shift_lut
D:\Program Files\msys2\tmp\ccWA55vR.s:2824   .progmem.data.ascii_to_altgr_lut:00000000 ascii_to_altgr_lut
D:\Program Files\msys2\tmp\ccWA55vR.s:669    .text.send_string_with_delay:00000000 send_string_with_delay
D:\Program Files\msys2\tmp\ccWA55vR.s:814    .text.send_string:00000000 send_string
D:\Program Files\msys2\tmp\ccWA55vR.s:833    .text.send_string_with_delay_P:00000000 send_string_with_delay_P
D:\Program Files\msys2\tmp\ccWA55vR.s:1009   .text.send_string_P:00000000 send_string_P
D:\Program Files\msys2\tmp\ccWA55vR.s:1028   .text.set_single_persistent_default_layer:00000000 set_single_persistent_default_layer
D:\Program Files\msys2\tmp\ccWA55vR.s:1077   .text.update_tri_layer_state:00000000 update_tri_layer_state
D:\Program Files\msys2\tmp\ccWA55vR.s:1232   .text.update_tri_layer:00000000 update_tri_layer
D:\Program Files\msys2\tmp\ccWA55vR.s:1271   .text.tap_random_base64:00000000 tap_random_base64
D:\Program Files\msys2\tmp\ccWA55vR.s:1398   .text.bootmagic_lite:00000000 bootmagic_lite
D:\Program Files\msys2\tmp\ccWA55vR.s:1444   .text.matrix_init_quantum:00000000 matrix_init_quantum
D:\Program Files\msys2\tmp\ccWA55vR.s:1470   .text.matrix_scan_quantum:00000000 matrix_scan_quantum
D:\Program Files\msys2\tmp\ccWA55vR.s:1487   .text.send_nibble:00000000 send_nibble
D:\Program Files\msys2\tmp\ccWA55vR.s:1551   .text.send_byte:00000000 send_byte
D:\Program Files\msys2\tmp\ccWA55vR.s:1588   .text.send_word:00000000 send_word
D:\Program Files\msys2\tmp\ccWA55vR.s:1622   .text.send_dword:00000000 send_dword
D:\Program Files\msys2\tmp\ccWA55vR.s:1672   .text.hex_to_keycode:00000000 hex_to_keycode
D:\Program Files\msys2\tmp\ccWA55vR.s:1711   .text.api_send_unicode:00000000 api_send_unicode
D:\Program Files\msys2\tmp\ccWA55vR.s:1727   .text.led_set_user:00000000 led_set_user
D:\Program Files\msys2\tmp\ccWA55vR.s:1727   .text.led_set_user:00000000 led_set_user.localalias.1
D:\Program Files\msys2\tmp\ccWA55vR.s:1744   .text.backlight_set:00000000 backlight_set
D:\Program Files\msys2\tmp\ccWA55vR.s:1758   .text.led_set_kb:00000000 led_set_kb
D:\Program Files\msys2\tmp\ccWA55vR.s:1776   .text.led_set:00000000 led_set
D:\Program Files\msys2\tmp\ccWA55vR.s:1794   .text.shutdown_user:00000000 shutdown_user
D:\Program Files\msys2\tmp\ccWA55vR.s:1794   .text.shutdown_user:00000000 shutdown_user.localalias.0
D:\Program Files\msys2\tmp\ccWA55vR.s:1810   .text.startup_user:00000000 startup_user
D:\Program Files\msys2\tmp\ccWA55vR.s:1824   .text.led_init_ports:00000000 led_init_ports
D:\Program Files\msys2\tmp\ccWA55vR.s:1838   .text.backlight_init_ports:00000000 backlight_init_ports
D:\Program Files\msys2\tmp\ccWA55vR.s:1852   .text.reset_keyboard:00000000 reset_keyboard
D:\Program Files\msys2\tmp\ccWA55vR.s:1890   .text.process_record_quantum:00000000 process_record_quantum
D:\Program Files\msys2\tmp\ccWA55vR.s:2962   .bss.grave_esc_was_shifted:00000000 grave_esc_was_shifted

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
read_source_layers_cache
keymap_key_to_keycode
tap_code
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_scan
matrix_get_row
eeconfig_disable
bootloader_jump
eeconfig_is_enabled
eeconfig_init
matrix_init_kb
matrix_scan_kb
clear_keyboard
process_space_cadet
rgblight_decrease_val
get_mods
rgblight_step_reverse
rgblight_step
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
debug_config
keyboard_report
add_key_to_report
del_key_from_report
rgblight_toggle
rgblight_decrease_hue
rgblight_increase_hue
rgblight_decrease_sat
rgblight_increase_sat
rgblight_increase_val
rgblight_get_mode
rgblight_mode
rgblight_increase_speed
rgblight_decrease_speed
set_output
__do_clear_bss
